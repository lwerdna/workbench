The "exchange" part in arm/thumb instructions like `bx` and `blx` have confused me for too long. It's time I run some tests (using [unicorn engine emulator](https://www.unicorn-engine.org/)) and commit these instructions' behavior to memory once and for all.

Summary:

1. when the operand is a register, it contains an absolute address whose lsb marks the destination mode (0 for arm, 1 for thumb).
2. when the operand is a displacement, the mode always flips (exchanges) with the current mode

In other words, exchange instructions that use a register **may** change the state while instructions that use displacements **will** change the state.

Tabulated:

| instruction    | destination mode                           |
| -------------- | ------------------------------------------ |
| `bx Rm`        | lsb of Rm                                  |
| `bx{cond} Rm`  | lsb of Rm                                  |
| `bx label`     | (this instruction form doesn't exist)      |
| `blx` Rm       | lsb of Rm                                  |
| `blx{cond} Rm` | lsb of Rm                                  |
| `blx label`    | opposite of current mode (always exchange) |

The link register `lr` will be set by `blx` to the pointer to instruction following the source instruction. If the source of the branch was in thumb mode, the pointer will have its lsb set, otherwise it will be cleared.

## Thumb function pointers, not addresses, have lsb set

It's a common misconception the arm/thumb state is stored in the lsb of PC, or that thumb functions start at odd misaligned boundaries. This is not true. The **address** in PC and the **address** of all functions are always aligned on even boundaries.

The function **pointers**, however, may have a lsb set to signal `bx` and `blx` to set the appropriate destination mode.

So a `blx` to function **pointer** 0x4000001 executes the function stored at **address** 0x4000000  in thumb mode.

Sometimes the address and pointer have the same value. A `blx` to function **pointer** 0x4001000 executes the function stored at **address** 0x4001000 in arm mode.

The actual arm/thumb state is stored in the T bit (bit 5) of the CPSR.

## experiments: bx rm

### arm to arm

The T flag **remains clear** because the lsb of pointer 0 is clear:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000000  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000000  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### arm to thumb

The T flag **is set** because the lsb of pointer 1 is set:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

The T flag **is cleared** because the lsb of pointer 1 is clear:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### thumb to thumb 

The T flag **remains set** because the lsb of pointer 1 is set:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

## experiments: blx rm

### arm to arm

The T flag **remains clear** and `lr` points to next arm instruction at 0xC:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000D  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### arm to thumb

The T flag **is set** and `lr` points to the next arm instruction at 0xC:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

The T flag **is cleared** and `lr` points with value 0xB to the thumb instruction at actual address 0xA:

```
> r3 = 0
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000B  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### thumb to thumb

The T flag **remains clear** and `lr` points with value 0xB to the thumb instruction at actual address 0xA:

```
> r
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000B  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

## experiments: blx label

### arm to thumb

Though the effective address is 8, with lsb clear, the displacement form of blx **always changes** state, so the T flag goes from clear to set:

```
> pc = 0
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx 8
arm-assembled 00000000: 000000fa  (4 bytes)
starting emulation at pointer: 0x00000000
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

Bouncing back to 0, the displacement form of blx again **always changes** state, so the T flag goes from set to clear:

```
> r
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx 0
thumb-assembled 00000008: fff7faef  (4 bytes)
starting emulation at pointer: 0x00000009
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000D  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

