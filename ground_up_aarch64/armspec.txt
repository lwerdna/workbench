IFORM: ABS_advsimd
	TYPE: instruction
	XML: abs_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|opcode=01011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ABS_asisdmisc_R
			OPERATION: ABS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean neg = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=01011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ABS_asimdmisc_R
			OPERATION: ABS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: ADC
	TYPE: instruction
	XML: adc.xml
	CLASS: no_s
		FIELDS32: sf=x|op=0|S=0|11010000|Rm=xxxxx|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADC_32_addsub_carry
			OPERATION: ADC
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADC_64_addsub_carry
			OPERATION: ADC
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');

IFORM: ADCS
	TYPE: instruction
	XML: adcs.xml
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|11010000|Rm=xxxxx|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADCS_32_addsub_carry
			OPERATION: ADCS
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADCS_64_addsub_carry
			OPERATION: ADCS
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');

IFORM: ADDG
	TYPE: instruction
	XML: addg.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|op=0|S=0|100011|o2=0|uimm6=xxxxxx|op3=(0)(0)|uimm4=xxxx|Xn=xxxxx|Xd=xxxxx
		ENCODING: ADDG_64_addsub_immtags
			OPERATION: ADDG
			SYNTAX: <Xd|SP>,<Xn|SP>, #<uimm6>, #<uimm4>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			bits(4) tag_offset = uimm4;
			bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
			boolean ADD = TRUE;

IFORM: ADDHN_advsimd
	TYPE: instruction
	XML: addhn_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|01|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDHN_asimddiff_N
			OPERATION: ADDHN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>,<Vm>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean round = (U == '1');

IFORM: ADDP_advsimd_pair
	TYPE: instruction
	XML: addp_advsimd_pair.xml
	CLASS: advsimd
		FIELDS32: 01|U=0|11110|size=xx|11000|opcode=11011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDP_asisdpair_only
			OPERATION: ADDP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = ReduceOp_ADD;

IFORM: ADDP_advsimd_vec
	TYPE: instruction
	XML: addp_advsimd_vec.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDP_asimdsame_only
			OPERATION: ADDP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: ADDS_addsub_ext
	TYPE: instruction
	XML: adds_addsub_ext.xml
	ALIAS: CMN_ADDS_addsub_ext
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDS_32S_addsub_ext
			OPERATION: ADDS
			SYNTAX: <Wd>,<Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADDS_64S_addsub_ext
			OPERATION: ADDS
			SYNTAX: <Xd>,<Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = UInt(imm3);
			if shift > 4 then UNDEFINED;

IFORM: ADDS_addsub_imm
	TYPE: instruction
	XML: adds_addsub_imm.xml
	ALIAS: CMN_ADDS_addsub_imm
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDS_32S_addsub_imm
			OPERATION: ADDS
			SYNTAX: <Wd>,<Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADDS_64S_addsub_imm
			OPERATION: ADDS
			SYNTAX: <Xd>,<Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			bits(datasize) imm;
			case sh of
			    when '0' imm = ZeroExtend(imm12, datasize);
			    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

IFORM: ADDS_addsub_shift
	TYPE: instruction
	XML: adds_addsub_shift.xml
	ALIAS: CMN_ADDS_addsub_shift
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDS_32_addsub_shift
			OPERATION: ADDS
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADDS_64_addsub_shift
			OPERATION: ADDS
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			if shift == '11' then UNDEFINED;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);

IFORM: ADDV_advsimd
	TYPE: instruction
	XML: addv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|11000|opcode=11011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADDV_asimdall_only
			OPERATION: ADDV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = ReduceOp_ADD;

IFORM: ADD_addsub_ext
	TYPE: instruction
	XML: add_addsub_ext.xml
	CLASS: no_s
		FIELDS32: sf=x|op=0|S=0|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADD_32_addsub_ext
			OPERATION: ADD
			SYNTAX: <Wd|WSP>,<Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADD_64_addsub_ext
			OPERATION: ADD
			SYNTAX: <Xd|SP>,<Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = UInt(imm3);
			if shift > 4 then UNDEFINED;

IFORM: ADD_addsub_imm
	TYPE: instruction
	XML: add_addsub_imm.xml
	ALIAS: MOV_ADD_addsub_imm
		sh == '0' && imm12 == '000000000000' && (Rd == '11111' || Rn == '11111')
	CLASS: no_s
		FIELDS32: sf=x|op=0|S=0|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADD_32_addsub_imm
			OPERATION: ADD
			SYNTAX: <Wd|WSP>,<Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADD_64_addsub_imm
			OPERATION: ADD
			SYNTAX: <Xd|SP>,<Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			bits(datasize) imm;
			case sh of
			    when '0' imm = ZeroExtend(imm12, datasize);
			    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

IFORM: ADD_addsub_shift
	TYPE: instruction
	XML: add_addsub_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|op=0|S=0|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADD_32_addsub_shift
			OPERATION: ADD
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ADD_64_addsub_shift
			OPERATION: ADD
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			if shift == '11' then UNDEFINED;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);

IFORM: ADD_advsimd
	TYPE: instruction
	XML: add_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=10000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADD_asisdsame_only
			OPERATION: ADD
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: ADD_asimdsame_only
			OPERATION: ADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (U == '1');

IFORM: ADR
	TYPE: instruction
	XML: adr.xml
	CLASS: literal
		FIELDS32: op=0|immlo=xx|10000|immhi=xxxxxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: ADR_only_pcreladdr
			OPERATION: ADR
			SYNTAX: <Xd>,<label>
		DECODE_PCODE:
			integer d = UInt(Rd);
			boolean page = (op == '1');
			bits(64) imm;
			if page then
			    imm = SignExtend(immhi:immlo:Zeros(12), 64);
			else
			    imm = SignExtend(immhi:immlo, 64);

IFORM: ADRP
	TYPE: instruction
	XML: adrp.xml
	CLASS: literal
		FIELDS32: op=1|immlo=xx|10000|immhi=xxxxxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: ADRP_only_pcreladdr
			OPERATION: ADRP
			SYNTAX: <Xd>,<label>
		DECODE_PCODE:
			integer d = UInt(Rd);
			boolean page = (op == '1');
			bits(64) imm;
			if page then
			    imm = SignExtend(immhi:immlo:Zeros(12), 64);
			else
			    imm = SignExtend(immhi:immlo, 64);

IFORM: AESD_advsimd
	TYPE: instruction
	XML: aesd_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01001110|size=00|10100|0010|D=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: AESD_B_cryptoaes
			OPERATION: AESD
			SYNTAX: <Vd>.16B,<Vn>.16B
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveAESExt() then UNDEFINED;
			boolean decrypt = (D == '1');

IFORM: AESE_advsimd
	TYPE: instruction
	XML: aese_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01001110|size=00|10100|0010|D=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: AESE_B_cryptoaes
			OPERATION: AESE
			SYNTAX: <Vd>.16B,<Vn>.16B
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveAESExt() then UNDEFINED;
			boolean decrypt = (D == '1');

IFORM: AESIMC_advsimd
	TYPE: instruction
	XML: aesimc_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01001110|size=00|10100|0011|D=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: AESIMC_B_cryptoaes
			OPERATION: AESIMC
			SYNTAX: <Vd>.16B,<Vn>.16B
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveAESExt() then UNDEFINED;
			boolean decrypt = (D == '1');

IFORM: AESMC_advsimd
	TYPE: instruction
	XML: aesmc_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01001110|size=00|10100|0011|D=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: AESMC_B_cryptoaes
			OPERATION: AESMC
			SYNTAX: <Vd>.16B,<Vn>.16B
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveAESExt() then UNDEFINED;
			boolean decrypt = (D == '1');

IFORM: ANDS_log_imm
	TYPE: instruction
	XML: ands_log_imm.xml
	ALIAS: TST_ANDS_log_imm
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|opc=11|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ANDS_32S_log_imm
			OPERATION: ANDS
			SYNTAX: <Wd>,<Wn>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: ANDS_64S_log_imm
			OPERATION: ANDS
			SYNTAX: <Xd>,<Xn>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			bits(datasize) imm;
			if sf == '0' && N != '0' then UNDEFINED;
			(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

IFORM: ANDS_log_shift
	TYPE: instruction
	XML: ands_log_shift.xml
	ALIAS: TST_ANDS_log_shift
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|opc=11|01010|shift=xx|N=0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ANDS_32_log_shift
			OPERATION: ANDS
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ANDS_64_log_shift
			OPERATION: ANDS
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: AND_advsimd
	TYPE: instruction
	XML: and_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=00|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: AND_asimdsame_only
			OPERATION: AND
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean invert = (size<0> == '1');
			LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

IFORM: AND_log_imm
	TYPE: instruction
	XML: and_log_imm.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=00|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: AND_32_log_imm
			OPERATION: AND
			SYNTAX: <Wd|WSP>,<Wn>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: AND_64_log_imm
			OPERATION: AND
			SYNTAX: <Xd|SP>,<Xn>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			bits(datasize) imm;
			if sf == '0' && N != '0' then UNDEFINED;
			(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

IFORM: AND_log_shift
	TYPE: instruction
	XML: and_log_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=00|01010|shift=xx|N=0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: AND_32_log_shift
			OPERATION: AND
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: AND_64_log_shift
			OPERATION: AND
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: ASRV
	TYPE: instruction
	XML: asrv.xml
	ALIAS: ASR_ASRV
		Unconditionally
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ASRV_32_dp_2src
			OPERATION: ASRV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ASRV_64_dp_2src
			OPERATION: ASRV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			ShiftType shift_type = DecodeShift(op2);

IFORM: ASR_ASRV
	TYPE: alias
	XML: asr_asrv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ASR_ASRV_32_dp_2src
			OPERATION: ASR
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ASR_ASRV_64_dp_2src
			OPERATION: ASR
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: ASR_SBFM
	TYPE: alias
	XML: asr_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=xxxxxx|imms=x11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: ASR_SBFM_32M_bitfield
			OPERATION: ASR
			SYNTAX: <Wd>,<Wn>, #<shift>
			BITDIFFS: sf == '0' && N == '0' && imms == '011111'
			LABEL: 32-bit
		ENCODING: ASR_SBFM_64M_bitfield
			OPERATION: ASR
			SYNTAX: <Xd>,<Xn>, #<shift>
			BITDIFFS: sf == '1' && N == '1' && imms == '111111'
			LABEL: 64-bit

IFORM: AT_SYS
	TYPE: alias
	XML: at_sys.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=01|op1=xxx|CRn=0111|CRm=100x|op2=xxx|Rt=xxxxx
		ENCODING: AT_SYS_CR_systeminstrs
			OPERATION: AT
			SYNTAX: <at_op>,<Xt>

IFORM: AUTDA
	TYPE: instruction
	XML: autda.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=110|Rn=xxxxx|Rd=xxxxx
		ENCODING: AUTDA_64P_dp_1src
			OPERATION: AUTDA
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: AUTDZA_64Z_dp_1src
			OPERATION: AUTDZA
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // AUTDA
			    if n == 31 then source_is_sp = TRUE;
			else // AUTDZA
			    if n != 31 then UNDEFINED;

IFORM: AUTDB
	TYPE: instruction
	XML: autdb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=111|Rn=xxxxx|Rd=xxxxx
		ENCODING: AUTDB_64P_dp_1src
			OPERATION: AUTDB
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: AUTDZB_64Z_dp_1src
			OPERATION: AUTDZB
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // AUTDB
			    if n == 31 then source_is_sp = TRUE;
			else // AUTDZB
			    if n != 31 then UNDEFINED;

IFORM: AUTIA
	TYPE: instruction
	XML: autia.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=100|Rn=xxxxx|Rd=xxxxx
		ENCODING: AUTIA_64P_dp_1src
			OPERATION: AUTIA
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: AUTIZA_64Z_dp_1src
			OPERATION: AUTIZA
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // AUTIA
			    if n == 31 then source_is_sp = TRUE;
			else // AUTIZA
			    if n != 31 then UNDEFINED;
	CLASS: system
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=00x1|op2=10x|Rt=11111
		ENCODING: AUTIA1716_HI_hints
			OPERATION: AUTIA1716
			SYNTAX: 
			BITDIFFS: CRm == '0001' && op2 == '100'
		ENCODING: AUTIASP_HI_hints
			OPERATION: AUTIASP
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '101'
		ENCODING: AUTIAZ_HI_hints
			OPERATION: AUTIAZ
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '100'

IFORM: AUTIB
	TYPE: instruction
	XML: autib.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=101|Rn=xxxxx|Rd=xxxxx
		ENCODING: AUTIB_64P_dp_1src
			OPERATION: AUTIB
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: AUTIZB_64Z_dp_1src
			OPERATION: AUTIZB
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // AUTIB
			    if n == 31 then source_is_sp = TRUE;
			else // AUTIZB
			    if n != 31 then UNDEFINED;
	CLASS: system
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=00x1|op2=11x|Rt=11111
		ENCODING: AUTIB1716_HI_hints
			OPERATION: AUTIB1716
			SYNTAX: 
			BITDIFFS: CRm == '0001' && op2 == '110'
		ENCODING: AUTIBSP_HI_hints
			OPERATION: AUTIBSP
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '111'
		ENCODING: AUTIBZ_HI_hints
			OPERATION: AUTIBZ
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '110'

IFORM: AXFLAG
	TYPE: instruction
	XML: axflag.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FlagM2
		FIELDS32: 1101010100|L=0|op0=00|op1=000|CRn=0100|CRm=(0)(0)(0)(0)|op2=010|Rt =11111
		ENCODING: AXFLAG_M_pstate
			OPERATION: AXFLAG
			SYNTAX: 
		DECODE_PCODE:
			if !HaveFlagFormatExt() then UNDEFINED;

IFORM: BCAX_advsimd
	TYPE: instruction
	XML: bcax_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA3
		FIELDS32: 110011100|Op0=01|Rm=xxxxx|0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: BCAX_VVV16_crypto4
			OPERATION: BCAX
			SYNTAX: <Vd>.16B,<Vn>.16B,<Vm>.16B,<Va>.16B
		DECODE_PCODE:
			if !HaveSHA3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);

IFORM: BFCVTN_advsimd
	TYPE: instruction
	XML: bfcvtn_advsimd.xml
	CLASS: simd_single_and_bf16
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=x|U=0|01110|size=10|10000|opcode=10110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFCVTN_asimdmisc_4S
			OPERATION: BFCVTN
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.4S
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer d = UInt(Rd);
			integer part = UInt(Q);
			integer elements = 64 DIV 16;

IFORM: BFCVT_float
	TYPE: instruction
	XML: bfcvt_float.xml
	CLASS: single_to_bf16
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: M=0|0|S=0|11110|ptype=01|1|opcode=000110|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFCVT_BS_floatdp1
			OPERATION: BFCVT
			SYNTAX: <Hd>,<Sn>
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer d = UInt(Rd);

IFORM: BFC_BFM
	TYPE: alias
	XML: bfc_bfm.xml
	CLASS: nofill
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_ASMv8p2
		FIELDS32: sf=x|opc=01|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=11111|Rd=xxxxx
		ENCODING: BFC_BFM_32M_bitfield
			OPERATION: BFC
			SYNTAX: <Wd>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: BFC_BFM_64M_bitfield
			OPERATION: BFC
			SYNTAX: <Xd>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: BFDOT_advsimd_elt
	TYPE: instruction
	XML: bfdot_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=x|U=0|01111|size=01|L=x|M=x|Rm=xxxx|opcode=1111|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFDOT_asimdelem_E
			OPERATION: BFDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.2H[<index>]
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			integer d = UInt(Rd);
			integer i = UInt(H:L);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 32;

IFORM: BFDOT_advsimd_vec
	TYPE: instruction
	XML: bfdot_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=x|U=1|01110|size=01|0|Rm=xxxxx|1|opcode=1111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFDOT_asimdsame2_D
			OPERATION: BFDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 32;

IFORM: BFI_BFM
	TYPE: alias
	XML: bfi_bfm.xml
	CLASS: nofill
		FIELDS32: sf=x|opc=01|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn!=11111|Rd=xxxxx
		ENCODING: BFI_BFM_32M_bitfield
			OPERATION: BFI
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: BFI_BFM_64M_bitfield
			OPERATION: BFI
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: BFM
	TYPE: instruction
	XML: bfm.xml
	ALIAS: BFC_BFM
		Rn == '11111' && UInt(imms) < UInt(immr)
	ALIAS: BFI_BFM
		Rn != '11111' && UInt(imms) < UInt(immr)
	ALIAS: BFXIL_BFM
		UInt(imms) >= UInt(immr)
	CLASS: nofill
		FIELDS32: sf=x|opc=01|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFM_32M_bitfield
			OPERATION: BFM
			SYNTAX: <Wd>,<Wn>, #<immr>, #<imms>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: BFM_64M_bitfield
			OPERATION: BFM
			SYNTAX: <Xd>,<Xn>, #<immr>, #<imms>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean inzero;
			boolean extend;
			integer R;
			integer S;
			bits(datasize) wmask;
			bits(datasize) tmask;
			case opc of
			    when '00' inzero = TRUE;  extend = TRUE;    // SBFM
			    when '01' inzero = FALSE; extend = FALSE;   // BFM
			    when '10' inzero = TRUE;  extend = FALSE;   // UBFM
			    when '11' UNDEFINED;
			if sf == '1' && N != '1' then UNDEFINED;
			if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
			R = UInt(immr);
			S = UInt(imms);
			(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

IFORM: BFMLAL_advsimd_elt
	TYPE: instruction
	XML: bfmlal_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=x|U=0|01111|size=11|L=x|M=x|Rm=xxxx|opcode<3>=1|opcode<2>=1|opcode<1:0>=11|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFMLAL_asimdelem_F
			OPERATION: BFMLAL
			SYNTAX: <bt><Vd>.4S,<Vn>.8H,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt('0':Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer elements = 128 DIV 32;
			integer sel = UInt(Q);

IFORM: BFMLAL_advsimd_vec
	TYPE: instruction
	XML: bfmlal_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=x|U=1|01110|size=11|0|Rm=xxxxx|1|opcode<3:2>=11|opcode=11|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFMLAL_asimdsame2_F_
			OPERATION: BFMLAL
			SYNTAX: <bt><Vd>.4S,<Vn>.8H,<Vm>.8H
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer elements = 128 DIV 32;
			integer sel = UInt(Q);

IFORM: BFMMLA_advsimd
	TYPE: instruction
	XML: bfmmla_advsimd.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_BF16
		FIELDS32: 0|Q=1|U=1|01110|size=01|0|Rm=xxxxx|1|opcode=1101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFMMLA_asimdsame2_E
			OPERATION: BFMMLA
			SYNTAX: <Vd>.4S,<Vn>.8H,<Vm>.8H
		DECODE_PCODE:
			if !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);

IFORM: BFXIL_BFM
	TYPE: alias
	XML: bfxil_bfm.xml
	CLASS: nofill
		FIELDS32: sf=x|opc=01|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: BFXIL_BFM_32M_bitfield
			OPERATION: BFXIL
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: BFXIL_BFM_64M_bitfield
			OPERATION: BFXIL
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: BICS
	TYPE: instruction
	XML: bics.xml
	CLASS: s
		FIELDS32: sf=x|opc=11|01010|shift=xx|N=1|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: BICS_32_log_shift
			OPERATION: BICS
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: BICS_64_log_shift
			OPERATION: BICS
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: BIC_advsimd_imm
	TYPE: instruction
	XML: bic_advsimd_imm.xml
	CLASS: shifted_immediate
		FIELDS32: 0|Q=x|op=1|0111100000|a=x|b=x|c=x|cmode=xxx1|o2=0|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: BIC_asimdimm_L_hl
			OPERATION: BIC
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '10x1'
		ENCODING: BIC_asimdimm_L_sl
			OPERATION: BIC
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '0xx1'
			LABEL: 32-bit
		DECODE_PCODE:
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			bits(64) imm64;
			ImmediateOp operation;
			case cmode:op of
			    when '0xx00' operation = ImmediateOp_MOVI;
			    when '0xx01' operation = ImmediateOp_MVNI;
			    when '0xx10' operation = ImmediateOp_ORR;
			    when '0xx11' operation = ImmediateOp_BIC;
			    when '10x00' operation = ImmediateOp_MOVI;
			    when '10x01' operation = ImmediateOp_MVNI;
			    when '10x10' operation = ImmediateOp_ORR;
			    when '10x11' operation = ImmediateOp_BIC;
			    when '110x0' operation = ImmediateOp_MOVI;
			    when '110x1' operation = ImmediateOp_MVNI;
			    when '1110x' operation = ImmediateOp_MOVI;
			    when '11110' operation = ImmediateOp_MOVI;
			    when '11111'
			        // FMOV Dn,#imm is in main FP instruction set
			        if Q == '0' then UNDEFINED;
			        operation = ImmediateOp_MOVI;
			imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
			imm = Replicate(imm64, datasize DIV 64);

IFORM: BIC_advsimd_reg
	TYPE: instruction
	XML: bic_advsimd_reg.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=01|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BIC_asimdsame_only
			OPERATION: BIC
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean invert = (size<0> == '1');
			LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

IFORM: BIC_and_z_zi
	TYPE: alias
	XML: bic_and_z_zi.xml
	CLASS: sve
		FIELDS32: 00000101|opc=10|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: BIC_and_z_zi_
			OPERATION: BIC
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>

IFORM: BIC_log_shift
	TYPE: instruction
	XML: bic_log_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=00|01010|shift=xx|N=1|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: BIC_32_log_shift
			OPERATION: BIC
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: BIC_64_log_shift
			OPERATION: BIC
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: BIF_advsimd
	TYPE: instruction
	XML: bif_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|opc2=11|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BIF_asimdsame_only
			OPERATION: BIF
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			VBitOp op;
			case opc2 of
			    when '00' op = VBitOp_VEOR;
			    when '01' op = VBitOp_VBSL;
			    when '10' op = VBitOp_VBIT;
			    when '11' op = VBitOp_VBIF;

IFORM: BIT_advsimd
	TYPE: instruction
	XML: bit_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|opc2=10|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BIT_asimdsame_only
			OPERATION: BIT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			VBitOp op;
			case opc2 of
			    when '00' op = VBitOp_VEOR;
			    when '01' op = VBitOp_VBSL;
			    when '10' op = VBitOp_VBIT;
			    when '11' op = VBitOp_VBIF;

IFORM: BL
	TYPE: instruction
	XML: bl.xml
	CLASS: br26
		FIELDS32: op=1|00101|imm26=xxxxxxxxxxxxxxxxxxxxxxxxxx
		ENCODING: BL_only_branch_imm
			OPERATION: BL
			SYNTAX: <label>
		DECODE_PCODE:
			BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;
			bits(64) offset = SignExtend(imm26:'00', 64);

IFORM: BLR
	TYPE: instruction
	XML: blr.xml
	CLASS: general
		FIELDS32: 1101011|Z=0|opc[2:1]=0|op=01|op2=11111|op3[5:2]=0000|A=0|M=0|Rn=xxxxx|Rm=00000
		ENCODING: BLR_64_branch_reg
			OPERATION: BLR
			SYNTAX: <Xn>
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: BLRA
	TYPE: instruction
	XML: blra.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101011|Z=x|opc[2:1]=0|op=01|op2=11111|op3[5:2]=0000|A=1|M=x|Rn=xxxxx|Rm=xxxxx
		ENCODING: BLRAAZ_64_branch_reg
			OPERATION: BLRAAZ
			SYNTAX: <Xn>
			BITDIFFS: Z == '0' && M == '0' && Rm == '11111'
		ENCODING: BLRAA_64P_branch_reg
			OPERATION: BLRAA
			SYNTAX: <Xn>,<Xm|SP>
			BITDIFFS: Z == '1' && M == '0'
		ENCODING: BLRABZ_64_branch_reg
			OPERATION: BLRABZ
			SYNTAX: <Xn>
			BITDIFFS: Z == '0' && M == '1' && Rm == '11111'
		ENCODING: BLRAB_64P_branch_reg
			OPERATION: BLRAB
			SYNTAX: <Xn>,<Xm|SP>
			BITDIFFS: Z == '1' && M == '1'
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: BR
	TYPE: instruction
	XML: br.xml
	CLASS: general
		FIELDS32: 1101011|Z=0|opc[2:1]=0|op=00|op2=11111|op3[5:2]=0000|A=0|M=0|Rn=xxxxx|Rm=00000
		ENCODING: BR_64_branch_reg
			OPERATION: BR
			SYNTAX: <Xn>
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: BRA
	TYPE: instruction
	XML: bra.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101011|Z=x|opc[2:1]=0|op=00|op2=11111|op3[5:2]=0000|A=1|M=x|Rn=xxxxx|Rm=xxxxx
		ENCODING: BRAAZ_64_branch_reg
			OPERATION: BRAAZ
			SYNTAX: <Xn>
			BITDIFFS: Z == '0' && M == '0' && Rm == '11111'
		ENCODING: BRAA_64P_branch_reg
			OPERATION: BRAA
			SYNTAX: <Xn>,<Xm|SP>
			BITDIFFS: Z == '1' && M == '0'
		ENCODING: BRABZ_64_branch_reg
			OPERATION: BRABZ
			SYNTAX: <Xn>
			BITDIFFS: Z == '0' && M == '1' && Rm == '11111'
		ENCODING: BRAB_64P_branch_reg
			OPERATION: BRAB
			SYNTAX: <Xn>,<Xm|SP>
			BITDIFFS: Z == '1' && M == '1'
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: BRK
	TYPE: instruction
	XML: brk.xml
	CLASS: system
		FIELDS32: 11010100|opc=001|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=00
		ENCODING: BRK_EX_exception
			OPERATION: BRK
			SYNTAX: #<imm>
		DECODE_PCODE:
			bits(16) comment = imm16;
			if HaveBTIExt() then
			    SetBTypeCompatible(TRUE);

IFORM: BSL_advsimd
	TYPE: instruction
	XML: bsl_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|opc2=01|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: BSL_asimdsame_only
			OPERATION: BSL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			VBitOp op;
			case opc2 of
			    when '00' op = VBitOp_VEOR;
			    when '01' op = VBitOp_VBSL;
			    when '10' op = VBitOp_VBIT;
			    when '11' op = VBitOp_VBIF;

IFORM: BTI
	TYPE: instruction
	XML: bti.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_BTI
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0100|op2=xx0|Rt=11111
		ENCODING: BTI_HB_hints
			OPERATION: BTI
			SYNTAX: {<targets>}
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: B_cond
	TYPE: instruction
	XML: b_cond.xml
	CLASS: br19
		FIELDS32: 0101010|o1=0|imm19=xxxxxxxxxxxxxxxxxxx|o0=0|cond=xxxx
		ENCODING: B_only_condbranch
			OPERATION: B
			SYNTAX: <cond><label>
		DECODE_PCODE:
			bits(64) offset = SignExtend(imm19:'00', 64);
			bits(4) condition = cond;

IFORM: B_uncond
	TYPE: instruction
	XML: b_uncond.xml
	CLASS: br26
		FIELDS32: op=0|00101|imm26=xxxxxxxxxxxxxxxxxxxxxxxxxx
		ENCODING: B_only_branch_imm
			OPERATION: B
			SYNTAX: <label>
		DECODE_PCODE:
			BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;
			bits(64) offset = SignExtend(imm26:'00', 64);

IFORM: CAS
	TYPE: instruction
	XML: cas.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|001000|o2=1|L=x|o1=1|Rs=xxxxx|o0=x|Rt2=11111|Rn=xxxxx|Rt=xxxxx
		ENCODING: CAS_C32_ldstexcl
			OPERATION: CAS
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10' && L == '0' && o0 == '0'
		ENCODING: CASA_C32_ldstexcl
			OPERATION: CASA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10' && L == '1' && o0 == '0'
		ENCODING: CASAL_C32_ldstexcl
			OPERATION: CASAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10' && L == '1' && o0 == '1'
		ENCODING: CASL_C32_ldstexcl
			OPERATION: CASL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10' && L == '0' && o0 == '1'
		ENCODING: CAS_C64_ldstexcl
			OPERATION: CAS
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11' && L == '0' && o0 == '0'
		ENCODING: CASA_C64_ldstexcl
			OPERATION: CASA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11' && L == '1' && o0 == '0'
		ENCODING: CASAL_C64_ldstexcl
			OPERATION: CASAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11' && L == '1' && o0 == '1'
		ENCODING: CASL_C64_ldstexcl
			OPERATION: CASL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11' && L == '0' && o0 == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: CASB
	TYPE: instruction
	XML: casb.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|001000|o2=1|L=x|o1=1|Rs=xxxxx|o0=x|Rt2=11111|Rn=xxxxx|Rt=xxxxx
		ENCODING: CASAB_C32_ldstexcl
			OPERATION: CASAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '1' && o0 == '0'
		ENCODING: CASALB_C32_ldstexcl
			OPERATION: CASALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '1' && o0 == '1'
		ENCODING: CASB_C32_ldstexcl
			OPERATION: CASB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '0' && o0 == '0'
		ENCODING: CASLB_C32_ldstexcl
			OPERATION: CASLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '0' && o0 == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: CASH
	TYPE: instruction
	XML: cash.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|001000|o2=1|L=x|o1=1|Rs=xxxxx|o0=x|Rt2=11111|Rn=xxxxx|Rt=xxxxx
		ENCODING: CASAH_C32_ldstexcl
			OPERATION: CASAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '1' && o0 == '0'
		ENCODING: CASALH_C32_ldstexcl
			OPERATION: CASALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '1' && o0 == '1'
		ENCODING: CASH_C32_ldstexcl
			OPERATION: CASH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '0' && o0 == '0'
		ENCODING: CASLH_C32_ldstexcl
			OPERATION: CASLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: L == '0' && o0 == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: CASP
	TYPE: instruction
	XML: casp.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: 0|sz=x|001000|o2=0|L=x|o1=1|Rs=xxxxx|o0=x|Rt2=11111|Rn=xxxxx|Rt=xxxxx
		ENCODING: CASP_CP32_ldstexcl
			OPERATION: CASP
			SYNTAX: <Ws>,<W(s+1)>,<Wt>,<W(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0' && L == '0' && o0 == '0'
		ENCODING: CASPA_CP32_ldstexcl
			OPERATION: CASPA
			SYNTAX: <Ws>,<W(s+1)>,<Wt>,<W(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0' && L == '1' && o0 == '0'
		ENCODING: CASPAL_CP32_ldstexcl
			OPERATION: CASPAL
			SYNTAX: <Ws>,<W(s+1)>,<Wt>,<W(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0' && L == '1' && o0 == '1'
		ENCODING: CASPL_CP32_ldstexcl
			OPERATION: CASPL
			SYNTAX: <Ws>,<W(s+1)>,<Wt>,<W(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0' && L == '0' && o0 == '1'
		ENCODING: CASP_CP64_ldstexcl
			OPERATION: CASP
			SYNTAX: <Xs>,<X(s+1)>,<Xt>,<X(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1' && L == '0' && o0 == '0'
		ENCODING: CASPA_CP64_ldstexcl
			OPERATION: CASPA
			SYNTAX: <Xs>,<X(s+1)>,<Xt>,<X(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1' && L == '1' && o0 == '0'
		ENCODING: CASPAL_CP64_ldstexcl
			OPERATION: CASPAL
			SYNTAX: <Xs>,<X(s+1)>,<Xt>,<X(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1' && L == '1' && o0 == '1'
		ENCODING: CASPL_CP64_ldstexcl
			OPERATION: CASPL
			SYNTAX: <Xs>,<X(s+1)>,<Xt>,<X(t+1)>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1' && L == '0' && o0 == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			if Rs<0> == '1' then UNDEFINED;
			if Rt<0> == '1' then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			integer datasize = 32 << UInt(sz);
			integer regsize = datasize;
			AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: CBNZ
	TYPE: instruction
	XML: cbnz.xml
	CLASS: br19
		FIELDS32: sf=x|011010|op=1|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: CBNZ_32_compbranch
			OPERATION: CBNZ
			SYNTAX: <Wt>,<label>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CBNZ_64_compbranch
			OPERATION: CBNZ
			SYNTAX: <Xt>,<label>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer datasize = if sf == '1' then 64 else 32;
			boolean iszero = (op == '0');
			bits(64) offset = SignExtend(imm19:'00', 64);

IFORM: CBZ
	TYPE: instruction
	XML: cbz.xml
	CLASS: br19
		FIELDS32: sf=x|011010|op=0|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: CBZ_32_compbranch
			OPERATION: CBZ
			SYNTAX: <Wt>,<label>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CBZ_64_compbranch
			OPERATION: CBZ
			SYNTAX: <Xt>,<label>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer datasize = if sf == '1' then 64 else 32;
			boolean iszero = (op == '0');
			bits(64) offset = SignExtend(imm19:'00', 64);

IFORM: CCMN_imm
	TYPE: instruction
	XML: ccmn_imm.xml
	CLASS: imm5u
		FIELDS32: sf=x|op=0|S=1|11010010|imm5=xxxxx|cond=xxxx|1|o2=0|Rn=xxxxx|o3=0|nzcv=xxxx
		ENCODING: CCMN_32_condcmp_imm
			OPERATION: CCMN
			SYNTAX: <Wn>, #<imm>, #<nzcv>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CCMN_64_condcmp_imm
			OPERATION: CCMN
			SYNTAX: <Xn>, #<imm>, #<nzcv>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;
			bits(datasize) imm = ZeroExtend(imm5, datasize);

IFORM: CCMN_reg
	TYPE: instruction
	XML: ccmn_reg.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=1|11010010|Rm=xxxxx|cond=xxxx|0|o2=0|Rn=xxxxx|o3=0|nzcv=xxxx
		ENCODING: CCMN_32_condcmp_reg
			OPERATION: CCMN
			SYNTAX: <Wn>,<Wm>, #<nzcv>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CCMN_64_condcmp_reg
			OPERATION: CCMN
			SYNTAX: <Xn>,<Xm>, #<nzcv>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;

IFORM: CCMP_imm
	TYPE: instruction
	XML: ccmp_imm.xml
	CLASS: imm5u
		FIELDS32: sf=x|op=1|S=1|11010010|imm5=xxxxx|cond=xxxx|1|o2=0|Rn=xxxxx|o3=0|nzcv=xxxx
		ENCODING: CCMP_32_condcmp_imm
			OPERATION: CCMP
			SYNTAX: <Wn>, #<imm>, #<nzcv>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CCMP_64_condcmp_imm
			OPERATION: CCMP
			SYNTAX: <Xn>, #<imm>, #<nzcv>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;
			bits(datasize) imm = ZeroExtend(imm5, datasize);

IFORM: CCMP_reg
	TYPE: instruction
	XML: ccmp_reg.xml
	CLASS: general
		FIELDS32: sf=x|op=1|S=1|11010010|Rm=xxxxx|cond=xxxx|0|o2=0|Rn=xxxxx|o3=0|nzcv=xxxx
		ENCODING: CCMP_32_condcmp_reg
			OPERATION: CCMP
			SYNTAX: <Wn>,<Wm>, #<nzcv>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CCMP_64_condcmp_reg
			OPERATION: CCMP
			SYNTAX: <Xn>,<Xm>, #<nzcv>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;

IFORM: CFINV
	TYPE: instruction
	XML: cfinv.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_FlagM
		FIELDS32: 1101010100|L=0|op0=00|op1=000|CRn=0100|CRm=(0)(0)(0)(0)|op2=000|Rt =11111
		ENCODING: CFINV_M_pstate
			OPERATION: CFINV
			SYNTAX: 
		DECODE_PCODE:
			if !HaveFlagManipulateExt() then UNDEFINED;

IFORM: CFP_SYS
	TYPE: alias
	XML: cfp_sys.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_SPECRES
		FIELDS32: 1101010100|L=0|op0=01|op1=011|CRn=0111|CRm=0011|op2=100|Rt=xxxxx
		ENCODING: CFP_SYS_CR_systeminstrs
			OPERATION: CFP
			SYNTAX: RCTX,<Xt>

IFORM: CINC_CSINC
	TYPE: alias
	XML: cinc_csinc.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010100|Rm!=11111|cond!=111x|0|o2=1|Rn!=11111|Rd=xxxxx
		ENCODING: CINC_CSINC_32_condsel
			OPERATION: CINC
			SYNTAX: <Wd>,<Wn>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CINC_CSINC_64_condsel
			OPERATION: CINC
			SYNTAX: <Xd>,<Xn>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CINV_CSINV
	TYPE: alias
	XML: cinv_csinv.xml
	CLASS: general
		FIELDS32: sf=x|op=1|S=0|11010100|Rm!=11111|cond!=111x|0|o2=0|Rn!=11111|Rd=xxxxx
		ENCODING: CINV_CSINV_32_condsel
			OPERATION: CINV
			SYNTAX: <Wd>,<Wn>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CINV_CSINV_64_condsel
			OPERATION: CINV
			SYNTAX: <Xd>,<Xn>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CLREX
	TYPE: instruction
	XML: clrex.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=xxxx|op2=010|Rt=11111
		ENCODING: CLREX_BN_barriers
			OPERATION: CLREX
			SYNTAX: {#<imm>}

IFORM: CLS_advsimd
	TYPE: instruction
	XML: cls_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=00100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CLS_asimdmisc_R
			OPERATION: CLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

IFORM: CLS_int
	TYPE: instruction
	XML: cls_int.xml
	CLASS: general
		FIELDS32: sf=x|1|S=0|11010110|opcode2=00000|opcode[5:1]=00010|op=1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CLS_32_dp_1src
			OPERATION: CLS
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CLS_64_dp_1src
			OPERATION: CLS
			SYNTAX: <Xd>,<Xn>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;

IFORM: CLZ_advsimd
	TYPE: instruction
	XML: clz_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=00100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CLZ_asimdmisc_R
			OPERATION: CLZ
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

IFORM: CLZ_int
	TYPE: instruction
	XML: clz_int.xml
	CLASS: general
		FIELDS32: sf=x|1|S=0|11010110|opcode2=00000|opcode[5:1]=00010|op=0|Rn=xxxxx|Rd=xxxxx
		ENCODING: CLZ_32_dp_1src
			OPERATION: CLZ
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CLZ_64_dp_1src
			OPERATION: CLZ
			SYNTAX: <Xd>,<Xn>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;

IFORM: CMEQ_advsimd_reg
	TYPE: instruction
	XML: cmeq_advsimd_reg.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|opcode=10001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMEQ_asisdsame_only
			OPERATION: CMEQ
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean and_test = (U == '0');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=10001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMEQ_asimdsame_only
			OPERATION: CMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean and_test = (U == '0');

IFORM: CMEQ_advsimd_zero
	TYPE: instruction
	XML: cmeq_advsimd_zero.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|0100|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMEQ_asisdmisc_Z
			OPERATION: CMEQ
			SYNTAX: <V><d>,<V><n>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|0100|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMEQ_asimdmisc_Z
			OPERATION: CMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: CMGE_advsimd_reg
	TYPE: instruction
	XML: cmge_advsimd_reg.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|0011|eq=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGE_asisdsame_only
			OPERATION: CMGE
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0011|eq=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGE_asimdsame_only
			OPERATION: CMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');

IFORM: CMGE_advsimd_zero
	TYPE: instruction
	XML: cmge_advsimd_zero.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|0100|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGE_asisdmisc_Z
			OPERATION: CMGE
			SYNTAX: <V><d>,<V><n>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|0100|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGE_asimdmisc_Z
			OPERATION: CMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: CMGT_advsimd_reg
	TYPE: instruction
	XML: cmgt_advsimd_reg.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|0011|eq=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGT_asisdsame_only
			OPERATION: CMGT
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0011|eq=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGT_asimdsame_only
			OPERATION: CMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');

IFORM: CMGT_advsimd_zero
	TYPE: instruction
	XML: cmgt_advsimd_zero.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|0100|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGT_asisdmisc_Z
			OPERATION: CMGT
			SYNTAX: <V><d>,<V><n>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|0100|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMGT_asimdmisc_Z
			OPERATION: CMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: CMHI_advsimd
	TYPE: instruction
	XML: cmhi_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|0011|eq=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMHI_asisdsame_only
			OPERATION: CMHI
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0011|eq=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMHI_asimdsame_only
			OPERATION: CMHI
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');

IFORM: CMHS_advsimd
	TYPE: instruction
	XML: cmhs_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|0011|eq=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMHS_asisdsame_only
			OPERATION: CMHS
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0011|eq=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMHS_asimdsame_only
			OPERATION: CMHS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean cmp_eq = (eq == '1');

IFORM: CMLE_advsimd
	TYPE: instruction
	XML: cmle_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|0100|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMLE_asisdmisc_Z
			OPERATION: CMLE
			SYNTAX: <V><d>,<V><n>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|0100|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMLE_asimdmisc_Z
			OPERATION: CMLE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: CMLT_advsimd
	TYPE: instruction
	XML: cmlt_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|opcode=01010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMLT_asisdmisc_Z
			OPERATION: CMLT
			SYNTAX: <V><d>,<V><n>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison = CompareOp_LT;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=01010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMLT_asimdmisc_Z
			OPERATION: CMLT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison = CompareOp_LT;

IFORM: CMN_ADDS_addsub_ext
	TYPE: alias
	XML: cmn_adds_addsub_ext.xml
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=11111
		ENCODING: CMN_ADDS_32S_addsub_ext
			OPERATION: CMN
			SYNTAX: <Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMN_ADDS_64S_addsub_ext
			OPERATION: CMN
			SYNTAX: <Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMN_ADDS_addsub_imm
	TYPE: alias
	XML: cmn_adds_addsub_imm.xml
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: CMN_ADDS_32S_addsub_imm
			OPERATION: CMN
			SYNTAX: <Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMN_ADDS_64S_addsub_imm
			OPERATION: CMN
			SYNTAX: <Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMN_ADDS_addsub_shift
	TYPE: alias
	XML: cmn_adds_addsub_shift.xml
	CLASS: s
		FIELDS32: sf=x|op=0|S=1|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: CMN_ADDS_32_addsub_shift
			OPERATION: CMN
			SYNTAX: <Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMN_ADDS_64_addsub_shift
			OPERATION: CMN
			SYNTAX: <Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMPLE_cmpeq_p_p_zz
	TYPE: alias
	XML: cmple_cmpeq_p_p_zz.xml
	CLASS: ge
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: CMPLE_cmpge_p_p_zz_
			OPERATION: CMPLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: CMPLO_cmpeq_p_p_zz
	TYPE: alias
	XML: cmplo_cmpeq_p_p_zz.xml
	CLASS: hi
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: CMPLO_cmphi_p_p_zz_
			OPERATION: CMPLO
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: CMPLS_cmpeq_p_p_zz
	TYPE: alias
	XML: cmpls_cmpeq_p_p_zz.xml
	CLASS: hs
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: CMPLS_cmphs_p_p_zz_
			OPERATION: CMPLS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: CMPLT_cmpeq_p_p_zz
	TYPE: alias
	XML: cmplt_cmpeq_p_p_zz.xml
	CLASS: gt
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: CMPLT_cmpgt_p_p_zz_
			OPERATION: CMPLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: CMPP_SUBPS
	TYPE: alias
	XML: cmpp_subps.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		FIELDS32: sf=1|0|S=1|11010110|Xm=xxxxx|opcode=000000|Xn=xxxxx|Xd=11111
		ENCODING: CMPP_SUBPS_64S_dp_2src
			OPERATION: CMPP
			SYNTAX: <Xn|SP>,<Xm|SP>

IFORM: CMP_SUBS_addsub_ext
	TYPE: alias
	XML: cmp_subs_addsub_ext.xml
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=11111
		ENCODING: CMP_SUBS_32S_addsub_ext
			OPERATION: CMP
			SYNTAX: <Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMP_SUBS_64S_addsub_ext
			OPERATION: CMP
			SYNTAX: <Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMP_SUBS_addsub_imm
	TYPE: alias
	XML: cmp_subs_addsub_imm.xml
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: CMP_SUBS_32S_addsub_imm
			OPERATION: CMP
			SYNTAX: <Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMP_SUBS_64S_addsub_imm
			OPERATION: CMP
			SYNTAX: <Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMP_SUBS_addsub_shift
	TYPE: alias
	XML: cmp_subs_addsub_shift.xml
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: CMP_SUBS_32_addsub_shift
			OPERATION: CMP
			SYNTAX: <Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CMP_SUBS_64_addsub_shift
			OPERATION: CMP
			SYNTAX: <Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CMTST_advsimd
	TYPE: instruction
	XML: cmtst_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=10001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMTST_asisdsame_only
			OPERATION: CMTST
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean and_test = (U == '0');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CMTST_asimdsame_only
			OPERATION: CMTST
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean and_test = (U == '0');

IFORM: CNEG_CSNEG
	TYPE: alias
	XML: cneg_csneg.xml
	CLASS: general
		FIELDS32: sf=x|op=1|S=0|11010100|Rm=xxxxx|cond!=111x|0|o2=1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CNEG_CSNEG_32_condsel
			OPERATION: CNEG
			SYNTAX: <Wd>,<Wn>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CNEG_CSNEG_64_condsel
			OPERATION: CNEG
			SYNTAX: <Xd>,<Xn>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CNT_advsimd
	TYPE: instruction
	XML: cnt_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=00101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: CNT_asimdmisc_R
			OPERATION: CNT
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '00' then UNDEFINED;
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 8;

IFORM: CPP_SYS
	TYPE: alias
	XML: cpp_sys.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_SPECRES
		FIELDS32: 1101010100|L=0|op0=01|op1=011|CRn=0111|CRm=0011|op2=111|Rt=xxxxx
		ENCODING: CPP_SYS_CR_systeminstrs
			OPERATION: CPP
			SYNTAX: RCTX,<Xt>

IFORM: CRC32
	TYPE: instruction
	XML: crc32.xml
	CLASS: crc
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:3>=010|C=0|sz=xx|Rn=xxxxx|Rd=xxxxx
		ENCODING: CRC32B_32C_dp_2src
			OPERATION: CRC32B
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '00'
		ENCODING: CRC32H_32C_dp_2src
			OPERATION: CRC32H
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '01'
		ENCODING: CRC32W_32C_dp_2src
			OPERATION: CRC32W
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '10'
		ENCODING: CRC32X_64C_dp_2src
			OPERATION: CRC32X
			SYNTAX: <Wd>,<Wn>,<Xm>
			BITDIFFS: sf == '1' && sz == '11'
		DECODE_PCODE:
			if !HaveCRCExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sf == '1' && sz != '11' then UNDEFINED;
			if sf == '0' && sz == '11' then UNDEFINED;
			integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
			boolean crc32c = (C == '1');

IFORM: CRC32C
	TYPE: instruction
	XML: crc32c.xml
	CLASS: crc
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:3>=010|C=1|sz=xx|Rn=xxxxx|Rd=xxxxx
		ENCODING: CRC32CB_32C_dp_2src
			OPERATION: CRC32CB
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '00'
		ENCODING: CRC32CH_32C_dp_2src
			OPERATION: CRC32CH
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '01'
		ENCODING: CRC32CW_32C_dp_2src
			OPERATION: CRC32CW
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0' && sz == '10'
		ENCODING: CRC32CX_64C_dp_2src
			OPERATION: CRC32CX
			SYNTAX: <Wd>,<Wn>,<Xm>
			BITDIFFS: sf == '1' && sz == '11'
		DECODE_PCODE:
			if !HaveCRCExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sf == '1' && sz != '11' then UNDEFINED;
			if sf == '0' && sz == '11' then UNDEFINED;
			integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
			boolean crc32c = (C == '1');

IFORM: CSDB
	TYPE: instruction
	XML: csdb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0010|op2=100|Rt=11111
		ENCODING: CSDB_HI_hints
			OPERATION: CSDB
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: CSEL
	TYPE: instruction
	XML: csel.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010100|Rm=xxxxx|cond=xxxx|0|o2=0|Rn=xxxxx|Rd=xxxxx
		ENCODING: CSEL_32_condsel
			OPERATION: CSEL
			SYNTAX: <Wd>,<Wn>,<Wm>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSEL_64_condsel
			OPERATION: CSEL
			SYNTAX: <Xd>,<Xn>,<Xm>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			bits(4) condition = cond;
			boolean else_inv = (op == '1');
			boolean else_inc = (o2 == '1');

IFORM: CSETM_CSINV
	TYPE: alias
	XML: csetm_csinv.xml
	CLASS: general
		FIELDS32: sf=x|op=1|S=0|11010100|Rm=11111|cond!=111x|0|o2=0|Rn=11111|Rd=xxxxx
		ENCODING: CSETM_CSINV_32_condsel
			OPERATION: CSETM
			SYNTAX: <Wd>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSETM_CSINV_64_condsel
			OPERATION: CSETM
			SYNTAX: <Xd>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CSET_CSINC
	TYPE: alias
	XML: cset_csinc.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010100|Rm=11111|cond!=111x|0|o2=1|Rn=11111|Rd=xxxxx
		ENCODING: CSET_CSINC_32_condsel
			OPERATION: CSET
			SYNTAX: <Wd>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSET_CSINC_64_condsel
			OPERATION: CSET
			SYNTAX: <Xd>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: CSINC
	TYPE: instruction
	XML: csinc.xml
	ALIAS: CINC_CSINC
		Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm
	ALIAS: CSET_CSINC
		Rm == '11111' && cond != '111x' && Rn == '11111'
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010100|Rm=xxxxx|cond=xxxx|0|o2=1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CSINC_32_condsel
			OPERATION: CSINC
			SYNTAX: <Wd>,<Wn>,<Wm>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSINC_64_condsel
			OPERATION: CSINC
			SYNTAX: <Xd>,<Xn>,<Xm>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			bits(4) condition = cond;
			boolean else_inv = (op == '1');
			boolean else_inc = (o2 == '1');

IFORM: CSINV
	TYPE: instruction
	XML: csinv.xml
	ALIAS: CINV_CSINV
		Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm
	ALIAS: CSETM_CSINV
		Rm == '11111' && cond != '111x' && Rn == '11111'
	CLASS: general
		FIELDS32: sf=x|op=1|S=0|11010100|Rm=xxxxx|cond=xxxx|0|o2=0|Rn=xxxxx|Rd=xxxxx
		ENCODING: CSINV_32_condsel
			OPERATION: CSINV
			SYNTAX: <Wd>,<Wn>,<Wm>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSINV_64_condsel
			OPERATION: CSINV
			SYNTAX: <Xd>,<Xn>,<Xm>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			bits(4) condition = cond;
			boolean else_inv = (op == '1');
			boolean else_inc = (o2 == '1');

IFORM: CSNEG
	TYPE: instruction
	XML: csneg.xml
	ALIAS: CNEG_CSNEG
		cond != '111x' && Rn == Rm
	CLASS: general
		FIELDS32: sf=x|op=1|S=0|11010100|Rm=xxxxx|cond=xxxx|0|o2=1|Rn=xxxxx|Rd=xxxxx
		ENCODING: CSNEG_32_condsel
			OPERATION: CSNEG
			SYNTAX: <Wd>,<Wn>,<Wm>,<cond>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: CSNEG_64_condsel
			OPERATION: CSNEG
			SYNTAX: <Xd>,<Xn>,<Xm>,<cond>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			bits(4) condition = cond;
			boolean else_inv = (op == '1');
			boolean else_inc = (o2 == '1');

IFORM: DCPS1
	TYPE: instruction
	XML: dcps1.xml
	CLASS: system
		FIELDS32: 11010100|opc=101|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=01
		ENCODING: DCPS1_DC_exception
			OPERATION: DCPS1
			SYNTAX: {#<imm>}
		DECODE_PCODE:
			bits(2) target_level = LL;
			if LL == '00' then UNDEFINED;
			if !Halted() then UNDEFINED;

IFORM: DCPS2
	TYPE: instruction
	XML: dcps2.xml
	CLASS: system
		FIELDS32: 11010100|opc=101|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=10
		ENCODING: DCPS2_DC_exception
			OPERATION: DCPS2
			SYNTAX: {#<imm>}
		DECODE_PCODE:
			bits(2) target_level = LL;
			if LL == '00' then UNDEFINED;
			if !Halted() then UNDEFINED;

IFORM: DCPS3
	TYPE: instruction
	XML: dcps3.xml
	CLASS: system
		FIELDS32: 11010100|opc=101|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=11
		ENCODING: DCPS3_DC_exception
			OPERATION: DCPS3
			SYNTAX: {#<imm>}
		DECODE_PCODE:
			bits(2) target_level = LL;
			if LL == '00' then UNDEFINED;
			if !Halted() then UNDEFINED;

IFORM: DC_SYS
	TYPE: alias
	XML: dc_sys.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=01|op1=xxx|CRn=0111|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: DC_SYS_CR_systeminstrs
			OPERATION: DC
			SYNTAX: <dc_op>,<Xt>

IFORM: DGH
	TYPE: instruction
	XML: dgh.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_DGH
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=110|Rt=11111
		ENCODING: DGH_HI_hints
			OPERATION: DGH
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: DMB
	TYPE: instruction
	XML: dmb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=xxxx|1|opc=01|Rt=11111
		ENCODING: DMB_BO_barriers
			OPERATION: DMB
			SYNTAX: <option>|#<imm>
		DECODE_PCODE:
			case CRm<3:2> of
			    when '00' domain = MBReqDomain_OuterShareable;
			    when '01' domain = MBReqDomain_Nonshareable;
			    when '10' domain = MBReqDomain_InnerShareable;
			    when '11' domain = MBReqDomain_FullSystem;
			case CRm<1:0> of
			    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
			    when '01' types = MBReqTypes_Reads;
			    when '10' types = MBReqTypes_Writes;
			    when '11' types = MBReqTypes_All;

IFORM: DRPS
	TYPE: instruction
	XML: drps.xml
	CLASS: system
		FIELDS32: 1101011|opc=0101|op2=11111|op3=000000|Rt=11111|op4=00000
		ENCODING: DRPS_64E_branch_reg
			OPERATION: DRPS
			SYNTAX: 
		DECODE_PCODE:
			if !Halted() || PSTATE.EL == EL0 then UNDEFINED;

IFORM: DSB
	TYPE: instruction
	XML: dsb.xml
	CLASS: dsb_memory
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm!=0x00|1|opc=00|Rt=11111
		ENCODING: DSB_BO_barriers
			OPERATION: DSB
			SYNTAX: <option>|#<imm>
		DECODE_PCODE:
			boolean nXS = FALSE;
			case CRm<3:2> of
			    when '00' domain = MBReqDomain_OuterShareable;
			    when '01' domain = MBReqDomain_Nonshareable;
			    when '10' domain = MBReqDomain_InnerShareable;
			    when '11' domain = MBReqDomain_FullSystem;
			case CRm<1:0> of
			    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
			    when '01' types = MBReqTypes_Reads;
			    when '10' types = MBReqTypes_Writes;
			    when '11' types = MBReqTypes_All;
	CLASS: dsb_nxs
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_XS
		FIELDS32: 11010101000000110011|imm2=xx|10|op2<2>=0|op2<1:0>=01|Rt=11111
		ENCODING: DSB_BOn_barriers
			OPERATION: DSB
			SYNTAX: <option>nXS|#<imm>
		DECODE_PCODE:
			if !HaveFeatXS() then UNDEFINED;
			MBReqTypes types = MBReqTypes_All;
			boolean nXS = TRUE;
			case imm2 of
			    when '00' domain = MBReqDomain_OuterShareable;
			    when '01' domain = MBReqDomain_Nonshareable;
			    when '10' domain = MBReqDomain_InnerShareable;
			    when '11' domain = MBReqDomain_FullSystem;

IFORM: DUP_advsimd_elt
	TYPE: instruction
	XML: dup_advsimd_elt.xml
	ALIAS: MOV_DUP_advsimd_elt
		Unconditionally
	CLASS: scalar_from_element
		FIELDS32: 01|op=0|11110000|imm5=xxxxx|0|imm4=0000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: DUP_asisdone_only
			OPERATION: DUP
			SYNTAX: <V><d>,<Vn>.<T>[<index>]
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size = LowestSetBit(imm5);
			if size > 3 then UNDEFINED;
			integer index = UInt(imm5<4:size+1>);
			integer idxdsize = if imm5<4> == '1' then 128 else 64;
			integer esize = 8 << size;
			integer datasize = esize;
			integer elements = 1;
	CLASS: vector_from_element
		FIELDS32: 0|Q=x|op=0|01110000|imm5=xxxxx|0|imm4=0000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: DUP_asimdins_DV_v
			OPERATION: DUP
			SYNTAX: <Vd>.<T>,<Vn>.<Ts>[<index>]
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size = LowestSetBit(imm5);
			if size > 3 then UNDEFINED;
			integer index = UInt(imm5<4:size+1>);
			integer idxdsize = if imm5<4> == '1' then 128 else 64;
			if size == 3 && Q == '0' then UNDEFINED;
			integer esize = 8 << size;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: DUP_advsimd_gen
	TYPE: instruction
	XML: dup_advsimd_gen.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=0|01110000|imm5=xxxxx|0|imm4=0001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: DUP_asimdins_DR_r
			OPERATION: DUP
			SYNTAX: <Vd>.<T>,<R><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size = LowestSetBit(imm5);
			if size > 3 then UNDEFINED;
			// imm5<4:size+1> is IGNORED
			if size == 3 && Q == '0' then UNDEFINED;
			integer esize = 8 << size;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: DVP_SYS
	TYPE: alias
	XML: dvp_sys.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_SPECRES
		FIELDS32: 1101010100|L=0|op0=01|op1=011|CRn=0111|CRm=0011|op2=101|Rt=xxxxx
		ENCODING: DVP_SYS_CR_systeminstrs
			OPERATION: DVP
			SYNTAX: RCTX,<Xt>

IFORM: EON
	TYPE: instruction
	XML: eon.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=10|01010|shift=xx|N=1|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: EON_32_log_shift
			OPERATION: EON
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: EON_64_log_shift
			OPERATION: EON
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: EON_eor_z_zi
	TYPE: alias
	XML: eon_eor_z_zi.xml
	CLASS: sve
		FIELDS32: 00000101|opc=01|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: EON_eor_z_zi_
			OPERATION: EON
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>

IFORM: EOR3_advsimd
	TYPE: instruction
	XML: eor3_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA3
		FIELDS32: 110011100|Op0=00|Rm=xxxxx|0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: EOR3_VVV16_crypto4
			OPERATION: EOR3
			SYNTAX: <Vd>.16B,<Vn>.16B,<Vm>.16B,<Va>.16B
		DECODE_PCODE:
			if !HaveSHA3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);

IFORM: EOR_advsimd
	TYPE: instruction
	XML: eor_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|opc2=00|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: EOR_asimdsame_only
			OPERATION: EOR
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			VBitOp op;
			case opc2 of
			    when '00' op = VBitOp_VEOR;
			    when '01' op = VBitOp_VBSL;
			    when '10' op = VBitOp_VBIT;
			    when '11' op = VBitOp_VBIF;

IFORM: EOR_log_imm
	TYPE: instruction
	XML: eor_log_imm.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=10|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: EOR_32_log_imm
			OPERATION: EOR
			SYNTAX: <Wd|WSP>,<Wn>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: EOR_64_log_imm
			OPERATION: EOR
			SYNTAX: <Xd|SP>,<Xn>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			bits(datasize) imm;
			if sf == '0' && N != '0' then UNDEFINED;
			(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

IFORM: EOR_log_shift
	TYPE: instruction
	XML: eor_log_shift.xml
	CLASS: general
		FIELDS32: sf=x|opc=10|01010|shift=xx|N=0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: EOR_32_log_shift
			OPERATION: EOR
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: EOR_64_log_shift
			OPERATION: EOR
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: ERET
	TYPE: instruction
	XML: eret.xml
	CLASS: system
		FIELDS32: 1101011|opc[3]=0|opc[2:0]=100|op2=11111|op3[5:2]=0000|A=0|M=0|Rn=11111|op4=00000
		ENCODING: ERET_64E_branch_reg
			OPERATION: ERET
			SYNTAX: 
		DECODE_PCODE:
			if PSTATE.EL == EL0 then UNDEFINED;
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			if !pac && op4 != '00000' then
			    UNDEFINED;
			elsif pac && (!HavePACExt() || op4 != '11111') then
			    UNDEFINED;
			if Rn != '11111' then
			    UNDEFINED;

IFORM: ERETA
	TYPE: instruction
	XML: ereta.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101011|opc[3]=0|opc[2:0]=100|op2=11111|op3[5:2]=0000|A=1|M=x|Rn=11111|op4=11111
		ENCODING: ERETAA_64E_branch_reg
			OPERATION: ERETAA
			SYNTAX: 
			BITDIFFS: M == '0'
		ENCODING: ERETAB_64E_branch_reg
			OPERATION: ERETAB
			SYNTAX: 
			BITDIFFS: M == '1'
		DECODE_PCODE:
			if PSTATE.EL == EL0 then UNDEFINED;
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			if !pac && op4 != '00000' then
			    UNDEFINED;
			elsif pac && (!HavePACExt() || op4 != '11111') then
			    UNDEFINED;
			if Rn != '11111' then
			    UNDEFINED;

IFORM: ESB
	TYPE: instruction
	XML: esb.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_RAS
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0010|op2=000|Rt=11111
		ENCODING: ESB_HI_hints
			OPERATION: ESB
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: EXTR
	TYPE: instruction
	XML: extr.xml
	ALIAS: ROR_EXTR
		Rn == Rm
	CLASS: general
		FIELDS32: sf=x|op21=00|100111|N=x|o0=0|Rm=xxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: EXTR_32_extract
			OPERATION: EXTR
			SYNTAX: <Wd>,<Wn>,<Wm>, #<lsb>
			BITDIFFS: sf == '0' && N == '0' && imms == '0xxxxx'
			LABEL: 32-bit
		ENCODING: EXTR_64_extract
			OPERATION: EXTR
			SYNTAX: <Xd>,<Xn>,<Xm>, #<lsb>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			integer lsb;
			if N != sf then UNDEFINED;
			if sf == '0' && imms<5> == '1' then UNDEFINED;
			lsb = UInt(imms);

IFORM: EXT_advsimd
	TYPE: instruction
	XML: ext_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|101110|op2=00|0|Rm=xxxxx|0|imm4=xxxx|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: EXT_asimdext_only
			OPERATION: EXT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>, #<index>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if Q == '0' && imm4<3> == '1' then UNDEFINED;
			integer datasize = if Q == '1' then 128 else 64;
			integer position = UInt(imm4) << 3;

IFORM: FABD_advsimd
	TYPE: instruction
	XML: fabd_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|a=1|10|Rm=xxxxx|00|opcode=010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABD_asisdsamefp16_only
			OPERATION: FABD
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean abs = TRUE;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|1|sz=x|1|Rm=xxxxx|opcode=11010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABD_asisdsame_only
			OPERATION: FABD
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean abs = TRUE;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|10|Rm=xxxxx|00|opcode=010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABD_asimdsamefp16_only
			OPERATION: FABD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean abs = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|1|Rm=xxxxx|opcode=11010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABD_asimdsame_only
			OPERATION: FABD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean abs = (U == '1');

IFORM: FABS_advsimd
	TYPE: instruction
	XML: fabs_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|111100|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABS_asimdmiscfp16_R
			OPERATION: FABS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABS_asimdmisc_R
			OPERATION: FABS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: FABS_float
	TYPE: instruction
	XML: fabs_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|0000|opc=01|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FABS_H_floatdp1
			OPERATION: FABS
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FABS_S_floatdp1
			OPERATION: FABS
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FABS_D_floatdp1
			OPERATION: FABS
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPUnaryOp fpop;
			case opc of
			    when '00' fpop = FPUnaryOp_MOV;
			    when '01' fpop = FPUnaryOp_ABS;
			    when '10' fpop = FPUnaryOp_NEG;
			    when '11' fpop = FPUnaryOp_SQRT;

IFORM: FACGE_advsimd
	TYPE: instruction
	XML: facge_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|E=0|10|Rm=xxxxx|00|10|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGE_asisdsamefp16_only
			OPERATION: FACGE
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|E=0|sz=x|1|Rm=xxxxx|1110|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGE_asisdsame_only
			OPERATION: FACGE
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|E=0|10|Rm=xxxxx|00|10|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGE_asimdsamefp16_only
			OPERATION: FACGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|E=0|sz=x|1|Rm=xxxxx|1110|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGE_asimdsame_only
			OPERATION: FACGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;

IFORM: FACGT_advsimd
	TYPE: instruction
	XML: facgt_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|E=1|10|Rm=xxxxx|00|10|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGT_asisdsamefp16_only
			OPERATION: FACGT
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|E=1|sz=x|1|Rm=xxxxx|1110|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGT_asisdsame_only
			OPERATION: FACGT
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|E=1|10|Rm=xxxxx|00|10|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGT_asimdsamefp16_only
			OPERATION: FACGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|E=1|sz=x|1|Rm=xxxxx|1110|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FACGT_asimdsame_only
			OPERATION: FACGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;

IFORM: FACLE_facge_p_p_zz
	TYPE: alias
	XML: facle_facge_p_p_zz.xml
	CLASS: ge
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=1|1|o2=0|Pg=xxx|Zn=xxxxx|o3=1|Pd=xxxx
		ENCODING: FACLE_facge_p_p_zz_
			OPERATION: FACLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: FACLT_facge_p_p_zz
	TYPE: alias
	XML: faclt_facge_p_p_zz.xml
	CLASS: gt
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=1|1|o2=1|Pg=xxx|Zn=xxxxx|o3=1|Pd=xxxx
		ENCODING: FACLT_facgt_p_p_zz_
			OPERATION: FACLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: FADDP_advsimd_pair
	TYPE: instruction
	XML: faddp_advsimd_pair.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|0|sz=x|11000|opcode=01101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADDP_asisdpair_only_H
			OPERATION: FADDP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			if sz == '1' then UNDEFINED;
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = ReduceOp_FADD;
	CLASS: single_and_double
		FIELDS32: 01|U=1|11110|0|sz=x|11000|opcode=01101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADDP_asisdpair_only_SD
			OPERATION: FADDP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = ReduceOp_FADD;

IFORM: FADDP_advsimd_vec
	TYPE: instruction
	XML: faddp_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|10|Rm=xxxxx|00|opcode=010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADDP_asimdsamefp16_only
			OPERATION: FADDP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|1|Rm=xxxxx|opcode=11010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADDP_asimdsame_only
			OPERATION: FADDP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');

IFORM: FADD_advsimd
	TYPE: instruction
	XML: fadd_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|10|Rm=xxxxx|00|opcode=010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADD_asimdsamefp16_only
			OPERATION: FADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|1|Rm=xxxxx|opcode=11010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADD_asimdsame_only
			OPERATION: FADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');

IFORM: FADD_float
	TYPE: instruction
	XML: fadd_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|001|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FADD_H_floatdp2
			OPERATION: FADD
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FADD_S_floatdp2
			OPERATION: FADD
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FADD_D_floatdp2
			OPERATION: FADD
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean sub_op = (op == '1');

IFORM: FCADD_advsimd_vec
	TYPE: instruction
	XML: fcadd_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_FCMA
		FIELDS32: 0|Q=x|U=1|01110|size=xx|0|Rm=xxxxx|1|11|rot=x|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCADD_asimdsame2_C
			OPERATION: FCADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>, #<rotate>
		DECODE_PCODE:
			if !HaveFCADDExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' then UNDEFINED;
			if Q == '0' && size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			if !HaveFP16Ext() && esize == 16 then UNDEFINED;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FCCMPE_float
	TYPE: instruction
	XML: fccmpe_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|cond=xxxx|01|Rn=xxxxx|op=1|nzcv=xxxx
		ENCODING: FCCMPE_H_floatccmp
			OPERATION: FCCMPE
			SYNTAX: <Hn>,<Hm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '11'
		ENCODING: FCCMPE_S_floatccmp
			OPERATION: FCCMPE
			SYNTAX: <Sn>,<Sm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '00'
		ENCODING: FCCMPE_D_floatccmp
			OPERATION: FCCMPE
			SYNTAX: <Dn>,<Dm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			boolean signal_all_nans = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;

IFORM: FCCMP_float
	TYPE: instruction
	XML: fccmp_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|cond=xxxx|01|Rn=xxxxx|op=0|nzcv=xxxx
		ENCODING: FCCMP_H_floatccmp
			OPERATION: FCCMP
			SYNTAX: <Hn>,<Hm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '11'
		ENCODING: FCCMP_S_floatccmp
			OPERATION: FCCMP
			SYNTAX: <Sn>,<Sm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '00'
		ENCODING: FCCMP_D_floatccmp
			OPERATION: FCCMP
			SYNTAX: <Dn>,<Dm>, #<nzcv>,<cond>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			boolean signal_all_nans = (op == '1');
			bits(4) condition = cond;
			bits(4) flags = nzcv;

IFORM: FCMEQ_advsimd_reg
	TYPE: instruction
	XML: fcmeq_advsimd_reg.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|E=0|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asisdsamefp16_only
			OPERATION: FCMEQ
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|E=0|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asisdsame_only
			OPERATION: FCMEQ
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|E=0|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asimdsamefp16_only
			OPERATION: FCMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|E=0|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asimdsame_only
			OPERATION: FCMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;

IFORM: FCMEQ_advsimd_zero
	TYPE: instruction
	XML: fcmeq_advsimd_zero.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=1|111100|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asisdmiscfp16_FZ
			OPERATION: FCMEQ
			SYNTAX: <Hd>,<Hn>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|10000|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asisdmisc_FZ
			OPERATION: FCMEQ
			SYNTAX: <V><d>,<V><n>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|111100|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asimdmiscfp16_FZ
			OPERATION: FCMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMEQ_asimdmisc_FZ
			OPERATION: FCMEQ
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: FCMGE_advsimd_reg
	TYPE: instruction
	XML: fcmge_advsimd_reg.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|E=0|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asisdsamefp16_only
			OPERATION: FCMGE
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|E=0|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asisdsame_only
			OPERATION: FCMGE
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|E=0|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asimdsamefp16_only
			OPERATION: FCMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|E=0|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asimdsame_only
			OPERATION: FCMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;

IFORM: FCMGE_advsimd_zero
	TYPE: instruction
	XML: fcmge_advsimd_zero.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|a=1|111100|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asisdmiscfp16_FZ
			OPERATION: FCMGE
			SYNTAX: <Hd>,<Hn>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|1|sz=x|10000|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asisdmisc_FZ
			OPERATION: FCMGE
			SYNTAX: <V><d>,<V><n>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|111100|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asimdmiscfp16_FZ
			OPERATION: FCMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGE_asimdmisc_FZ
			OPERATION: FCMGE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: FCMGT_advsimd_reg
	TYPE: instruction
	XML: fcmgt_advsimd_reg.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|E=1|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asisdsamefp16_only
			OPERATION: FCMGT
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|E=1|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asisdsame_only
			OPERATION: FCMGT
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|E=1|10|Rm=xxxxx|00|10|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asimdsamefp16_only
			OPERATION: FCMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|E=1|sz=x|1|Rm=xxxxx|1110|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asimdsame_only
			OPERATION: FCMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp cmp;
			boolean abs;
			case E:U:ac of
			    when '000' cmp = CompareOp_EQ; abs = FALSE;
			    when '010' cmp = CompareOp_GE; abs = FALSE;
			    when '011' cmp = CompareOp_GE; abs = TRUE;
			    when '110' cmp = CompareOp_GT; abs = FALSE;
			    when '111' cmp = CompareOp_GT; abs = TRUE;
			    otherwise  UNDEFINED;

IFORM: FCMGT_advsimd_zero
	TYPE: instruction
	XML: fcmgt_advsimd_zero.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=1|111100|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asisdmiscfp16_FZ
			OPERATION: FCMGT
			SYNTAX: <Hd>,<Hn>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|10000|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asisdmisc_FZ
			OPERATION: FCMGT
			SYNTAX: <V><d>,<V><n>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|111100|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asimdmiscfp16_FZ
			OPERATION: FCMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|0110|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMGT_asimdmisc_FZ
			OPERATION: FCMGT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: FCMLA_advsimd_elt
	TYPE: instruction
	XML: fcmla_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_FCMA
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|0|rot=xx|1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLA_asimdelem_C_H
			OPERATION: FCMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>], #<rotate>
			BITDIFFS: size == '01'
		ENCODING: FCMLA_asimdelem_C_S
			OPERATION: FCMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>], #<rotate>
			BITDIFFS: size == '10'
		DECODE_PCODE:
			if !HaveFCADDExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			if size == '00' || size == '11' then UNDEFINED;
			if size == '01' then index = UInt(H:L);
			if size == '10' then index = UInt(H);
			integer esize = 8 << UInt(size);
			if !HaveFP16Ext() && esize == 16 then UNDEFINED;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			if size == '10' && (L == '1' || Q == '0') then UNDEFINED;
			if size == '01' && H == '1' && Q=='0' then UNDEFINED;

IFORM: FCMLA_advsimd_vec
	TYPE: instruction
	XML: fcmla_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_FCMA
		FIELDS32: 0|Q=x|U=1|01110|size=xx|0|Rm=xxxxx|1|10|rot=xx|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLA_asimdsame2_C
			OPERATION: FCMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>, #<rotate>
		DECODE_PCODE:
			if !HaveFCADDExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' then UNDEFINED;
			if Q == '0' && size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			if !HaveFP16Ext() && esize == 16 then UNDEFINED;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FCMLE_advsimd
	TYPE: instruction
	XML: fcmle_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|a=1|111100|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLE_asisdmiscfp16_FZ
			OPERATION: FCMLE
			SYNTAX: <Hd>,<Hn>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|1|sz=x|10000|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLE_asisdmisc_FZ
			OPERATION: FCMLE
			SYNTAX: <V><d>,<V><n>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|111100|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLE_asimdmiscfp16_FZ
			OPERATION: FCMLE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|0110|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLE_asimdmisc_FZ
			OPERATION: FCMLE
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison;
			case op:U of
			    when '00' comparison = CompareOp_GT;
			    when '01' comparison = CompareOp_GE;
			    when '10' comparison = CompareOp_EQ;
			    when '11' comparison = CompareOp_LE;

IFORM: FCMLE_fcmeq_p_p_zz
	TYPE: alias
	XML: fcmle_fcmeq_p_p_zz.xml
	CLASS: ge
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=0|Pg=xxx|Zn=xxxxx|cmpl=0|Pd=xxxx
		ENCODING: FCMLE_fcmge_p_p_zz_
			OPERATION: FCMLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: FCMLT_advsimd
	TYPE: instruction
	XML: fcmlt_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=1|111100|opcode=01110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLT_asisdmiscfp16_FZ
			OPERATION: FCMLT
			SYNTAX: <Hd>,<Hn>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison = CompareOp_LT;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|10000|opcode=01110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLT_asisdmisc_FZ
			OPERATION: FCMLT
			SYNTAX: <V><d>,<V><n>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			CompareOp comparison = CompareOp_LT;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|111100|opcode=01110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLT_asimdmiscfp16_FZ
			OPERATION: FCMLT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison = CompareOp_LT;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|opcode=01110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCMLT_asimdmisc_FZ
			OPERATION: FCMLT
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #0.0
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			CompareOp comparison = CompareOp_LT;

IFORM: FCMLT_fcmeq_p_p_zz
	TYPE: alias
	XML: fcmlt_fcmeq_p_p_zz.xml
	CLASS: gt
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=0|Pg=xxx|Zn=xxxxx|cmpl=1|Pd=xxxx
		ENCODING: FCMLT_fcmgt_p_p_zz_
			OPERATION: FCMLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zm>.<T>,<Zn>.<T>

IFORM: FCMPE_float
	TYPE: instruction
	XML: fcmpe_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|op=00|1000|Rn=xxxxx|opc=1x|000
		ENCODING: FCMPE_H_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Hn>,<Hm>
			BITDIFFS: ftype == '11' && opc == '10'
		ENCODING: FCMPE_HZ_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Hn>, #0.0
			BITDIFFS: ftype == '11' && PreferBitsEqual(Rm,'00000') && opc == '11'
		ENCODING: FCMPE_S_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Sn>,<Sm>
			BITDIFFS: ftype == '00' && opc == '10'
		ENCODING: FCMPE_SZ_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Sn>, #0.0
			BITDIFFS: ftype == '00' && PreferBitsEqual(Rm,'00000') && opc == '11'
		ENCODING: FCMPE_D_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Dn>,<Dm>
			BITDIFFS: ftype == '01' && opc == '10'
		ENCODING: FCMPE_DZ_floatcmp
			OPERATION: FCMPE
			SYNTAX: <Dn>, #0.0
			BITDIFFS: ftype == '01' && PreferBitsEqual(Rm,'00000') && opc == '11'
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);   // ignored when opc<0> == '1'
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			boolean signal_all_nans = (opc<1> == '1');
			boolean cmp_with_zero = (opc<0> == '1');

IFORM: FCMP_float
	TYPE: instruction
	XML: fcmp_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|op=00|1000|Rn=xxxxx|opc=0x|000
		ENCODING: FCMP_H_floatcmp
			OPERATION: FCMP
			SYNTAX: <Hn>,<Hm>
			BITDIFFS: ftype == '11' && opc == '00'
		ENCODING: FCMP_HZ_floatcmp
			OPERATION: FCMP
			SYNTAX: <Hn>, #0.0
			BITDIFFS: ftype == '11' && PreferBitsEqual(Rm,'00000') && opc == '01'
		ENCODING: FCMP_S_floatcmp
			OPERATION: FCMP
			SYNTAX: <Sn>,<Sm>
			BITDIFFS: ftype == '00' && opc == '00'
		ENCODING: FCMP_SZ_floatcmp
			OPERATION: FCMP
			SYNTAX: <Sn>, #0.0
			BITDIFFS: ftype == '00' && PreferBitsEqual(Rm,'00000') && opc == '01'
		ENCODING: FCMP_D_floatcmp
			OPERATION: FCMP
			SYNTAX: <Dn>,<Dm>
			BITDIFFS: ftype == '01' && opc == '00'
		ENCODING: FCMP_DZ_floatcmp
			OPERATION: FCMP
			SYNTAX: <Dn>, #0.0
			BITDIFFS: ftype == '01' && PreferBitsEqual(Rm,'00000') && opc == '01'
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer m = UInt(Rm);   // ignored when opc<0> == '1'
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			boolean signal_all_nans = (opc<1> == '1');
			boolean cmp_with_zero = (opc<0> == '1');

IFORM: FCSEL_float
	TYPE: instruction
	XML: fcsel_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|cond=xxxx|11|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCSEL_H_floatsel
			OPERATION: FCSEL
			SYNTAX: <Hd>,<Hn>,<Hm>,<cond>
			BITDIFFS: ftype == '11'
		ENCODING: FCSEL_S_floatsel
			OPERATION: FCSEL
			SYNTAX: <Sd>,<Sn>,<Sm>,<cond>
			BITDIFFS: ftype == '00'
		ENCODING: FCSEL_D_floatsel
			OPERATION: FCSEL
			SYNTAX: <Dd>,<Dn>,<Dm>,<cond>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			bits(4) condition = cond;

IFORM: FCVTAS_advsimd
	TYPE: instruction
	XML: fcvtas_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|size<1>=0|111100|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAS_asisdmiscfp16_R
			OPERATION: FCVTAS
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|0|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAS_asisdmisc_R
			OPERATION: FCVTAS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|111100|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAS_asimdmiscfp16_R
			OPERATION: FCVTAS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAS_asimdmisc_R
			OPERATION: FCVTAS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');

IFORM: FCVTAS_float
	TYPE: instruction
	XML: fcvtas_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=100|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAS_32H_float2int
			OPERATION: FCVTAS
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTAS_64H_float2int
			OPERATION: FCVTAS
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTAS_32S_float2int
			OPERATION: FCVTAS
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTAS_64S_float2int
			OPERATION: FCVTAS
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTAS_32D_float2int
			OPERATION: FCVTAS
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTAS_64D_float2int
			OPERATION: FCVTAS
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTAU_advsimd
	TYPE: instruction
	XML: fcvtau_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|size<1>=0|111100|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAU_asisdmiscfp16_R
			OPERATION: FCVTAU
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|0|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAU_asisdmisc_R
			OPERATION: FCVTAU
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|111100|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAU_asimdmiscfp16_R
			OPERATION: FCVTAU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAU_asimdmisc_R
			OPERATION: FCVTAU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPRounding_TIEAWAY;
			boolean unsigned = (U == '1');

IFORM: FCVTAU_float
	TYPE: instruction
	XML: fcvtau_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=101|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTAU_32H_float2int
			OPERATION: FCVTAU
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTAU_64H_float2int
			OPERATION: FCVTAU
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTAU_32S_float2int
			OPERATION: FCVTAU
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTAU_64S_float2int
			OPERATION: FCVTAU
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTAU_32D_float2int
			OPERATION: FCVTAU
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTAU_64D_float2int
			OPERATION: FCVTAU
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTL_advsimd
	TYPE: instruction
	XML: fcvtl_advsimd.xml
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|opcode=10111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTL_asimdmisc_L
			OPERATION: FCVTL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16 << UInt(sz);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: FCVTMS_advsimd
	TYPE: instruction
	XML: fcvtms_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o2=0|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMS_asisdmiscfp16_R
			OPERATION: FCVTMS
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|o2=0|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMS_asisdmisc_R
			OPERATION: FCVTMS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=0|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMS_asimdmiscfp16_R
			OPERATION: FCVTMS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=0|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMS_asimdmisc_R
			OPERATION: FCVTMS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTMS_float
	TYPE: instruction
	XML: fcvtms_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=10|opcode=000|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMS_32H_float2int
			OPERATION: FCVTMS
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTMS_64H_float2int
			OPERATION: FCVTMS
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTMS_32S_float2int
			OPERATION: FCVTMS
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTMS_64S_float2int
			OPERATION: FCVTMS
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTMS_32D_float2int
			OPERATION: FCVTMS
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTMS_64D_float2int
			OPERATION: FCVTMS
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTMU_advsimd
	TYPE: instruction
	XML: fcvtmu_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|o2=0|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMU_asisdmiscfp16_R
			OPERATION: FCVTMU
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|o2=0|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMU_asisdmisc_R
			OPERATION: FCVTMU
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=0|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMU_asimdmiscfp16_R
			OPERATION: FCVTMU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=0|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMU_asimdmisc_R
			OPERATION: FCVTMU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTMU_float
	TYPE: instruction
	XML: fcvtmu_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=10|opcode=001|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTMU_32H_float2int
			OPERATION: FCVTMU
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTMU_64H_float2int
			OPERATION: FCVTMU
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTMU_32S_float2int
			OPERATION: FCVTMU
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTMU_64S_float2int
			OPERATION: FCVTMU
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTMU_32D_float2int
			OPERATION: FCVTMU
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTMU_64D_float2int
			OPERATION: FCVTMU
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTNS_advsimd
	TYPE: instruction
	XML: fcvtns_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o2=0|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNS_asisdmiscfp16_R
			OPERATION: FCVTNS
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|o2=0|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNS_asisdmisc_R
			OPERATION: FCVTNS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=0|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNS_asimdmiscfp16_R
			OPERATION: FCVTNS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=0|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNS_asimdmisc_R
			OPERATION: FCVTNS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTNS_float
	TYPE: instruction
	XML: fcvtns_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=000|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNS_32H_float2int
			OPERATION: FCVTNS
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTNS_64H_float2int
			OPERATION: FCVTNS
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTNS_32S_float2int
			OPERATION: FCVTNS
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTNS_64S_float2int
			OPERATION: FCVTNS
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTNS_32D_float2int
			OPERATION: FCVTNS
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTNS_64D_float2int
			OPERATION: FCVTNS
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTNU_advsimd
	TYPE: instruction
	XML: fcvtnu_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|o2=0|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNU_asisdmiscfp16_R
			OPERATION: FCVTNU
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|o2=0|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNU_asisdmisc_R
			OPERATION: FCVTNU
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=0|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNU_asimdmiscfp16_R
			OPERATION: FCVTNU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=0|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNU_asimdmisc_R
			OPERATION: FCVTNU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTNU_float
	TYPE: instruction
	XML: fcvtnu_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=001|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTNU_32H_float2int
			OPERATION: FCVTNU
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTNU_64H_float2int
			OPERATION: FCVTNU
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTNU_32S_float2int
			OPERATION: FCVTNU
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTNU_64S_float2int
			OPERATION: FCVTNU
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTNU_32D_float2int
			OPERATION: FCVTNU
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTNU_64D_float2int
			OPERATION: FCVTNU
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTN_advsimd
	TYPE: instruction
	XML: fcvtn_advsimd.xml
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|opcode=10110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTN_asimdmisc_N
			OPERATION: FCVTN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16 << UInt(sz);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: FCVTPS_advsimd
	TYPE: instruction
	XML: fcvtps_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o2=1|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPS_asisdmiscfp16_R
			OPERATION: FCVTPS
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|o2=1|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPS_asisdmisc_R
			OPERATION: FCVTPS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=1|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPS_asimdmiscfp16_R
			OPERATION: FCVTPS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=1|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPS_asimdmisc_R
			OPERATION: FCVTPS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTPS_float
	TYPE: instruction
	XML: fcvtps_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=01|opcode=000|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPS_32H_float2int
			OPERATION: FCVTPS
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTPS_64H_float2int
			OPERATION: FCVTPS
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTPS_32S_float2int
			OPERATION: FCVTPS
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTPS_64S_float2int
			OPERATION: FCVTPS
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTPS_32D_float2int
			OPERATION: FCVTPS
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTPS_64D_float2int
			OPERATION: FCVTPS
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTPU_advsimd
	TYPE: instruction
	XML: fcvtpu_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|o2=1|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPU_asisdmiscfp16_R
			OPERATION: FCVTPU
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|o2=1|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPU_asisdmisc_R
			OPERATION: FCVTPU
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=1|111100|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPU_asimdmiscfp16_R
			OPERATION: FCVTPU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=1|sz=x|10000|1101|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPU_asimdmisc_R
			OPERATION: FCVTPU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTPU_float
	TYPE: instruction
	XML: fcvtpu_float.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=01|opcode=001|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTPU_32H_float2int
			OPERATION: FCVTPU
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTPU_64H_float2int
			OPERATION: FCVTPU
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTPU_32S_float2int
			OPERATION: FCVTPU
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTPU_64S_float2int
			OPERATION: FCVTPU
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTPU_32D_float2int
			OPERATION: FCVTPU
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTPU_64D_float2int
			OPERATION: FCVTPU
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTXN_advsimd
	TYPE: instruction
	XML: fcvtxn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|0|sz=x|10000|opcode=10110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTXN_asisdmisc_N
			OPERATION: FCVTXN
			SYNTAX: <Vb><d>,<Va><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz == '0' then UNDEFINED;
			integer esize = 32;
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|10000|opcode=10110|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTXN_asimdmisc_N
			OPERATION: FCVTXN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz == '0' then UNDEFINED;
			integer esize = 32;
			integer datasize = 64;
			integer elements = 2;
			integer part = UInt(Q);

IFORM: FCVTZS_advsimd_fix
	TYPE: instruction
	XML: fcvtzs_advsimd_fix.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asisdshf_C
			OPERATION: FCVTZS
			SYNTAX: <V><d>,<V><n>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = esize;
			integer elements = 1;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRounding_ZERO;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asimdshf_C
			OPERATION: FCVTZS
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRounding_ZERO;

IFORM: FCVTZS_advsimd_int
	TYPE: instruction
	XML: fcvtzs_advsimd_int.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o2=1|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asisdmiscfp16_R
			OPERATION: FCVTZS
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|o2=1|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asisdmisc_R
			OPERATION: FCVTZS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=1|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asimdmiscfp16_R
			OPERATION: FCVTZS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=1|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_asimdmisc_R
			OPERATION: FCVTZS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTZS_float_fix
	TYPE: instruction
	XML: fcvtzs_float_fix.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|0|rmode=11|opcode=000|scale=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_32H_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Hn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTZS_64H_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Hn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTZS_32S_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Sn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTZS_64S_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Sn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTZS_32D_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Dn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTZS_64D_float2fix
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Dn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			case ftype of
			    when '00' fltsize = 32;
			    when '01' fltsize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			if sf == '0' && scale<5> == '0' then UNDEFINED;
			integer fracbits = 64 - UInt(scale);
			case opcode<2:1>:rmode of
			    when '00 11'        // FCVTZ
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    otherwise
			        UNDEFINED;

IFORM: FCVTZS_float_int
	TYPE: instruction
	XML: fcvtzs_float_int.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=11|opcode=000|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZS_32H_float2int
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTZS_64H_float2int
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTZS_32S_float2int
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTZS_64S_float2int
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTZS_32D_float2int
			OPERATION: FCVTZS
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTZS_64D_float2int
			OPERATION: FCVTZS
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVTZU_advsimd_fix
	TYPE: instruction
	XML: fcvtzu_advsimd_fix.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asisdshf_C
			OPERATION: FCVTZU
			SYNTAX: <V><d>,<V><n>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = esize;
			integer elements = 1;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRounding_ZERO;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asimdshf_C
			OPERATION: FCVTZU
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRounding_ZERO;

IFORM: FCVTZU_advsimd_int
	TYPE: instruction
	XML: fcvtzu_advsimd_int.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|o2=1|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asisdmiscfp16_R
			OPERATION: FCVTZU
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|o2=1|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asisdmisc_R
			OPERATION: FCVTZU
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=1|111100|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asimdmiscfp16_R
			OPERATION: FCVTZU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=1|sz=x|10000|1101|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_asimdmisc_R
			OPERATION: FCVTZU
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			FPRounding rounding = FPDecodeRounding(o1:o2);
			boolean unsigned = (U == '1');

IFORM: FCVTZU_float_fix
	TYPE: instruction
	XML: fcvtzu_float_fix.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|0|rmode=11|opcode=001|scale=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_32H_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Hn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTZU_64H_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Hn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTZU_32S_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Sn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTZU_64S_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Sn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTZU_32D_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Dn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTZU_64D_float2fix
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Dn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			case ftype of
			    when '00' fltsize = 32;
			    when '01' fltsize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			if sf == '0' && scale<5> == '0' then UNDEFINED;
			integer fracbits = 64 - UInt(scale);
			case opcode<2:1>:rmode of
			    when '00 11'        // FCVTZ
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    otherwise
			        UNDEFINED;

IFORM: FCVTZU_float_int
	TYPE: instruction
	XML: fcvtzu_float_int.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=11|opcode=001|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVTZU_32H_float2int
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: FCVTZU_64H_float2int
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: FCVTZU_32S_float2int
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: FCVTZU_64S_float2int
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Sn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: FCVTZU_32D_float2int
			OPERATION: FCVTZU
			SYNTAX: <Wd>,<Dn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: FCVTZU_64D_float2int
			OPERATION: FCVTZU
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FCVT_float
	TYPE: instruction
	XML: fcvt_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|0001|opc=xx|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FCVT_SH_floatdp1
			OPERATION: FCVT
			SYNTAX: <Sd>,<Hn>
			BITDIFFS: ftype == '11' && opc == '00'
		ENCODING: FCVT_DH_floatdp1
			OPERATION: FCVT
			SYNTAX: <Dd>,<Hn>
			BITDIFFS: ftype == '11' && opc == '01'
		ENCODING: FCVT_HS_floatdp1
			OPERATION: FCVT
			SYNTAX: <Hd>,<Sn>
			BITDIFFS: ftype == '00' && opc == '11'
		ENCODING: FCVT_DS_floatdp1
			OPERATION: FCVT
			SYNTAX: <Dd>,<Sn>
			BITDIFFS: ftype == '00' && opc == '01'
		ENCODING: FCVT_HD_floatdp1
			OPERATION: FCVT
			SYNTAX: <Hd>,<Dn>
			BITDIFFS: ftype == '01' && opc == '11'
		ENCODING: FCVT_SD_floatdp1
			OPERATION: FCVT
			SYNTAX: <Sd>,<Dn>
			BITDIFFS: ftype == '01' && opc == '00'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer srcsize;
			integer dstsize;
			if ftype == opc then UNDEFINED;
			case ftype of
			    when '00' srcsize = 32;
			    when '01' srcsize = 64;
			    when '10' UNDEFINED;
			    when '11' srcsize = 16;
			case opc of
			    when '00' dstsize = 32;
			    when '01' dstsize = 64;
			    when '10' UNDEFINED;
			    when '11' dstsize = 16;

IFORM: FDIV_advsimd
	TYPE: instruction
	XML: fdiv_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|10|Rm=xxxxx|00|opcode=111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FDIV_asimdsamefp16_only
			OPERATION: FDIV
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|1|Rm=xxxxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FDIV_asimdsame_only
			OPERATION: FDIV
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FDIV_float
	TYPE: instruction
	XML: fdiv_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|opcode=0001|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FDIV_H_floatdp2
			OPERATION: FDIV
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FDIV_S_floatdp2
			OPERATION: FDIV
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FDIV_D_floatdp2
			OPERATION: FDIV
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;

IFORM: FJCVTZS
	TYPE: instruction
	XML: fjcvtzs.xml
	CLASS: double_to_32
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_JSCVT
		FIELDS32: sf=0|0|S=0|11110|ftype=01|1|rmode=11|opcode=110|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FJCVTZS_32D_float2int
			OPERATION: FJCVTZS
			SYNTAX: <Wd>,<Dn>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FMADD_float
	TYPE: instruction
	XML: fmadd_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11111|ftype=xx|o1=0|Rm=xxxxx|o0=0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMADD_H_floatdp3
			OPERATION: FMADD
			SYNTAX: <Hd>,<Hn>,<Hm>,<Ha>
			BITDIFFS: ftype == '11'
		ENCODING: FMADD_S_floatdp3
			OPERATION: FMADD
			SYNTAX: <Sd>,<Sn>,<Sm>,<Sa>
			BITDIFFS: ftype == '00'
		ENCODING: FMADD_D_floatdp3
			OPERATION: FMADD
			SYNTAX: <Dd>,<Dn>,<Dm>,<Da>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer a = UInt(Ra);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean opa_neg = (o1 == '1');
			boolean op1_neg = (o0 != o1);

IFORM: FMAXNMP_advsimd_pair
	TYPE: instruction
	XML: fmaxnmp_advsimd_pair.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o1=0|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMP_asisdpair_only_H
			OPERATION: FMAXNMP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			if sz == '1' then UNDEFINED;
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
	CLASS: single_and_double
		FIELDS32: 01|U=1|11110|o1=0|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMP_asisdpair_only_SD
			OPERATION: FMAXNMP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

IFORM: FMAXNMP_advsimd_vec
	TYPE: instruction
	XML: fmaxnmp_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|10|Rm=xxxxx|00|Op3=000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMP_asimdsamefp16_only
			OPERATION: FMAXNMP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=0|sz=x|1|Rm=xxxxx|opcode=11000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMP_asimdsame_only
			OPERATION: FMAXNMP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMAXNMV_advsimd
	TYPE: instruction
	XML: fmaxnmv_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=0|0|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMV_asimdall_only_H
			OPERATION: FMAXNMV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=0|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNMV_asimdall_only_SD
			OPERATION: FMAXNMV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q != '01' then UNDEFINED; // .4S only
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

IFORM: FMAXNM_advsimd
	TYPE: instruction
	XML: fmaxnm_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|10|Rm=xxxxx|00|Op3=000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNM_asimdsamefp16_only
			OPERATION: FMAXNM
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o1=0|sz=x|1|Rm=xxxxx|opcode=11000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNM_asimdsame_only
			OPERATION: FMAXNM
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMAXNM_float
	TYPE: instruction
	XML: fmaxnm_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|01|op=10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXNM_H_floatdp2
			OPERATION: FMAXNM
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FMAXNM_S_floatdp2
			OPERATION: FMAXNM
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FMAXNM_D_floatdp2
			OPERATION: FMAXNM
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPMaxMinOp operation;
			case op of
			    when '00' operation = FPMaxMinOp_MAX;
			    when '01' operation = FPMaxMinOp_MIN;
			    when '10' operation = FPMaxMinOp_MAXNUM;
			    when '11' operation = FPMaxMinOp_MINNUM;

IFORM: FMAXP_advsimd_pair
	TYPE: instruction
	XML: fmaxp_advsimd_pair.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o1=0|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXP_asisdpair_only_H
			OPERATION: FMAXP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			if sz == '1' then UNDEFINED;
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;
	CLASS: single_and_double
		FIELDS32: 01|U=1|11110|o1=0|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXP_asisdpair_only_SD
			OPERATION: FMAXP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

IFORM: FMAXP_advsimd_vec
	TYPE: instruction
	XML: fmaxp_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o1=0|10|Rm=xxxxx|00|opcode=110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXP_asimdsamefp16_only
			OPERATION: FMAXP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=0|sz=x|1|Rm=xxxxx|opcode=11110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXP_asimdsame_only
			OPERATION: FMAXP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMAXV_advsimd
	TYPE: instruction
	XML: fmaxv_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=0|0|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXV_asimdall_only_H
			OPERATION: FMAXV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=0|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAXV_asimdall_only_SD
			OPERATION: FMAXV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q != '01' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

IFORM: FMAX_advsimd
	TYPE: instruction
	XML: fmax_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=0|10|Rm=xxxxx|00|opcode=110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAX_asimdsamefp16_only
			OPERATION: FMAX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o1=0|sz=x|1|Rm=xxxxx|opcode=11110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAX_asimdsame_only
			OPERATION: FMAX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMAX_float
	TYPE: instruction
	XML: fmax_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|01|op=00|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMAX_H_floatdp2
			OPERATION: FMAX
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FMAX_S_floatdp2
			OPERATION: FMAX
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FMAX_D_floatdp2
			OPERATION: FMAX
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPMaxMinOp operation;
			case op of
			    when '00' operation = FPMaxMinOp_MAX;
			    when '01' operation = FPMaxMinOp_MIN;
			    when '10' operation = FPMaxMinOp_MAXNUM;
			    when '11' operation = FPMaxMinOp_MINNUM;

IFORM: FMINNMP_advsimd_pair
	TYPE: instruction
	XML: fminnmp_advsimd_pair.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o1=1|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMP_asisdpair_only_H
			OPERATION: FMINNMP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			if sz == '1' then UNDEFINED;
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
	CLASS: single_and_double
		FIELDS32: 01|U=1|11110|o1=1|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMP_asisdpair_only_SD
			OPERATION: FMINNMP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

IFORM: FMINNMP_advsimd_vec
	TYPE: instruction
	XML: fminnmp_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|10|Rm=xxxxx|00|Op3=000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMP_asimdsamefp16_only
			OPERATION: FMINNMP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=1|sz=x|1|Rm=xxxxx|opcode=11000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMP_asimdsame_only
			OPERATION: FMINNMP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMINNMV_advsimd
	TYPE: instruction
	XML: fminnmv_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=1|0|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMV_asimdall_only_H
			OPERATION: FMINNMV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=1|sz=x|11000|opcode=01100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNMV_asimdall_only_SD
			OPERATION: FMINNMV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q != '01' then UNDEFINED; // .4S only
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

IFORM: FMINNM_advsimd
	TYPE: instruction
	XML: fminnm_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|10|Rm=xxxxx|00|Op3=000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNM_asimdsamefp16_only
			OPERATION: FMINNM
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o1=1|sz=x|1|Rm=xxxxx|opcode=11000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNM_asimdsame_only
			OPERATION: FMINNM
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMINNM_float
	TYPE: instruction
	XML: fminnm_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|01|op=11|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINNM_H_floatdp2
			OPERATION: FMINNM
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FMINNM_S_floatdp2
			OPERATION: FMINNM
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FMINNM_D_floatdp2
			OPERATION: FMINNM
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPMaxMinOp operation;
			case op of
			    when '00' operation = FPMaxMinOp_MAX;
			    when '01' operation = FPMaxMinOp_MIN;
			    when '10' operation = FPMaxMinOp_MAXNUM;
			    when '11' operation = FPMaxMinOp_MINNUM;

IFORM: FMINP_advsimd_pair
	TYPE: instruction
	XML: fminp_advsimd_pair.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|o1=1|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINP_asisdpair_only_H
			OPERATION: FMINP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			if sz == '1' then UNDEFINED;
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;
	CLASS: single_and_double
		FIELDS32: 01|U=1|11110|o1=1|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINP_asisdpair_only_SD
			OPERATION: FMINP
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize * 2;
			integer elements = 2;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

IFORM: FMINP_advsimd_vec
	TYPE: instruction
	XML: fminp_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o1=1|10|Rm=xxxxx|00|opcode=110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINP_asimdsamefp16_only
			OPERATION: FMINP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=1|sz=x|1|Rm=xxxxx|opcode=11110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINP_asimdsame_only
			OPERATION: FMINP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMINV_advsimd
	TYPE: instruction
	XML: fminv_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=1|0|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINV_asimdall_only_H
			OPERATION: FMINV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o1=1|sz=x|11000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMINV_asimdall_only_SD
			OPERATION: FMINV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q != '01' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

IFORM: FMIN_advsimd
	TYPE: instruction
	XML: fmin_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o1=1|10|Rm=xxxxx|00|opcode=110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMIN_asimdsamefp16_only
			OPERATION: FMIN
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o1=1|sz=x|1|Rm=xxxxx|opcode=11110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMIN_asimdsame_only
			OPERATION: FMIN
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean pair = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: FMIN_float
	TYPE: instruction
	XML: fmin_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|01|op=01|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMIN_H_floatdp2
			OPERATION: FMIN
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FMIN_S_floatdp2
			OPERATION: FMIN
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FMIN_D_floatdp2
			OPERATION: FMIN
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPMaxMinOp operation;
			case op of
			    when '00' operation = FPMaxMinOp_MAX;
			    when '01' operation = FPMaxMinOp_MIN;
			    when '10' operation = FPMaxMinOp_MAXNUM;
			    when '11' operation = FPMaxMinOp_MINNUM;

IFORM: FMLAL_advsimd_elt
	TYPE: instruction
	XML: fmlal_advsimd_elt.xml
	CLASS: fmlal
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=0|01111|size[1]=1|sz=0|L=x|M=x|Rm=xxxx|opcode[3]=0|S=0|opcode[1:0]=00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLAL_asimdelem_LH
			OPERATION: FMLAL
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
			if sz == '1' then UNDEFINED;
			integer index = UInt(H:L:M);
			integer esize = 32;
			integer datasize = if Q=='1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 0;
	CLASS: fmlal2
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=1|01111|size[1]=1|sz=0|L=x|M=x|Rm=xxxx|opcode[3]=1|S=0|opcode[1:0]=00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLAL2_asimdelem_LH
			OPERATION: FMLAL2
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
			if sz == '1' then UNDEFINED;
			integer index = UInt(H:L:M);
			integer esize = 32;
			integer datasize = if Q=='1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 1;

IFORM: FMLAL_advsimd_vec
	TYPE: instruction
	XML: fmlal_advsimd_vec.xml
	CLASS: fmlal
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=0|01110|S=0|sz=0|1|Rm=xxxxx|opcode[4]=1|opcode[3:0]=1101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLAL_asimdsame_F
			OPERATION: FMLAL
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 0;
	CLASS: fmlal2
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=1|01110|S=0|sz=0|1|Rm=xxxxx|opcode[4]=1|opcode[3:0]=1001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLAL2_asimdsame_F
			OPERATION: FMLAL2
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 1;

IFORM: FMLA_advsimd_elt
	TYPE: instruction
	XML: fmla_advsimd_elt.xml
	CLASS: 2reg_scalar_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11111|size=00|L=x|M=x|Rm=xxxx|0|o2=0|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asisdelem_RH_H
			OPERATION: FMLA
			SYNTAX: <Hd>,<Hn>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_scalar_single_and_double
		FIELDS32: 01|U=0|11111|1|sz=x|L=x|M=x|Rm=xxxx|0|o2=0|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asisdelem_R_SD
			OPERATION: FMLA
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01111|size=00|L=x|M=x|Rm=xxxx|0|o2=0|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asimdelem_RH_H
			OPERATION: FMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element_single_and_double
		FIELDS32: 0|Q=x|U=0|01111|1|sz=x|L=x|M=x|Rm=xxxx|0|o2=0|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asimdelem_R_SD
			OPERATION: FMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: FMLA_advsimd_vec
	TYPE: instruction
	XML: fmla_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|10|Rm=xxxxx|00|opcode=001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asimdsamefp16_only
			OPERATION: FMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|op=0|sz=x|1|Rm=xxxxx|opcode=11001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLA_asimdsame_only
			OPERATION: FMLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (op == '1');

IFORM: FMLSL_advsimd_elt
	TYPE: instruction
	XML: fmlsl_advsimd_elt.xml
	CLASS: fmlsl
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=0|01111|size[1]=1|sz=0|L=x|M=x|Rm=xxxx|opcode[3]=0|S=1|opcode[1:0]=00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLSL_asimdelem_LH
			OPERATION: FMLSL
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
			if sz == '1' then UNDEFINED;
			integer index = UInt(H:L:M);
			integer esize = 32;
			integer datasize = if Q=='1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 0;
	CLASS: fmlsl2
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=1|01111|size[1]=1|sz=0|L=x|M=x|Rm=xxxx|opcode[3]=1|S=1|opcode[1:0]=00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLSL2_asimdelem_LH
			OPERATION: FMLSL2
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
			if sz == '1' then UNDEFINED;
			integer index = UInt(H:L:M);
			integer esize = 32;
			integer datasize = if Q=='1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 1;

IFORM: FMLSL_advsimd_vec
	TYPE: instruction
	XML: fmlsl_advsimd_vec.xml
	CLASS: fmlsl
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=0|01110|S=1|sz=0|1|Rm=xxxxx|opcode[4]=1|opcode[3:0]=1101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLSL_asimdsame_F
			OPERATION: FMLSL
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 0;
	CLASS: fmlsl2
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FHM
		FIELDS32: 0|Q=x|U=1|01110|S=1|sz=0|1|Rm=xxxxx|opcode[4]=1|opcode[3:0]=1001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLSL2_asimdsame_F
			OPERATION: FMLSL2
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (S == '1');
			integer part = 1;

IFORM: FMLS_advsimd_elt
	TYPE: instruction
	XML: fmls_advsimd_elt.xml
	CLASS: 2reg_scalar_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11111|size=00|L=x|M=x|Rm=xxxx|0|o2=1|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asisdelem_RH_H
			OPERATION: FMLS
			SYNTAX: <Hd>,<Hn>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_scalar_single_and_double
		FIELDS32: 01|U=0|11111|1|sz=x|L=x|M=x|Rm=xxxx|0|o2=1|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asisdelem_R_SD
			OPERATION: FMLS
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01111|size=00|L=x|M=x|Rm=xxxx|0|o2=1|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asimdelem_RH_H
			OPERATION: FMLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element_single_and_double
		FIELDS32: 0|Q=x|U=0|01111|1|sz=x|L=x|M=x|Rm=xxxx|0|o2=1|01|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asimdelem_R_SD
			OPERATION: FMLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: FMLS_advsimd_vec
	TYPE: instruction
	XML: fmls_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|10|Rm=xxxxx|00|opcode=001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asimdsamefp16_only
			OPERATION: FMLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (a == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|op=1|sz=x|1|Rm=xxxxx|opcode=11001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMLS_asimdsame_only
			OPERATION: FMLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (op == '1');

IFORM: FMOV_advsimd
	TYPE: instruction
	XML: fmov_advsimd.xml
	CLASS: per_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|op=0|0111100000|a=x|b=x|c=x|cmode=1111|o2=1|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: FMOV_asimdimm_H_h
			OPERATION: FMOV
			SYNTAX: <Vd>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			imm8 = a:b:c:d:e:f:g:h;
			imm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);
			imm = Replicate(imm16, datasize DIV 16);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|op=x|0111100000|a=x|b=x|c=x|cmode=1111|o2=0|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: FMOV_asimdimm_S_s
			OPERATION: FMOV
			SYNTAX: <Vd>.<T>, #<imm>
			BITDIFFS: op == '0'
		ENCODING: FMOV_asimdimm_D2_d
			OPERATION: FMOV
			SYNTAX: <Vd>.2D, #<imm>
			BITDIFFS: Q == '1' && op == '1'
		DECODE_PCODE:
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			bits(64) imm64;
			ImmediateOp operation;
			case cmode:op of
			    when '0xx00' operation = ImmediateOp_MOVI;
			    when '0xx01' operation = ImmediateOp_MVNI;
			    when '0xx10' operation = ImmediateOp_ORR;
			    when '0xx11' operation = ImmediateOp_BIC;
			    when '10x00' operation = ImmediateOp_MOVI;
			    when '10x01' operation = ImmediateOp_MVNI;
			    when '10x10' operation = ImmediateOp_ORR;
			    when '10x11' operation = ImmediateOp_BIC;
			    when '110x0' operation = ImmediateOp_MOVI;
			    when '110x1' operation = ImmediateOp_MVNI;
			    when '1110x' operation = ImmediateOp_MOVI;
			    when '11110' operation = ImmediateOp_MOVI;
			    when '11111'
			        // FMOV Dn,#imm is in main FP instruction set
			        if Q == '0' then UNDEFINED;
			        operation = ImmediateOp_MOVI;
			imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
			imm = Replicate(imm64, datasize DIV 64);

IFORM: FMOV_cpy_z_p_i
	TYPE: alias
	XML: fmov_cpy_z_p_i.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|0|M=1|sh=0|imm8=00000000|Zd=xxxxx
		ENCODING: FMOV_cpy_z_p_i_
			OPERATION: FMOV
			SYNTAX: <Zd>.<T>,<Pg>/M, #0.0

IFORM: FMOV_dup_z_i
	TYPE: alias
	XML: fmov_dup_z_i.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|111|opc=00|011|sh=0|imm8=00000000|Zd=xxxxx
		ENCODING: FMOV_dup_z_i_
			OPERATION: FMOV
			SYNTAX: <Zd>.<T>, #0.0

IFORM: FMOV_fcpy_z_p_i
	TYPE: alias
	XML: fmov_fcpy_z_p_i.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|110|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: FMOV_fcpy_z_p_i_
			OPERATION: FMOV
			SYNTAX: <Zd>.<T>,<Pg>/M, #<const>

IFORM: FMOV_fdup_z_i
	TYPE: alias
	XML: fmov_fdup_z_i.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|111|opc=00|111|o2=0|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: FMOV_fdup_z_i_
			OPERATION: FMOV
			SYNTAX: <Zd>.<T>, #<const>

IFORM: FMOV_float
	TYPE: instruction
	XML: fmov_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|0000|opc=00|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMOV_H_floatdp1
			OPERATION: FMOV
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FMOV_S_floatdp1
			OPERATION: FMOV
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FMOV_D_floatdp1
			OPERATION: FMOV
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPUnaryOp fpop;
			case opc of
			    when '00' fpop = FPUnaryOp_MOV;
			    when '01' fpop = FPUnaryOp_ABS;
			    when '10' fpop = FPUnaryOp_NEG;
			    when '11' fpop = FPUnaryOp_SQRT;

IFORM: FMOV_float_gen
	TYPE: instruction
	XML: fmov_float_gen.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=0x|opcode=11x|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMOV_32H_float2int
			OPERATION: FMOV
			SYNTAX: <Wd>,<Hn>
			BITDIFFS: sf == '0' && ftype == '11' && rmode == '00' && opcode == '110'
		ENCODING: FMOV_64H_float2int
			OPERATION: FMOV
			SYNTAX: <Xd>,<Hn>
			BITDIFFS: sf == '1' && ftype == '11' && rmode == '00' && opcode == '110'
		ENCODING: FMOV_H32_float2int
			OPERATION: FMOV
			SYNTAX: <Hd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '11' && rmode == '00' && opcode == '111'
		ENCODING: FMOV_S32_float2int
			OPERATION: FMOV
			SYNTAX: <Sd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '00' && rmode == '00' && opcode == '111'
		ENCODING: FMOV_32S_float2int
			OPERATION: FMOV
			SYNTAX: <Wd>,<Sn>
			BITDIFFS: sf == '0' && ftype == '00' && rmode == '00' && opcode == '110'
		ENCODING: FMOV_H64_float2int
			OPERATION: FMOV
			SYNTAX: <Hd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '11' && rmode == '00' && opcode == '111'
		ENCODING: FMOV_D64_float2int
			OPERATION: FMOV
			SYNTAX: <Dd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '01' && rmode == '00' && opcode == '111'
		ENCODING: FMOV_V64I_float2int
			OPERATION: FMOV
			SYNTAX: <Vd>.D[1],<Xn>
			BITDIFFS: sf == '1' && ftype == '10' && rmode == '01' && opcode == '111'
		ENCODING: FMOV_64D_float2int
			OPERATION: FMOV
			SYNTAX: <Xd>,<Dn>
			BITDIFFS: sf == '1' && ftype == '01' && rmode == '00' && opcode == '110'
		ENCODING: FMOV_64VX_float2int
			OPERATION: FMOV
			SYNTAX: <Xd>,<Vn>.D[1]
			BITDIFFS: sf == '1' && ftype == '10' && rmode == '01' && opcode == '110'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: FMOV_float_imm
	TYPE: instruction
	XML: fmov_float_imm.xml
	CLASS: imm8f
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|imm8=xxxxxxxx|100|imm5=00000|Rd=xxxxx
		ENCODING: FMOV_H_floatimm
			OPERATION: FMOV
			SYNTAX: <Hd>, #<imm>
			BITDIFFS: ftype == '11'
		ENCODING: FMOV_S_floatimm
			OPERATION: FMOV
			SYNTAX: <Sd>, #<imm>
			BITDIFFS: ftype == '00'
		ENCODING: FMOV_D_floatimm
			OPERATION: FMOV
			SYNTAX: <Dd>, #<imm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer datasize;
			case ftype of
			    when '00' datasize = 32;
			    when '01' datasize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            datasize = 16;
			        else
			            UNDEFINED;
			bits(datasize) imm = VFPExpandImm(imm8);

IFORM: FMSUB_float
	TYPE: instruction
	XML: fmsub_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11111|ftype=xx|o1=0|Rm=xxxxx|o0=1|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMSUB_H_floatdp3
			OPERATION: FMSUB
			SYNTAX: <Hd>,<Hn>,<Hm>,<Ha>
			BITDIFFS: ftype == '11'
		ENCODING: FMSUB_S_floatdp3
			OPERATION: FMSUB
			SYNTAX: <Sd>,<Sn>,<Sm>,<Sa>
			BITDIFFS: ftype == '00'
		ENCODING: FMSUB_D_floatdp3
			OPERATION: FMSUB
			SYNTAX: <Dd>,<Dn>,<Dm>,<Da>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer a = UInt(Ra);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean opa_neg = (o1 == '1');
			boolean op1_neg = (o0 != o1);

IFORM: FMULX_advsimd_elt
	TYPE: instruction
	XML: fmulx_advsimd_elt.xml
	CLASS: 2reg_scalar_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11111|size=00|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asisdelem_RH_H
			OPERATION: FMULX
			SYNTAX: <Hd>,<Hn>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_scalar_single_and_double
		FIELDS32: 01|U=1|11111|1|sz=x|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asisdelem_R_SD
			OPERATION: FMULX
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_element_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01111|size=00|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asimdelem_RH_H
			OPERATION: FMULX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_element_single_and_double
		FIELDS32: 0|Q=x|U=1|01111|1|sz=x|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asimdelem_R_SD
			OPERATION: FMULX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean mulx_op = (U == '1');

IFORM: FMULX_advsimd_vec
	TYPE: instruction
	XML: fmulx_advsimd_vec.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=0|10|Rm=xxxxx|00|opcode=011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asisdsamefp16_only
			OPERATION: FMULX
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|0|sz=x|1|Rm=xxxxx|opcode=11011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asisdsame_only
			OPERATION: FMULX
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|10|Rm=xxxxx|00|opcode=011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asimdsamefp16_only
			OPERATION: FMULX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|1|Rm=xxxxx|opcode=11011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMULX_asimdsame_only
			OPERATION: FMULX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FMUL_advsimd_elt
	TYPE: instruction
	XML: fmul_advsimd_elt.xml
	CLASS: 2reg_scalar_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11111|size=00|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asisdelem_RH_H
			OPERATION: FMUL
			SYNTAX: <Hd>,<Hn>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_scalar_single_and_double
		FIELDS32: 01|U=0|11111|1|sz=x|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asisdelem_R_SD
			OPERATION: FMUL
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_element_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01111|size=00|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asimdelem_RH_H
			OPERATION: FMUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.H[<index>]
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer index = UInt(H:L:M);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean mulx_op = (U == '1');
	CLASS: 2reg_element_single_and_double
		FIELDS32: 0|Q=x|U=0|01111|1|sz=x|L=x|M=x|Rm=xxxx|opcode=1001|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asimdelem_R_SD
			OPERATION: FMUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi = M;
			case sz:L of
			    when '0x' index = UInt(H:L);
			    when '10' index = UInt(H);
			    when '11' UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean mulx_op = (U == '1');

IFORM: FMUL_advsimd_vec
	TYPE: instruction
	XML: fmul_advsimd_vec.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|10|Rm=xxxxx|00|opcode=011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asimdsamefp16_only
			OPERATION: FMUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|1|Rm=xxxxx|opcode=11011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_asimdsame_only
			OPERATION: FMUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FMUL_float
	TYPE: instruction
	XML: fmul_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|op=0|000|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FMUL_H_floatdp2
			OPERATION: FMUL
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FMUL_S_floatdp2
			OPERATION: FMUL
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FMUL_D_floatdp2
			OPERATION: FMUL
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean negated = (op == '1');

IFORM: FNEG_advsimd
	TYPE: instruction
	XML: fneg_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|111100|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNEG_asimdmiscfp16_R
			OPERATION: FNEG
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|opcode=01111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNEG_asimdmisc_R
			OPERATION: FNEG
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: FNEG_float
	TYPE: instruction
	XML: fneg_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|0000|opc=10|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNEG_H_floatdp1
			OPERATION: FNEG
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FNEG_S_floatdp1
			OPERATION: FNEG
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FNEG_D_floatdp1
			OPERATION: FNEG
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPUnaryOp fpop;
			case opc of
			    when '00' fpop = FPUnaryOp_MOV;
			    when '01' fpop = FPUnaryOp_ABS;
			    when '10' fpop = FPUnaryOp_NEG;
			    when '11' fpop = FPUnaryOp_SQRT;

IFORM: FNMADD_float
	TYPE: instruction
	XML: fnmadd_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11111|ftype=xx|o1=1|Rm=xxxxx|o0=0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNMADD_H_floatdp3
			OPERATION: FNMADD
			SYNTAX: <Hd>,<Hn>,<Hm>,<Ha>
			BITDIFFS: ftype == '11'
		ENCODING: FNMADD_S_floatdp3
			OPERATION: FNMADD
			SYNTAX: <Sd>,<Sn>,<Sm>,<Sa>
			BITDIFFS: ftype == '00'
		ENCODING: FNMADD_D_floatdp3
			OPERATION: FNMADD
			SYNTAX: <Dd>,<Dn>,<Dm>,<Da>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer a = UInt(Ra);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean opa_neg = (o1 == '1');
			boolean op1_neg = (o0 != o1);

IFORM: FNMSUB_float
	TYPE: instruction
	XML: fnmsub_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11111|ftype=xx|o1=1|Rm=xxxxx|o0=1|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNMSUB_H_floatdp3
			OPERATION: FNMSUB
			SYNTAX: <Hd>,<Hn>,<Hm>,<Ha>
			BITDIFFS: ftype == '11'
		ENCODING: FNMSUB_S_floatdp3
			OPERATION: FNMSUB
			SYNTAX: <Sd>,<Sn>,<Sm>,<Sa>
			BITDIFFS: ftype == '00'
		ENCODING: FNMSUB_D_floatdp3
			OPERATION: FNMSUB
			SYNTAX: <Dd>,<Dn>,<Dm>,<Da>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer a = UInt(Ra);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean opa_neg = (o1 == '1');
			boolean op1_neg = (o0 != o1);

IFORM: FNMUL_float
	TYPE: instruction
	XML: fnmul_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|op=1|000|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FNMUL_H_floatdp2
			OPERATION: FNMUL
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FNMUL_S_floatdp2
			OPERATION: FNMUL
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FNMUL_D_floatdp2
			OPERATION: FNMUL
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean negated = (op == '1');

IFORM: FRECPE_advsimd
	TYPE: instruction
	XML: frecpe_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|size<1>=1|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPE_asisdmiscfp16_R
			OPERATION: FRECPE
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPE_asisdmisc_R
			OPERATION: FRECPE
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPE_asimdmiscfp16_R
			OPERATION: FRECPE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPE_asimdmisc_R
			OPERATION: FRECPE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FRECPS_advsimd
	TYPE: instruction
	XML: frecps_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=0|10|Rm=xxxxx|00|opcode=111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPS_asisdsamefp16_only
			OPERATION: FRECPS
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|0|sz=x|1|Rm=xxxxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPS_asisdsame_only
			OPERATION: FRECPS
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|10|Rm=xxxxx|00|opcode=111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPS_asimdsamefp16_only
			OPERATION: FRECPS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|1|Rm=xxxxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPS_asimdsame_only
			OPERATION: FRECPS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FRECPX_advsimd
	TYPE: instruction
	XML: frecpx_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=1|111100|opcode=11111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPX_asisdmiscfp16_R
			OPERATION: FRECPX
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|10000|opcode=11111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRECPX_asisdmisc_R
			OPERATION: FRECPX
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;

IFORM: FRINT32X_advsimd
	TYPE: instruction
	XML: frint32x_advsimd.xml
	CLASS: simd_single_and_double
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|10000|1111|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT32X_asimdmisc_R
			OPERATION: FRINT32X
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer intsize = if op == '0' then 32 else 64;
			FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT32X_float
	TYPE: instruction
	XML: frint32x_float.xml
	CLASS: float
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: M=0|0|S=0|11110|ftype=0x|1|0100|op=01|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT32X_S_floatdp1
			OPERATION: FRINT32X
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINT32X_D_floatdp1
			OPERATION: FRINT32X
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '1x' UNDEFINED;
			integer intsize = if op<1> == '0' then 32 else 64;
			FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT32Z_advsimd
	TYPE: instruction
	XML: frint32z_advsimd.xml
	CLASS: simd_single_and_double
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|1111|op=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT32Z_asimdmisc_R
			OPERATION: FRINT32Z
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer intsize = if op == '0' then 32 else 64;
			FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT32Z_float
	TYPE: instruction
	XML: frint32z_float.xml
	CLASS: float
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: M=0|0|S=0|11110|ftype=0x|1|0100|op=00|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT32Z_S_floatdp1
			OPERATION: FRINT32Z
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINT32Z_D_floatdp1
			OPERATION: FRINT32Z
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '1x' UNDEFINED;
			integer intsize = if op<1> == '0' then 32 else 64;
			FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT64X_advsimd
	TYPE: instruction
	XML: frint64x_advsimd.xml
	CLASS: simd_single_and_double
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|10000|1111|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT64X_asimdmisc_R
			OPERATION: FRINT64X
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer intsize = if op == '0' then 32 else 64;
			FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT64X_float
	TYPE: instruction
	XML: frint64x_float.xml
	CLASS: float
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: M=0|0|S=0|11110|ftype=0x|1|0100|op=11|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT64X_S_floatdp1
			OPERATION: FRINT64X
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINT64X_D_floatdp1
			OPERATION: FRINT64X
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '1x' UNDEFINED;
			integer intsize = if op<1> == '0' then 32 else 64;
			FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT64Z_advsimd
	TYPE: instruction
	XML: frint64z_advsimd.xml
	CLASS: simd_single_and_double
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|1111|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT64Z_asimdmisc_R
			OPERATION: FRINT64Z
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer intsize = if op == '0' then 32 else 64;
			FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINT64Z_float
	TYPE: instruction
	XML: frint64z_float.xml
	CLASS: float
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FRINTTS
		FIELDS32: M=0|0|S=0|11110|ftype=0x|1|0100|op=10|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINT64Z_S_floatdp1
			OPERATION: FRINT64Z
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINT64Z_D_floatdp1
			OPERATION: FRINT64Z
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			if !HaveFrintExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '1x' UNDEFINED;
			integer intsize = if op<1> == '0' then 32 else 64;
			FPRounding rounding = if op<0> == '0' then FPRounding_ZERO else FPRoundingMode(FPCR[]);

IFORM: FRINTA_advsimd
	TYPE: instruction
	XML: frinta_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=0|111100|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTA_asimdmiscfp16_R
			OPERATION: FRINTA
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=0|sz=x|10000|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTA_asimdmisc_R
			OPERATION: FRINTA
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTA_float
	TYPE: instruction
	XML: frinta_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=100|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTA_H_floatdp1
			OPERATION: FRINTA
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTA_S_floatdp1
			OPERATION: FRINTA
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTA_D_floatdp1
			OPERATION: FRINTA
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTI_advsimd
	TYPE: instruction
	XML: frinti_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=1|111100|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTI_asimdmiscfp16_R
			OPERATION: FRINTI
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=1|sz=x|10000|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTI_asimdmisc_R
			OPERATION: FRINTI
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTI_float
	TYPE: instruction
	XML: frinti_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=111|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTI_H_floatdp1
			OPERATION: FRINTI
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTI_S_floatdp1
			OPERATION: FRINTI
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTI_D_floatdp1
			OPERATION: FRINTI
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTM_advsimd
	TYPE: instruction
	XML: frintm_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=0|111100|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTM_asimdmiscfp16_R
			OPERATION: FRINTM
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=0|sz=x|10000|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTM_asimdmisc_R
			OPERATION: FRINTM
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTM_float
	TYPE: instruction
	XML: frintm_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=010|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTM_H_floatdp1
			OPERATION: FRINTM
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTM_S_floatdp1
			OPERATION: FRINTM
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTM_D_floatdp1
			OPERATION: FRINTM
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTN_advsimd
	TYPE: instruction
	XML: frintn_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=0|111100|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTN_asimdmiscfp16_R
			OPERATION: FRINTN
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=0|sz=x|10000|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTN_asimdmisc_R
			OPERATION: FRINTN
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTN_float
	TYPE: instruction
	XML: frintn_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=000|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTN_H_floatdp1
			OPERATION: FRINTN
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTN_S_floatdp1
			OPERATION: FRINTN
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTN_D_floatdp1
			OPERATION: FRINTN
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTP_advsimd
	TYPE: instruction
	XML: frintp_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=1|111100|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTP_asimdmiscfp16_R
			OPERATION: FRINTP
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=1|sz=x|10000|1100|o1=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTP_asimdmisc_R
			OPERATION: FRINTP
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTP_float
	TYPE: instruction
	XML: frintp_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=001|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTP_H_floatdp1
			OPERATION: FRINTP
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTP_S_floatdp1
			OPERATION: FRINTP
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTP_D_floatdp1
			OPERATION: FRINTP
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTX_advsimd
	TYPE: instruction
	XML: frintx_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|o2=0|111100|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTX_asimdmiscfp16_R
			OPERATION: FRINTX
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|o2=0|sz=x|10000|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTX_asimdmisc_R
			OPERATION: FRINTX
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTX_float
	TYPE: instruction
	XML: frintx_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=110|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTX_H_floatdp1
			OPERATION: FRINTX
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTX_S_floatdp1
			OPERATION: FRINTX
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTX_D_floatdp1
			OPERATION: FRINTX
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTZ_advsimd
	TYPE: instruction
	XML: frintz_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|o2=1|111100|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTZ_asimdmiscfp16_R
			OPERATION: FRINTZ
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|o2=1|sz=x|10000|1100|o1=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTZ_asimdmisc_R
			OPERATION: FRINTZ
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean exact = FALSE;
			FPRounding rounding;
			case U:o1:o2 of
			    when '0xx' rounding = FPDecodeRounding(o1:o2);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRINTZ_float
	TYPE: instruction
	XML: frintz_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|001|rmode=011|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRINTZ_H_floatdp1
			OPERATION: FRINTZ
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FRINTZ_S_floatdp1
			OPERATION: FRINTZ
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FRINTZ_D_floatdp1
			OPERATION: FRINTZ
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean exact = FALSE;
			FPRounding rounding;
			case rmode of
			    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
			    when '100' rounding = FPRounding_TIEAWAY;
			    when '101' UNDEFINED;
			    when '110' rounding = FPRoundingMode(FPCR[]); exact = TRUE;
			    when '111' rounding = FPRoundingMode(FPCR[]);

IFORM: FRSQRTE_advsimd
	TYPE: instruction
	XML: frsqrte_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|a=1|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTE_asisdmiscfp16_R
			OPERATION: FRSQRTE
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|1|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTE_asisdmisc_R
			OPERATION: FRSQRTE
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTE_asimdmiscfp16_R
			OPERATION: FRSQRTE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTE_asimdmisc_R
			OPERATION: FRSQRTE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FRSQRTS_advsimd
	TYPE: instruction
	XML: frsqrts_advsimd.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=1|10|Rm=xxxxx|00|opcode=111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTS_asisdsamefp16_only
			OPERATION: FRSQRTS
			SYNTAX: <Hd>,<Hn>,<Hm>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|1|sz=x|1|Rm=xxxxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTS_asisdsame_only
			OPERATION: FRSQRTS
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|10|Rm=xxxxx|00|opcode=111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTS_asimdsamefp16_only
			OPERATION: FRSQRTS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|1|Rm=xxxxx|opcode=11111|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FRSQRTS_asimdsame_only
			OPERATION: FRSQRTS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FSQRT_advsimd
	TYPE: instruction
	XML: fsqrt_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=1|111100|opcode=11111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSQRT_asimdmiscfp16_R
			OPERATION: FSQRT
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|opcode=11111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSQRT_asimdmisc_R
			OPERATION: FSQRT
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: FSQRT_float
	TYPE: instruction
	XML: fsqrt_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|0000|opc=11|10000|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSQRT_H_floatdp1
			OPERATION: FSQRT
			SYNTAX: <Hd>,<Hn>
			BITDIFFS: ftype == '11'
		ENCODING: FSQRT_S_floatdp1
			OPERATION: FSQRT
			SYNTAX: <Sd>,<Sn>
			BITDIFFS: ftype == '00'
		ENCODING: FSQRT_D_floatdp1
			OPERATION: FSQRT
			SYNTAX: <Dd>,<Dn>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			FPUnaryOp fpop;
			case opc of
			    when '00' fpop = FPUnaryOp_MOV;
			    when '01' fpop = FPUnaryOp_ABS;
			    when '10' fpop = FPUnaryOp_NEG;
			    when '11' fpop = FPUnaryOp_SQRT;

IFORM: FSUB_advsimd
	TYPE: instruction
	XML: fsub_advsimd.xml
	CLASS: half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=1|10|Rm=xxxxx|00|opcode=010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSUB_asimdsamefp16_only
			OPERATION: FSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean abs = (U == '1');
	CLASS: single_and_double
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|1|Rm=xxxxx|opcode=11010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSUB_asimdsame_only
			OPERATION: FSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean abs = (U == '1');

IFORM: FSUB_float
	TYPE: instruction
	XML: fsub_float.xml
	CLASS: float
		FIELDS32: M=0|0|S=0|11110|ftype=xx|1|Rm=xxxxx|001|op=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: FSUB_H_floatdp2
			OPERATION: FSUB
			SYNTAX: <Hd>,<Hn>,<Hm>
			BITDIFFS: ftype == '11'
		ENCODING: FSUB_S_floatdp2
			OPERATION: FSUB
			SYNTAX: <Sd>,<Sn>,<Sm>
			BITDIFFS: ftype == '00'
		ENCODING: FSUB_D_floatdp2
			OPERATION: FSUB
			SYNTAX: <Dd>,<Dn>,<Dm>
			BITDIFFS: ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize;
			case ftype of
			    when '00' esize = 32;
			    when '01' esize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            esize = 16;
			        else
			            UNDEFINED;
			boolean sub_op = (op == '1');

IFORM: GMI
	TYPE: instruction
	XML: gmi.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|0|S=0|11010110|Xm=xxxxx|opcode=000101|Xn=xxxxx|Xd=xxxxx
		ENCODING: GMI_64G_dp_2src
			OPERATION: GMI
			SYNTAX: <Xd>,<Xn|SP>,<Xm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			integer m = UInt(Xm);

IFORM: HINT
	TYPE: instruction
	XML: hint.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=xxxx|op2=xxx|Rt=11111
		ENCODING: HINT_HM_hints
			OPERATION: HINT
			SYNTAX: #<imm>
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: HLT
	TYPE: instruction
	XML: hlt.xml
	CLASS: system
		FIELDS32: 11010100|opc=010|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=00
		ENCODING: HLT_EX_exception
			OPERATION: HLT
			SYNTAX: #<imm>
		DECODE_PCODE:
			if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
			if HaveBTIExt() then
			    SetBTypeCompatible(TRUE);

IFORM: HVC
	TYPE: instruction
	XML: hvc.xml
	CLASS: system
		FIELDS32: 11010100|opc=000|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=10
		ENCODING: HVC_EX_exception
			OPERATION: HVC
			SYNTAX: #<imm>

IFORM: IC_SYS
	TYPE: alias
	XML: ic_sys.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=01|op1=xxx|CRn=0111|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: IC_SYS_CR_systeminstrs
			OPERATION: IC
			SYNTAX: <ic_op>{,<Xt>}

IFORM: INS_advsimd_elt
	TYPE: instruction
	XML: ins_advsimd_elt.xml
	ALIAS: MOV_INS_advsimd_elt
		Unconditionally
	CLASS: advsimd
		FIELDS32: 0|Q=1|op=1|01110000|imm5=xxxxx|0|imm4=xxxx|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: INS_asimdins_IV_v
			OPERATION: INS
			SYNTAX: <Vd>.<Ts>[<index1>],<Vn>.<Ts>[<index2>]
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size = LowestSetBit(imm5);
			if size > 3 then UNDEFINED;
			integer dst_index = UInt(imm5<4:size+1>);
			integer src_index = UInt(imm4<3:size>);
			integer idxdsize = if imm4<3> == '1' then 128 else 64;
			// imm4<size-1:0> is IGNORED
			integer esize = 8 << size;

IFORM: INS_advsimd_gen
	TYPE: instruction
	XML: ins_advsimd_gen.xml
	ALIAS: MOV_INS_advsimd_gen
		Unconditionally
	CLASS: advsimd
		FIELDS32: 0|Q=1|op=0|01110000|imm5=xxxxx|0|imm4=0011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: INS_asimdins_IR_r
			OPERATION: INS
			SYNTAX: <Vd>.<Ts>[<index>],<R><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size = LowestSetBit(imm5);
			if size > 3 then UNDEFINED;
			integer index = UInt(imm5<4:size+1>);
			integer esize = 8 << size;
			integer datasize = 128;

IFORM: IRG
	TYPE: instruction
	XML: irg.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|0|S=0|11010110|Xm=xxxxx|opcode=000100|Xn=xxxxx|Xd=xxxxx
		ENCODING: IRG_64I_dp_2src
			OPERATION: IRG
			SYNTAX: <Xd|SP>,<Xn|SP>{,<Xm>}
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			integer m = UInt(Xm);

IFORM: ISB
	TYPE: instruction
	XML: isb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=xxxx|1|opc=10|Rt=11111
		ENCODING: ISB_BI_barriers
			OPERATION: ISB
			SYNTAX: {<option>|#<imm>}

IFORM: LD1R_advsimd
	TYPE: instruction
	XML: ld1r_advsimd.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=0|00000|opcode=110|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1R_asisdlso_R1
			OPERATION: LD1R
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=0|Rm=xxxxx|opcode=110|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1R_asisdlsop_R1_i
			OPERATION: LD1R
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD1R_asisdlsop_RX1_r
			OPERATION: LD1R
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD1_advsimd_mult
	TYPE: instruction
	XML: ld1_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=1|000000|opcode=xx1x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1_asisdlse_R1_1v
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0111'
		ENCODING: LD1_asisdlse_R2_2v
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '1010'
		ENCODING: LD1_asisdlse_R3_3v
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0110'
		ENCODING: LD1_asisdlse_R4_4v
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0010'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=1|0|Rm=xxxxx|opcode=xx1x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1_asisdlsep_I1_i1
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0111'
		ENCODING: LD1_asisdlsep_R1_r1
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0111'
		ENCODING: LD1_asisdlsep_I2_i2
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '1010'
		ENCODING: LD1_asisdlsep_R2_r2
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '1010'
		ENCODING: LD1_asisdlsep_I3_i3
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0110'
		ENCODING: LD1_asisdlsep_R3_r3
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0110'
		ENCODING: LD1_asisdlsep_I4_i4
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0010'
		ENCODING: LD1_asisdlsep_R4_r4
			OPERATION: LD1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0010'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: LD1_advsimd_sngl
	TYPE: instruction
	XML: ld1_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=0|00000|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1_asisdlso_B1_1b
			OPERATION: LD1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '000'
		ENCODING: LD1_asisdlso_H1_1h
			OPERATION: LD1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '010' && size == 'x0'
		ENCODING: LD1_asisdlso_S1_1s
			OPERATION: LD1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && size == '00'
			LABEL: 32-bit
		ENCODING: LD1_asisdlso_D1_1d
			OPERATION: LD1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=0|Rm=xxxxx|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD1_asisdlsop_B1_i1b
			OPERATION: LD1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>], #1
			BITDIFFS: Rm == '11111' && opcode == '000'
		ENCODING: LD1_asisdlsop_BX1_r1b
			OPERATION: LD1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '000'
		ENCODING: LD1_asisdlsop_H1_i1h
			OPERATION: LD1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>], #2
			BITDIFFS: Rm == '11111' && opcode == '010' && size == 'x0'
		ENCODING: LD1_asisdlsop_HX1_r1h
			OPERATION: LD1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '010' && size == 'x0'
		ENCODING: LD1_asisdlsop_S1_i1s
			OPERATION: LD1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '100' && size == '00'
		ENCODING: LD1_asisdlsop_SX1_r1s
			OPERATION: LD1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && size == '00'
		ENCODING: LD1_asisdlsop_D1_i1d
			OPERATION: LD1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '100' && S == '0' && size == '01'
		ENCODING: LD1_asisdlsop_DX1_r1d
			OPERATION: LD1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD2R_advsimd
	TYPE: instruction
	XML: ld2r_advsimd.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=1|00000|opcode=110|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2R_asisdlso_R2
			OPERATION: LD2R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=1|Rm=xxxxx|opcode=110|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2R_asisdlsop_R2_i
			OPERATION: LD2R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD2R_asisdlsop_RX2_r
			OPERATION: LD2R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD2_advsimd_mult
	TYPE: instruction
	XML: ld2_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=1|000000|opcode=1000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2_asisdlse_R2
			OPERATION: LD2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=1|0|Rm=xxxxx|opcode=1000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2_asisdlsep_I2_i
			OPERATION: LD2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD2_asisdlsep_R2_r
			OPERATION: LD2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: LD2_advsimd_sngl
	TYPE: instruction
	XML: ld2_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=1|00000|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2_asisdlso_B2_2b
			OPERATION: LD2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '000'
		ENCODING: LD2_asisdlso_H2_2h
			OPERATION: LD2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '010' && size == 'x0'
		ENCODING: LD2_asisdlso_S2_2s
			OPERATION: LD2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && size == '00'
			LABEL: 32-bit
		ENCODING: LD2_asisdlso_D2_2d
			OPERATION: LD2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=1|Rm=xxxxx|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD2_asisdlsop_B2_i2b
			OPERATION: LD2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>], #2
			BITDIFFS: Rm == '11111' && opcode == '000'
		ENCODING: LD2_asisdlsop_BX2_r2b
			OPERATION: LD2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '000'
		ENCODING: LD2_asisdlsop_H2_i2h
			OPERATION: LD2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '010' && size == 'x0'
		ENCODING: LD2_asisdlsop_HX2_r2h
			OPERATION: LD2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '010' && size == 'x0'
		ENCODING: LD2_asisdlsop_S2_i2s
			OPERATION: LD2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '100' && size == '00'
		ENCODING: LD2_asisdlsop_SX2_r2s
			OPERATION: LD2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && size == '00'
		ENCODING: LD2_asisdlsop_D2_i2d
			OPERATION: LD2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>], #16
			BITDIFFS: Rm == '11111' && opcode == '100' && S == '0' && size == '01'
		ENCODING: LD2_asisdlsop_DX2_r2d
			OPERATION: LD2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD3R_advsimd
	TYPE: instruction
	XML: ld3r_advsimd.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=0|00000|opcode=111|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3R_asisdlso_R3
			OPERATION: LD3R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=0|Rm=xxxxx|opcode=111|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3R_asisdlsop_R3_i
			OPERATION: LD3R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD3R_asisdlsop_RX3_r
			OPERATION: LD3R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD3_advsimd_mult
	TYPE: instruction
	XML: ld3_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=1|000000|opcode=0100|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3_asisdlse_R3
			OPERATION: LD3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=1|0|Rm=xxxxx|opcode=0100|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3_asisdlsep_I3_i
			OPERATION: LD3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD3_asisdlsep_R3_r
			OPERATION: LD3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: LD3_advsimd_sngl
	TYPE: instruction
	XML: ld3_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=0|00000|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3_asisdlso_B3_3b
			OPERATION: LD3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '001'
		ENCODING: LD3_asisdlso_H3_3h
			OPERATION: LD3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '011' && size == 'x0'
		ENCODING: LD3_asisdlso_S3_3s
			OPERATION: LD3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && size == '00'
			LABEL: 32-bit
		ENCODING: LD3_asisdlso_D3_3d
			OPERATION: LD3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=0|Rm=xxxxx|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD3_asisdlsop_B3_i3b
			OPERATION: LD3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>], #3
			BITDIFFS: Rm == '11111' && opcode == '001'
		ENCODING: LD3_asisdlsop_BX3_r3b
			OPERATION: LD3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '001'
		ENCODING: LD3_asisdlsop_H3_i3h
			OPERATION: LD3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>], #6
			BITDIFFS: Rm == '11111' && opcode == '011' && size == 'x0'
		ENCODING: LD3_asisdlsop_HX3_r3h
			OPERATION: LD3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '011' && size == 'x0'
		ENCODING: LD3_asisdlsop_S3_i3s
			OPERATION: LD3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>], #12
			BITDIFFS: Rm == '11111' && opcode == '101' && size == '00'
		ENCODING: LD3_asisdlsop_SX3_r3s
			OPERATION: LD3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && size == '00'
		ENCODING: LD3_asisdlsop_D3_i3d
			OPERATION: LD3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>], #24
			BITDIFFS: Rm == '11111' && opcode == '101' && S == '0' && size == '01'
		ENCODING: LD3_asisdlsop_DX3_r3d
			OPERATION: LD3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD4R_advsimd
	TYPE: instruction
	XML: ld4r_advsimd.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=1|00000|opcode=111|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4R_asisdlso_R4
			OPERATION: LD4R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=1|Rm=xxxxx|opcode=111|S=0|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4R_asisdlsop_R4_i
			OPERATION: LD4R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD4R_asisdlsop_RX4_r
			OPERATION: LD4R
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD4_advsimd_mult
	TYPE: instruction
	XML: ld4_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=1|000000|opcode=0000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4_asisdlse_R4
			OPERATION: LD4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=1|0|Rm=xxxxx|opcode=0000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4_asisdlsep_I4_i
			OPERATION: LD4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: LD4_asisdlsep_R4_r
			OPERATION: LD4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: LD4_advsimd_sngl
	TYPE: instruction
	XML: ld4_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=1|R=1|00000|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4_asisdlso_B4_4b
			OPERATION: LD4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '001'
		ENCODING: LD4_asisdlso_H4_4h
			OPERATION: LD4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '011' && size == 'x0'
		ENCODING: LD4_asisdlso_S4_4s
			OPERATION: LD4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && size == '00'
			LABEL: 32-bit
		ENCODING: LD4_asisdlso_D4_4d
			OPERATION: LD4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=1|R=1|Rm=xxxxx|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD4_asisdlsop_B4_i4b
			OPERATION: LD4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '001'
		ENCODING: LD4_asisdlsop_BX4_r4b
			OPERATION: LD4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '001'
		ENCODING: LD4_asisdlsop_H4_i4h
			OPERATION: LD4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '011' && size == 'x0'
		ENCODING: LD4_asisdlsop_HX4_r4h
			OPERATION: LD4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '011' && size == 'x0'
		ENCODING: LD4_asisdlsop_S4_i4s
			OPERATION: LD4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>], #16
			BITDIFFS: Rm == '11111' && opcode == '101' && size == '00'
		ENCODING: LD4_asisdlsop_SX4_r4s
			OPERATION: LD4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && size == '00'
		ENCODING: LD4_asisdlsop_D4_i4d
			OPERATION: LD4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>], #32
			BITDIFFS: Rm == '11111' && opcode == '101' && S == '0' && size == '01'
		ENCODING: LD4_asisdlsop_DX4_r4d
			OPERATION: LD4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: LD64B
	TYPE: instruction
	XML: ld64b.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_LS64
		FIELDS32: size=11|111|V=0|00|A=0|R=0|1|Rs=11111|o3=1|opc=101|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LD64B_64L_memop
			OPERATION: LD64B
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			if !HaveFeatLS64() then UNDEFINED;
			if Rt<4:3> == '11' || Rt<0> == '1' then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			boolean tag_checked = n != 31;

IFORM: LDADD
	TYPE: instruction
	XML: ldadd.xml
	ALIAS: STADD_LDADD
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDADD_32_memop
			OPERATION: LDADD
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDADDA_32_memop
			OPERATION: LDADDA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDADDAL_32_memop
			OPERATION: LDADDAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDADDL_32_memop
			OPERATION: LDADDL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDADD_64_memop
			OPERATION: LDADD
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDADDA_64_memop
			OPERATION: LDADDA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDADDAL_64_memop
			OPERATION: LDADDAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDADDL_64_memop
			OPERATION: LDADDL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDADDB
	TYPE: instruction
	XML: ldaddb.xml
	ALIAS: STADDB_LDADDB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDADDAB_32_memop
			OPERATION: LDADDAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDADDALB_32_memop
			OPERATION: LDADDALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDADDB_32_memop
			OPERATION: LDADDB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDADDLB_32_memop
			OPERATION: LDADDLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDADDH
	TYPE: instruction
	XML: ldaddh.xml
	ALIAS: STADDH_LDADDH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDADDAH_32_memop
			OPERATION: LDADDAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDADDALH_32_memop
			OPERATION: LDADDALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDADDH_32_memop
			OPERATION: LDADDH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDADDLH_32_memop
			OPERATION: LDADDLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDAPR
	TYPE: instruction
	XML: ldapr.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_LRCPC
		FIELDS32: size=1x|111|V=0|00|A=1|R=0|1|Rs=(1)(1)(1)(1)(1)|o3=1|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPR_32L_memop
			OPERATION: LDAPR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDAPR_64L_memop
			OPERATION: LDAPR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = AccType_ORDERED;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDAPRB
	TYPE: instruction
	XML: ldaprb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_LRCPC
		FIELDS32: size=00|111|V=0|00|A=1|R=0|1|Rs=(1)(1)(1)(1)(1)|o3=1|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPRB_32L_memop
			OPERATION: LDAPRB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = AccType_ORDERED;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDAPRH
	TYPE: instruction
	XML: ldaprh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_LRCPC
		FIELDS32: size=01|111|V=0|00|A=1|R=0|1|Rs=(1)(1)(1)(1)(1)|o3=1|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPRH_32L_memop
			OPERATION: LDAPRH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = AccType_ORDERED;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDAPURB
	TYPE: instruction
	XML: ldapurb.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=00|011001|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPURB_32_ldapstl_unscaled
			OPERATION: LDAPURB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAPURH
	TYPE: instruction
	XML: ldapurh.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=01|011001|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPURH_32_ldapstl_unscaled
			OPERATION: LDAPURH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAPURSB
	TYPE: instruction
	XML: ldapursb.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=00|011001|opc=1x|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPURSB_32_ldapstl_unscaled
			OPERATION: LDAPURSB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDAPURSB_64_ldapstl_unscaled
			OPERATION: LDAPURSB
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAPURSH
	TYPE: instruction
	XML: ldapursh.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=01|011001|opc=1x|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPURSH_32_ldapstl_unscaled
			OPERATION: LDAPURSH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDAPURSH_64_ldapstl_unscaled
			OPERATION: LDAPURSH
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAPURSW
	TYPE: instruction
	XML: ldapursw.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=10|011001|opc=10|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPURSW_64_ldapstl_unscaled
			OPERATION: LDAPURSW
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAPUR_gen
	TYPE: instruction
	XML: ldapur_gen.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=1x|011001|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAPUR_32_ldapstl_unscaled
			OPERATION: LDAPUR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDAPUR_64_ldapstl_unscaled
			OPERATION: LDAPUR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDAR
	TYPE: instruction
	XML: ldar.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAR_LR32_ldstexcl
			OPERATION: LDAR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDAR_LR64_ldstexcl
			OPERATION: LDAR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDARB
	TYPE: instruction
	XML: ldarb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDARB_LR32_ldstexcl
			OPERATION: LDARB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDARH
	TYPE: instruction
	XML: ldarh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDARH_LR32_ldstexcl
			OPERATION: LDARH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDAXP
	TYPE: instruction
	XML: ldaxp.xml
	CLASS: base_register
		FIELDS32: 1|sz=x|001000|o2=0|L=1|o1=1|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAXP_LP32_ldstexcl
			OPERATION: LDAXP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0'
			LABEL: 32-bit
		ENCODING: LDAXP_LP64_ldstexcl
			OPERATION: LDAXP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = TRUE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 32 << UInt(sz);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDAXR
	TYPE: instruction
	XML: ldaxr.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAXR_LR32_ldstexcl
			OPERATION: LDAXR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDAXR_LR64_ldstexcl
			OPERATION: LDAXR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDAXRB
	TYPE: instruction
	XML: ldaxrb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAXRB_LR32_ldstexcl
			OPERATION: LDAXRB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDAXRH
	TYPE: instruction
	XML: ldaxrh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDAXRH_LR32_ldstexcl
			OPERATION: LDAXRH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDCLR
	TYPE: instruction
	XML: ldclr.xml
	ALIAS: STCLR_LDCLR
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDCLR_32_memop
			OPERATION: LDCLR
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDCLRA_32_memop
			OPERATION: LDCLRA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDCLRAL_32_memop
			OPERATION: LDCLRAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDCLRL_32_memop
			OPERATION: LDCLRL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDCLR_64_memop
			OPERATION: LDCLR
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDCLRA_64_memop
			OPERATION: LDCLRA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDCLRAL_64_memop
			OPERATION: LDCLRAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDCLRL_64_memop
			OPERATION: LDCLRL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDCLRB
	TYPE: instruction
	XML: ldclrb.xml
	ALIAS: STCLRB_LDCLRB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDCLRAB_32_memop
			OPERATION: LDCLRAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDCLRALB_32_memop
			OPERATION: LDCLRALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDCLRB_32_memop
			OPERATION: LDCLRB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDCLRLB_32_memop
			OPERATION: LDCLRLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDCLRH
	TYPE: instruction
	XML: ldclrh.xml
	ALIAS: STCLRH_LDCLRH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDCLRAH_32_memop
			OPERATION: LDCLRAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDCLRALH_32_memop
			OPERATION: LDCLRALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDCLRH_32_memop
			OPERATION: LDCLRH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDCLRLH_32_memop
			OPERATION: LDCLRLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDEOR
	TYPE: instruction
	XML: ldeor.xml
	ALIAS: STEOR_LDEOR
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDEOR_32_memop
			OPERATION: LDEOR
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDEORA_32_memop
			OPERATION: LDEORA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDEORAL_32_memop
			OPERATION: LDEORAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDEORL_32_memop
			OPERATION: LDEORL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDEOR_64_memop
			OPERATION: LDEOR
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDEORA_64_memop
			OPERATION: LDEORA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDEORAL_64_memop
			OPERATION: LDEORAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDEORL_64_memop
			OPERATION: LDEORL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDEORB
	TYPE: instruction
	XML: ldeorb.xml
	ALIAS: STEORB_LDEORB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDEORAB_32_memop
			OPERATION: LDEORAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDEORALB_32_memop
			OPERATION: LDEORALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDEORB_32_memop
			OPERATION: LDEORB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDEORLB_32_memop
			OPERATION: LDEORLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDEORH
	TYPE: instruction
	XML: ldeorh.xml
	ALIAS: STEORH_LDEORH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDEORAH_32_memop
			OPERATION: LDEORAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDEORALH_32_memop
			OPERATION: LDEORALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDEORH_32_memop
			OPERATION: LDEORH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDEORLH_32_memop
			OPERATION: LDEORLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDG
	TYPE: instruction
	XML: ldg.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=01|1|imm9=xxxxxxxxx|op2=00|Xn=xxxxx|Xt=xxxxx
		ENCODING: LDG_64Loffset_ldsttags
			OPERATION: LDG
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer t = UInt(Xt);
			integer n = UInt(Xn);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);

IFORM: LDGM
	TYPE: instruction
	XML: ldgm.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE2
		FIELDS32: 11011001|opc=11|1|imm9=000000000|op2=00|Xn=xxxxx|Xt=xxxxx
		ENCODING: LDGM_64bulk_ldsttags
			OPERATION: LDGM
			SYNTAX: <Xt>, [<Xn|SP>]
		DECODE_PCODE:
			if !HaveMTE2Ext() then UNDEFINED;
			integer t = UInt(Xt);
			integer n = UInt(Xn);

IFORM: LDLAR
	TYPE: instruction
	XML: ldlar.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=1x|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDLAR_LR32_ldstexcl
			OPERATION: LDLAR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDLAR_LR64_ldstexcl
			OPERATION: LDLAR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDLARB
	TYPE: instruction
	XML: ldlarb.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=00|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDLARB_LR32_ldstexcl
			OPERATION: LDLARB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDLARH
	TYPE: instruction
	XML: ldlarh.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=01|001000|o2=1|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDLARH_LR32_ldstexcl
			OPERATION: LDLARH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: LDNP_fpsimd
	TYPE: instruction
	XML: ldnp_fpsimd.xml
	CLASS: signed_scaled_offset
		FIELDS32: opc=xx|101|V=1|000|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDNP_S_ldstnapair_offs
			OPERATION: LDNP
			SYNTAX: <St1>,<St2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDNP_D_ldstnapair_offs
			OPERATION: LDNP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: LDNP_Q_ldstnapair_offs
			OPERATION: LDNP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_VECSTREAM;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc == '11' then UNDEFINED;
		integer scale = 2 + UInt(opc);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDNP_gen
	TYPE: instruction
	XML: ldnp_gen.xml
	CLASS: signed_scaled_offset
		FIELDS32: opc=x0|101|V=0|000|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDNP_32_ldstnapair_offs
			OPERATION: LDNP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDNP_64_ldstnapair_offs
			OPERATION: LDNP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_STREAM;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc<0> == '1' then UNDEFINED;
		integer scale = 2 + UInt(opc<1>);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDPSW
	TYPE: instruction
	XML: ldpsw.xml
	CLASS: post_indexed
		FIELDS32: opc=01|101|V=0|001|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDPSW_64_ldstpair_post
			OPERATION: LDPSW
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>], #<imm>
	CLASS: pre_indexed
		FIELDS32: opc=01|101|V=0|011|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDPSW_64_ldstpair_pre
			OPERATION: LDPSW
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>, #<imm>]!
	CLASS: signed_scaled_offset
		FIELDS32: opc=01|101|V=0|010|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDPSW_64_ldstpair_off
			OPERATION: LDPSW
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_NORMAL;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if L:opc<0> == '01' || opc == '11' then UNDEFINED;
		boolean signed = (opc<0> != '0');
		integer scale = 2 + UInt(opc<1>);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		boolean wb_unknown = FALSE;
		if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDP_fpsimd
	TYPE: instruction
	XML: ldp_fpsimd.xml
	CLASS: post_indexed
		FIELDS32: opc=xx|101|V=1|001|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_S_ldstpair_post
			OPERATION: LDP
			SYNTAX: <St1>,<St2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_D_ldstpair_post
			OPERATION: LDP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: LDP_Q_ldstpair_post
			OPERATION: LDP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '10'
	CLASS: pre_indexed
		FIELDS32: opc=xx|101|V=1|011|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_S_ldstpair_pre
			OPERATION: LDP
			SYNTAX: <St1>,<St2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_D_ldstpair_pre
			OPERATION: LDP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: LDP_Q_ldstpair_pre
			OPERATION: LDP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '10'
	CLASS: signed_scaled_offset
		FIELDS32: opc=xx|101|V=1|010|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_S_ldstpair_off
			OPERATION: LDP
			SYNTAX: <St1>,<St2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_D_ldstpair_off
			OPERATION: LDP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: LDP_Q_ldstpair_off
			OPERATION: LDP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_VEC;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc == '11' then UNDEFINED;
		integer scale = 2 + UInt(opc);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDP_gen
	TYPE: instruction
	XML: ldp_gen.xml
	CLASS: post_indexed
		FIELDS32: opc=x0|101|V=0|001|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_32_ldstpair_post
			OPERATION: LDP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_64_ldstpair_post
			OPERATION: LDP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	CLASS: pre_indexed
		FIELDS32: opc=x0|101|V=0|011|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_32_ldstpair_pre
			OPERATION: LDP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_64_ldstpair_pre
			OPERATION: LDP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	CLASS: signed_scaled_offset
		FIELDS32: opc=x0|101|V=0|010|L=1|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDP_32_ldstpair_off
			OPERATION: LDP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDP_64_ldstpair_off
			OPERATION: LDP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_NORMAL;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if L:opc<0> == '01' || opc == '11' then UNDEFINED;
		boolean signed = (opc<0> != '0');
		integer scale = 2 + UInt(opc<1>);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		boolean wb_unknown = FALSE;
		if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRA
	TYPE: instruction
	XML: ldra.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: size=11|111|V=0|00|M=x|S=x|1|imm9=xxxxxxxxx|W=x|1|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRAA_64_ldst_pac
			OPERATION: LDRAA
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: M == '0' && W == '0'
		ENCODING: LDRAA_64W_ldst_pac
			OPERATION: LDRAA
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]!
			BITDIFFS: M == '0' && W == '1'
		ENCODING: LDRAB_64_ldst_pac
			OPERATION: LDRAB
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: M == '1' && W == '0'
		ENCODING: LDRAB_64W_ldst_pac
			OPERATION: LDRAB
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]!
			BITDIFFS: M == '1' && W == '1'
		DECODE_PCODE:
			if !HavePACExt() || size != '11' then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			boolean wback = (W == '1');
			boolean use_key_a = (M == '0');
			bits(10) S10 = S:imm9;
			integer scale = 3;
			bits(64) offset = LSL(SignExtend(S10, 64), scale);
			boolean tag_checked = wback || n != 31;

IFORM: LDRB_imm
	TYPE: instruction
	XML: ldrb_imm.xml
	CLASS: post_indexed
		FIELDS32: size=00|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRB_32_ldst_immpost
			OPERATION: LDRB
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=00|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRB_32_ldst_immpre
			OPERATION: LDRB
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=00|111|V=0|01|opc=01|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRB_32_ldst_pos
			OPERATION: LDRB
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRB_reg
	TYPE: instruction
	XML: ldrb_reg.xml
	CLASS: 32
		FIELDS32: size=00|111|V=0|00|opc=01|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRB_32B_ldst_regoff
			OPERATION: LDRB
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: option != '011'
		ENCODING: LDRB_32BL_ldst_regoff
			OPERATION: LDRB
			SYNTAX: <Wt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: option == '011'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRH_imm
	TYPE: instruction
	XML: ldrh_imm.xml
	CLASS: post_indexed
		FIELDS32: size=01|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRH_32_ldst_immpost
			OPERATION: LDRH
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=01|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRH_32_ldst_immpre
			OPERATION: LDRH
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=01|111|V=0|01|opc=01|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRH_32_ldst_pos
			OPERATION: LDRH
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRH_reg
	TYPE: instruction
	XML: ldrh_reg.xml
	CLASS: 32
		FIELDS32: size=01|111|V=0|00|opc=01|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRH_32_ldst_regoff
			OPERATION: LDRH
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSB_imm
	TYPE: instruction
	XML: ldrsb_imm.xml
	CLASS: post_indexed
		FIELDS32: size=00|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSB_32_ldst_immpost
			OPERATION: LDRSB
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSB_64_ldst_immpost
			OPERATION: LDRSB
			SYNTAX: <Xt>, [<Xn|SP>], #<simm>
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=00|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSB_32_ldst_immpre
			OPERATION: LDRSB
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSB_64_ldst_immpre
			OPERATION: LDRSB
			SYNTAX: <Xt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=00|111|V=0|01|opc=1x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSB_32_ldst_pos
			OPERATION: LDRSB
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSB_64_ldst_pos
			OPERATION: LDRSB
			SYNTAX: <Xt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSB_reg
	TYPE: instruction
	XML: ldrsb_reg.xml
	CLASS: general
		FIELDS32: size=00|111|V=0|00|opc=1x|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSB_32B_ldst_regoff
			OPERATION: LDRSB
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: opc == '11' && option != '011'
		ENCODING: LDRSB_32BL_ldst_regoff
			OPERATION: LDRSB
			SYNTAX: <Wt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: opc == '11' && option == '011'
		ENCODING: LDRSB_64B_ldst_regoff
			OPERATION: LDRSB
			SYNTAX: <Xt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: opc == '10' && option != '011'
		ENCODING: LDRSB_64BL_ldst_regoff
			OPERATION: LDRSB
			SYNTAX: <Xt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: opc == '10' && option == '011'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSH_imm
	TYPE: instruction
	XML: ldrsh_imm.xml
	CLASS: post_indexed
		FIELDS32: size=01|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSH_32_ldst_immpost
			OPERATION: LDRSH
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSH_64_ldst_immpost
			OPERATION: LDRSH
			SYNTAX: <Xt>, [<Xn|SP>], #<simm>
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=01|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSH_32_ldst_immpre
			OPERATION: LDRSH
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSH_64_ldst_immpre
			OPERATION: LDRSH
			SYNTAX: <Xt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=01|111|V=0|01|opc=1x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSH_32_ldst_pos
			OPERATION: LDRSH
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSH_64_ldst_pos
			OPERATION: LDRSH
			SYNTAX: <Xt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSH_reg
	TYPE: instruction
	XML: ldrsh_reg.xml
	CLASS: general
		FIELDS32: size=01|111|V=0|00|opc=1x|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSH_32_ldst_regoff
			OPERATION: LDRSH
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDRSH_64_ldst_regoff
			OPERATION: LDRSH
			SYNTAX: <Xt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSW_imm
	TYPE: instruction
	XML: ldrsw_imm.xml
	CLASS: post_indexed
		FIELDS32: size=10|111|V=0|00|opc=10|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSW_64_ldst_immpost
			OPERATION: LDRSW
			SYNTAX: <Xt>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=10|111|V=0|00|opc=10|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSW_64_ldst_immpre
			OPERATION: LDRSW
			SYNTAX: <Xt>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=10|111|V=0|01|opc=10|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSW_64_ldst_pos
			OPERATION: LDRSW
			SYNTAX: <Xt>, [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDRSW_lit
	TYPE: instruction
	XML: ldrsw_lit.xml
	CLASS: literal
		FIELDS32: opc=10|011|V=0|00|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: LDRSW_64_loadlit
			OPERATION: LDRSW
			SYNTAX: <Xt>,<label>
		DECODE_PCODE:
			integer t = UInt(Rt);
			MemOp memop = MemOp_LOAD;
			boolean signed = FALSE;
			integer size;
			bits(64) offset;
			case opc of
			    when '00'
			        size = 4;
			    when '01'
			        size = 8;
			    when '10'
			        size = 4;
			        signed = TRUE;
			    when '11'
			        memop = MemOp_PREFETCH;
			offset = SignExtend(imm19:'00', 64);
			boolean tag_checked = FALSE;

IFORM: LDRSW_reg
	TYPE: instruction
	XML: ldrsw_reg.xml
	CLASS: 64
		FIELDS32: size=10|111|V=0|00|opc=10|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDRSW_64_ldst_regoff
			OPERATION: LDRSW
			SYNTAX: <Xt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDR_imm_fpsimd
	TYPE: instruction
	XML: ldr_imm_fpsimd.xml
	CLASS: post_indexed
		FIELDS32: size=xx|111|V=1|00|opc=x1|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_B_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Bt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '00' && opc == '01'
		ENCODING: LDR_H_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Ht>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '01' && opc == '01'
		ENCODING: LDR_S_ldst_immpost
			OPERATION: LDR
			SYNTAX: <St>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '10' && opc == '01'
			LABEL: 32-bit
		ENCODING: LDR_D_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Dt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '11' && opc == '01'
			LABEL: 64-bit
		ENCODING: LDR_Q_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Qt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '00' && opc == '11'
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=xx|111|V=1|00|opc=x1|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_B_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Bt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '00' && opc == '01'
		ENCODING: LDR_H_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Ht>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '01' && opc == '01'
		ENCODING: LDR_S_ldst_immpre
			OPERATION: LDR
			SYNTAX: <St>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '10' && opc == '01'
			LABEL: 32-bit
		ENCODING: LDR_D_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Dt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '11' && opc == '01'
			LABEL: 64-bit
		ENCODING: LDR_Q_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Qt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '00' && opc == '11'
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=xx|111|V=1|01|opc=x1|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_B_ldst_pos
			OPERATION: LDR
			SYNTAX: <Bt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '00' && opc == '01'
		ENCODING: LDR_H_ldst_pos
			OPERATION: LDR
			SYNTAX: <Ht>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '01' && opc == '01'
		ENCODING: LDR_S_ldst_pos
			OPERATION: LDR
			SYNTAX: <St>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '10' && opc == '01'
			LABEL: 32-bit
		ENCODING: LDR_D_ldst_pos
			OPERATION: LDR
			SYNTAX: <Dt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '11' && opc == '01'
			LABEL: 64-bit
		ENCODING: LDR_Q_ldst_pos
			OPERATION: LDR
			SYNTAX: <Qt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '00' && opc == '11'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

IFORM: LDR_imm_gen
	TYPE: instruction
	XML: ldr_imm_gen.xml
	CLASS: post_indexed
		FIELDS32: size=1x|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_32_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDR_64_ldst_immpost
			OPERATION: LDR
			SYNTAX: <Xt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=1x|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_32_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDR_64_ldst_immpre
			OPERATION: LDR
			SYNTAX: <Xt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=1x|111|V=0|01|opc=01|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_32_ldst_pos
			OPERATION: LDR
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDR_64_ldst_pos
			OPERATION: LDR
			SYNTAX: <Xt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDR_lit_fpsimd
	TYPE: instruction
	XML: ldr_lit_fpsimd.xml
	CLASS: literal
		FIELDS32: opc=xx|011|V=1|00|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: LDR_S_loadlit
			OPERATION: LDR
			SYNTAX: <St>,<label>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDR_D_loadlit
			OPERATION: LDR
			SYNTAX: <Dt>,<label>
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: LDR_Q_loadlit
			OPERATION: LDR
			SYNTAX: <Qt>,<label>
			BITDIFFS: opc == '10'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer size;
			bits(64) offset;
			case opc of
			    when '00'
			        size = 4;
			    when '01'
			        size = 8;
			    when '10'
			        size = 16;
			    when '11'
			        UNDEFINED;
			offset = SignExtend(imm19:'00', 64);
			boolean tag_checked = FALSE;

IFORM: LDR_lit_gen
	TYPE: instruction
	XML: ldr_lit_gen.xml
	CLASS: literal
		FIELDS32: opc=0x|011|V=0|00|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: LDR_32_loadlit
			OPERATION: LDR
			SYNTAX: <Wt>,<label>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: LDR_64_loadlit
			OPERATION: LDR
			SYNTAX: <Xt>,<label>
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			MemOp memop = MemOp_LOAD;
			boolean signed = FALSE;
			integer size;
			bits(64) offset;
			case opc of
			    when '00'
			        size = 4;
			    when '01'
			        size = 8;
			    when '10'
			        size = 4;
			        signed = TRUE;
			    when '11'
			        memop = MemOp_PREFETCH;
			offset = SignExtend(imm19:'00', 64);
			boolean tag_checked = FALSE;

IFORM: LDR_reg_fpsimd
	TYPE: instruction
	XML: ldr_reg_fpsimd.xml
	CLASS: fpsimd
		FIELDS32: size=xx|111|V=1|00|opc=x1|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_B_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Bt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: size == '00' && opc == '01' && option != '011'
		ENCODING: LDR_BL_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Bt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: size == '00' && opc == '01' && option == '011'
		ENCODING: LDR_H_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Ht>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '01' && opc == '01'
		ENCODING: LDR_S_ldst_regoff
			OPERATION: LDR
			SYNTAX: <St>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '10' && opc == '01'
		ENCODING: LDR_D_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Dt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '11' && opc == '01'
		ENCODING: LDR_Q_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Qt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '00' && opc == '11'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;

IFORM: LDR_reg_gen
	TYPE: instruction
	XML: ldr_reg_gen.xml
	CLASS: general
		FIELDS32: size=1x|111|V=0|00|opc=01|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDR_32_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDR_64_ldst_regoff
			OPERATION: LDR
			SYNTAX: <Xt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDSET
	TYPE: instruction
	XML: ldset.xml
	ALIAS: STSET_LDSET
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSET_32_memop
			OPERATION: LDSET
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDSETA_32_memop
			OPERATION: LDSETA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDSETAL_32_memop
			OPERATION: LDSETAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDSETL_32_memop
			OPERATION: LDSETL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDSET_64_memop
			OPERATION: LDSET
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDSETA_64_memop
			OPERATION: LDSETA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDSETAL_64_memop
			OPERATION: LDSETAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDSETL_64_memop
			OPERATION: LDSETL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSETB
	TYPE: instruction
	XML: ldsetb.xml
	ALIAS: STSETB_LDSETB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSETAB_32_memop
			OPERATION: LDSETAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSETALB_32_memop
			OPERATION: LDSETALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSETB_32_memop
			OPERATION: LDSETB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSETLB_32_memop
			OPERATION: LDSETLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSETH
	TYPE: instruction
	XML: ldseth.xml
	ALIAS: STSETH_LDSETH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSETAH_32_memop
			OPERATION: LDSETAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSETALH_32_memop
			OPERATION: LDSETALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSETH_32_memop
			OPERATION: LDSETH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSETLH_32_memop
			OPERATION: LDSETLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMAX
	TYPE: instruction
	XML: ldsmax.xml
	ALIAS: STSMAX_LDSMAX
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMAX_32_memop
			OPERATION: LDSMAX
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDSMAXA_32_memop
			OPERATION: LDSMAXA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDSMAXAL_32_memop
			OPERATION: LDSMAXAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDSMAXL_32_memop
			OPERATION: LDSMAXL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDSMAX_64_memop
			OPERATION: LDSMAX
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDSMAXA_64_memop
			OPERATION: LDSMAXA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDSMAXAL_64_memop
			OPERATION: LDSMAXAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDSMAXL_64_memop
			OPERATION: LDSMAXL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMAXB
	TYPE: instruction
	XML: ldsmaxb.xml
	ALIAS: STSMAXB_LDSMAXB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMAXAB_32_memop
			OPERATION: LDSMAXAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSMAXALB_32_memop
			OPERATION: LDSMAXALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSMAXB_32_memop
			OPERATION: LDSMAXB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSMAXLB_32_memop
			OPERATION: LDSMAXLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMAXH
	TYPE: instruction
	XML: ldsmaxh.xml
	ALIAS: STSMAXH_LDSMAXH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMAXAH_32_memop
			OPERATION: LDSMAXAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSMAXALH_32_memop
			OPERATION: LDSMAXALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSMAXH_32_memop
			OPERATION: LDSMAXH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSMAXLH_32_memop
			OPERATION: LDSMAXLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMIN
	TYPE: instruction
	XML: ldsmin.xml
	ALIAS: STSMIN_LDSMIN
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMIN_32_memop
			OPERATION: LDSMIN
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDSMINA_32_memop
			OPERATION: LDSMINA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDSMINAL_32_memop
			OPERATION: LDSMINAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDSMINL_32_memop
			OPERATION: LDSMINL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDSMIN_64_memop
			OPERATION: LDSMIN
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDSMINA_64_memop
			OPERATION: LDSMINA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDSMINAL_64_memop
			OPERATION: LDSMINAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDSMINL_64_memop
			OPERATION: LDSMINL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMINB
	TYPE: instruction
	XML: ldsminb.xml
	ALIAS: STSMINB_LDSMINB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMINAB_32_memop
			OPERATION: LDSMINAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSMINALB_32_memop
			OPERATION: LDSMINALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSMINB_32_memop
			OPERATION: LDSMINB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSMINLB_32_memop
			OPERATION: LDSMINLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDSMINH
	TYPE: instruction
	XML: ldsminh.xml
	ALIAS: STSMINH_LDSMINH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDSMINAH_32_memop
			OPERATION: LDSMINAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDSMINALH_32_memop
			OPERATION: LDSMINALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDSMINH_32_memop
			OPERATION: LDSMINH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDSMINLH_32_memop
			OPERATION: LDSMINLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDTR
	TYPE: instruction
	XML: ldtr.xml
	CLASS: base_plus_offset
		FIELDS32: size=1x|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTR_32_ldst_unpriv
			OPERATION: LDTR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDTR_64_ldst_unpriv
			OPERATION: LDTR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDTRB
	TYPE: instruction
	XML: ldtrb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTRB_32_ldst_unpriv
			OPERATION: LDTRB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDTRH
	TYPE: instruction
	XML: ldtrh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTRH_32_ldst_unpriv
			OPERATION: LDTRH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDTRSB
	TYPE: instruction
	XML: ldtrsb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTRSB_32_ldst_unpriv
			OPERATION: LDTRSB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDTRSB_64_ldst_unpriv
			OPERATION: LDTRSB
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDTRSH
	TYPE: instruction
	XML: ldtrsh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTRSH_32_ldst_unpriv
			OPERATION: LDTRSH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDTRSH_64_ldst_unpriv
			OPERATION: LDTRSH
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDTRSW
	TYPE: instruction
	XML: ldtrsw.xml
	CLASS: base_plus_offset
		FIELDS32: size=10|111|V=0|00|opc=10|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDTRSW_64_ldst_unpriv
			OPERATION: LDTRSW
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDUMAX
	TYPE: instruction
	XML: ldumax.xml
	ALIAS: STUMAX_LDUMAX
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMAX_32_memop
			OPERATION: LDUMAX
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDUMAXA_32_memop
			OPERATION: LDUMAXA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDUMAXAL_32_memop
			OPERATION: LDUMAXAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDUMAXL_32_memop
			OPERATION: LDUMAXL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDUMAX_64_memop
			OPERATION: LDUMAX
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDUMAXA_64_memop
			OPERATION: LDUMAXA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDUMAXAL_64_memop
			OPERATION: LDUMAXAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDUMAXL_64_memop
			OPERATION: LDUMAXL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDUMAXB
	TYPE: instruction
	XML: ldumaxb.xml
	ALIAS: STUMAXB_LDUMAXB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMAXAB_32_memop
			OPERATION: LDUMAXAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDUMAXALB_32_memop
			OPERATION: LDUMAXALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDUMAXB_32_memop
			OPERATION: LDUMAXB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDUMAXLB_32_memop
			OPERATION: LDUMAXLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDUMAXH
	TYPE: instruction
	XML: ldumaxh.xml
	ALIAS: STUMAXH_LDUMAXH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMAXAH_32_memop
			OPERATION: LDUMAXAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDUMAXALH_32_memop
			OPERATION: LDUMAXALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDUMAXH_32_memop
			OPERATION: LDUMAXH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDUMAXLH_32_memop
			OPERATION: LDUMAXLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDUMIN
	TYPE: instruction
	XML: ldumin.xml
	ALIAS: STUMIN_LDUMIN
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMIN_32_memop
			OPERATION: LDUMIN
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: LDUMINA_32_memop
			OPERATION: LDUMINA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: LDUMINAL_32_memop
			OPERATION: LDUMINAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: LDUMINL_32_memop
			OPERATION: LDUMINL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: LDUMIN_64_memop
			OPERATION: LDUMIN
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: LDUMINA_64_memop
			OPERATION: LDUMINA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: LDUMINAL_64_memop
			OPERATION: LDUMINAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: LDUMINL_64_memop
			OPERATION: LDUMINL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDUMINB
	TYPE: instruction
	XML: lduminb.xml
	ALIAS: STUMINB_LDUMINB
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMINAB_32_memop
			OPERATION: LDUMINAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDUMINALB_32_memop
			OPERATION: LDUMINALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDUMINB_32_memop
			OPERATION: LDUMINB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDUMINLB_32_memop
			OPERATION: LDUMINLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDUMINH
	TYPE: instruction
	XML: lduminh.xml
	ALIAS: STUMINH_LDUMINH
		A == '0' && Rt == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUMINAH_32_memop
			OPERATION: LDUMINAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: LDUMINALH_32_memop
			OPERATION: LDUMINALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: LDUMINH_32_memop
			OPERATION: LDUMINH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: LDUMINLH_32_memop
			OPERATION: LDUMINLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			MemAtomicOp op;
			case opc of
			    when '000' op = MemAtomicOp_ADD;
			    when '001' op = MemAtomicOp_BIC;
			    when '010' op = MemAtomicOp_EOR;
			    when '011' op = MemAtomicOp_ORR;
			    when '100' op = MemAtomicOp_SMAX;
			    when '101' op = MemAtomicOp_SMIN;
			    when '110' op = MemAtomicOp_UMAX;
			    when '111' op = MemAtomicOp_UMIN;
			boolean tag_checked = n != 31;

IFORM: LDURB
	TYPE: instruction
	XML: ldurb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDURB_32_ldst_unscaled
			OPERATION: LDURB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDURH
	TYPE: instruction
	XML: ldurh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDURH_32_ldst_unscaled
			OPERATION: LDURH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDURSB
	TYPE: instruction
	XML: ldursb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDURSB_32_ldst_unscaled
			OPERATION: LDURSB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDURSB_64_ldst_unscaled
			OPERATION: LDURSB
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDURSH
	TYPE: instruction
	XML: ldursh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=1x|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDURSH_32_ldst_unscaled
			OPERATION: LDURSH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '11'
			LABEL: 32-bit
		ENCODING: LDURSH_64_ldst_unscaled
			OPERATION: LDURSH
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDURSW
	TYPE: instruction
	XML: ldursw.xml
	CLASS: base_plus_offset
		FIELDS32: size=10|111|V=0|00|opc=10|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDURSW_64_ldst_unscaled
			OPERATION: LDURSW
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDUR_fpsimd
	TYPE: instruction
	XML: ldur_fpsimd.xml
	CLASS: base_plus_offset
		FIELDS32: size=xx|111|V=1|00|opc=x1|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUR_B_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Bt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '00' && opc == '01'
		ENCODING: LDUR_H_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Ht>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '01' && opc == '01'
		ENCODING: LDUR_S_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <St>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10' && opc == '01'
			LABEL: 32-bit
		ENCODING: LDUR_D_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Dt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11' && opc == '01'
			LABEL: 64-bit
		ENCODING: LDUR_Q_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Qt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '00' && opc == '11'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

IFORM: LDUR_gen
	TYPE: instruction
	XML: ldur_gen.xml
	CLASS: base_plus_offset
		FIELDS32: size=1x|111|V=0|00|opc=01|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDUR_32_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDUR_64_ldst_unscaled
			OPERATION: LDUR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: LDXP
	TYPE: instruction
	XML: ldxp.xml
	CLASS: base_register
		FIELDS32: 1|sz=x|001000|o2=0|L=1|o1=1|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDXP_LP32_ldstexcl
			OPERATION: LDXP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0'
			LABEL: 32-bit
		ENCODING: LDXP_LP64_ldstexcl
			OPERATION: LDXP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = TRUE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 32 << UInt(sz);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDXR
	TYPE: instruction
	XML: ldxr.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDXR_LR32_ldstexcl
			OPERATION: LDXR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: LDXR_LR64_ldstexcl
			OPERATION: LDXR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDXRB
	TYPE: instruction
	XML: ldxrb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDXRB_LR32_ldstexcl
			OPERATION: LDXRB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LDXRH
	TYPE: instruction
	XML: ldxrh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=0|L=1|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: LDXRH_LR32_ldstexcl
			OPERATION: LDXRH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: LSLV
	TYPE: instruction
	XML: lslv.xml
	ALIAS: LSL_LSLV
		Unconditionally
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSLV_32_dp_2src
			OPERATION: LSLV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: LSLV_64_dp_2src
			OPERATION: LSLV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			ShiftType shift_type = DecodeShift(op2);

IFORM: LSL_LSLV
	TYPE: alias
	XML: lsl_lslv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSL_LSLV_32_dp_2src
			OPERATION: LSL
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: LSL_LSLV_64_dp_2src
			OPERATION: LSL
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: LSL_UBFM
	TYPE: alias
	XML: lsl_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=x|opc=10|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSL_UBFM_32M_bitfield
			OPERATION: LSL
			SYNTAX: <Wd>,<Wn>, #<shift>
			BITDIFFS: sf == '0' && N == '0' && imms != '011111'
			LABEL: 32-bit
		ENCODING: LSL_UBFM_64M_bitfield
			OPERATION: LSL
			SYNTAX: <Xd>,<Xn>, #<shift>
			BITDIFFS: sf == '1' && N == '1' && imms != '111111'
			LABEL: 64-bit

IFORM: LSRV
	TYPE: instruction
	XML: lsrv.xml
	ALIAS: LSR_LSRV
		Unconditionally
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSRV_32_dp_2src
			OPERATION: LSRV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: LSRV_64_dp_2src
			OPERATION: LSRV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			ShiftType shift_type = DecodeShift(op2);

IFORM: LSR_LSRV
	TYPE: alias
	XML: lsr_lsrv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSR_LSRV_32_dp_2src
			OPERATION: LSR
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: LSR_LSRV_64_dp_2src
			OPERATION: LSR
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: LSR_UBFM
	TYPE: alias
	XML: lsr_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=x|opc=10|100110|N=x|immr=xxxxxx|imms=x11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: LSR_UBFM_32M_bitfield
			OPERATION: LSR
			SYNTAX: <Wd>,<Wn>, #<shift>
			BITDIFFS: sf == '0' && N == '0' && imms == '011111'
			LABEL: 32-bit
		ENCODING: LSR_UBFM_64M_bitfield
			OPERATION: LSR
			SYNTAX: <Xd>,<Xn>, #<shift>
			BITDIFFS: sf == '1' && N == '1' && imms == '111111'
			LABEL: 64-bit

IFORM: MADD
	TYPE: instruction
	XML: madd.xml
	ALIAS: MUL_MADD
		Ra == '11111'
	CLASS: general
		FIELDS32: sf=x|op54=00|11011|op31=000|Rm=xxxxx|o0=0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: MADD_32A_dp_3src
			OPERATION: MADD
			SYNTAX: <Wd>,<Wn>,<Wm>,<Wa>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MADD_64A_dp_3src
			OPERATION: MADD
			SYNTAX: <Xd>,<Xn>,<Xm>,<Xa>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = if sf == '1' then 64 else 32;
			integer datasize = destsize;
			boolean sub_op = (o0 == '1');

IFORM: MLA_advsimd_elt
	TYPE: instruction
	XML: mla_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=0|00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: MLA_asimdelem_R
			OPERATION: MLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: MLA_advsimd_vec
	TYPE: instruction
	XML: mla_advsimd_vec.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MLA_asimdsame_only
			OPERATION: MLA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (U == '1');

IFORM: MLS_advsimd_elt
	TYPE: instruction
	XML: mls_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=1|00|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: MLS_asimdelem_R
			OPERATION: MLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: MLS_advsimd_vec
	TYPE: instruction
	XML: mls_advsimd_vec.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=10010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MLS_asimdsame_only
			OPERATION: MLS
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (U == '1');

IFORM: MNEG_MSUB
	TYPE: alias
	XML: mneg_msub.xml
	CLASS: general
		FIELDS32: sf=x|op54=00|11011|op31=000|Rm=xxxxx|o0=1|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: MNEG_MSUB_32A_dp_3src
			OPERATION: MNEG
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MNEG_MSUB_64A_dp_3src
			OPERATION: MNEG
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOVI_advsimd
	TYPE: instruction
	XML: movi_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=x|0111100000|a=x|b=x|c=x|cmode=xxxx|o2=0|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: MOVI_asimdimm_N_b
			OPERATION: MOVI
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #0}
			BITDIFFS: op == '0' && cmode == '1110'
		ENCODING: MOVI_asimdimm_L_hl
			OPERATION: MOVI
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: op == '0' && cmode == '10x0'
		ENCODING: MOVI_asimdimm_L_sl
			OPERATION: MOVI
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: op == '0' && cmode == '0xx0'
		ENCODING: MOVI_asimdimm_M_sm
			OPERATION: MOVI
			SYNTAX: <Vd>.<T>, #<imm8>, MSL #<amount>
			BITDIFFS: op == '0' && cmode == '110x'
		ENCODING: MOVI_asimdimm_D_ds
			OPERATION: MOVI
			SYNTAX: <Dd>, #<imm>
			BITDIFFS: Q == '0' && op == '1' && cmode == '1110'
		ENCODING: MOVI_asimdimm_D2_d
			OPERATION: MOVI
			SYNTAX: <Vd>.2D, #<imm>
			BITDIFFS: Q == '1' && op == '1' && cmode == '1110'
		DECODE_PCODE:
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			bits(64) imm64;
			ImmediateOp operation;
			case cmode:op of
			    when '0xx00' operation = ImmediateOp_MOVI;
			    when '0xx01' operation = ImmediateOp_MVNI;
			    when '0xx10' operation = ImmediateOp_ORR;
			    when '0xx11' operation = ImmediateOp_BIC;
			    when '10x00' operation = ImmediateOp_MOVI;
			    when '10x01' operation = ImmediateOp_MVNI;
			    when '10x10' operation = ImmediateOp_ORR;
			    when '10x11' operation = ImmediateOp_BIC;
			    when '110x0' operation = ImmediateOp_MOVI;
			    when '110x1' operation = ImmediateOp_MVNI;
			    when '1110x' operation = ImmediateOp_MOVI;
			    when '11110' operation = ImmediateOp_MOVI;
			    when '11111'
			        // FMOV Dn,#imm is in main FP instruction set
			        if Q == '0' then UNDEFINED;
			        operation = ImmediateOp_MOVI;
			imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
			imm = Replicate(imm64, datasize DIV 64);

IFORM: MOVK
	TYPE: instruction
	XML: movk.xml
	CLASS: imm18_packed
		FIELDS32: sf=x|opc=11|100101|hw=xx|imm16=xxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: MOVK_32_movewide
			OPERATION: MOVK
			SYNTAX: <Wd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '0' && hw == '0x'
			LABEL: 32-bit
		ENCODING: MOVK_64_movewide
			OPERATION: MOVK
			SYNTAX: <Xd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer datasize = if sf == '1' then 64 else 32;
			bits(16) imm = imm16;
			integer pos;
			MoveWideOp opcode;
			case opc of
			    when '00' opcode = MoveWideOp_N;
			    when '10' opcode = MoveWideOp_Z;
			    when '11' opcode = MoveWideOp_K;
			    otherwise UNDEFINED;
			if sf == '0' && hw<1> == '1' then UNDEFINED;
			pos = UInt(hw:'0000');

IFORM: MOVN
	TYPE: instruction
	XML: movn.xml
	ALIAS: MOV_MOVN
		! (IsZero(imm16) && hw != '00') && EncodingLabeled64Bit()
		! (IsZero(imm16) && hw != '00') && ! IsOnes(imm16) && EncodingLabeled32Bit()
	CLASS: imm18_packed
		FIELDS32: sf=x|opc=00|100101|hw=xx|imm16=xxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: MOVN_32_movewide
			OPERATION: MOVN
			SYNTAX: <Wd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '0' && hw == '0x'
			LABEL: 32-bit
		ENCODING: MOVN_64_movewide
			OPERATION: MOVN
			SYNTAX: <Xd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer datasize = if sf == '1' then 64 else 32;
			bits(16) imm = imm16;
			integer pos;
			MoveWideOp opcode;
			case opc of
			    when '00' opcode = MoveWideOp_N;
			    when '10' opcode = MoveWideOp_Z;
			    when '11' opcode = MoveWideOp_K;
			    otherwise UNDEFINED;
			if sf == '0' && hw<1> == '1' then UNDEFINED;
			pos = UInt(hw:'0000');

IFORM: MOVS_and_p_p_pp
	TYPE: alias
	XML: movs_and_p_p_pp.xml
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: MOVS_ands_p_p_pp_z
			OPERATION: MOVS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B

IFORM: MOVS_orr_p_p_pp
	TYPE: alias
	XML: movs_orr_p_p_pp.xml
	CLASS: s
		FIELDS32: 00100101|op=1|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: MOVS_orrs_p_p_pp_z
			OPERATION: MOVS
			SYNTAX: <Pd>.B,<Pn>.B

IFORM: MOVZ
	TYPE: instruction
	XML: movz.xml
	ALIAS: MOV_MOVZ
		! (IsZero(imm16) && hw != '00')
	CLASS: imm18_packed
		FIELDS32: sf=x|opc=10|100101|hw=xx|imm16=xxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: MOVZ_32_movewide
			OPERATION: MOVZ
			SYNTAX: <Wd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '0' && hw == '0x'
			LABEL: 32-bit
		ENCODING: MOVZ_64_movewide
			OPERATION: MOVZ
			SYNTAX: <Xd>, #<imm>{, LSL #<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer datasize = if sf == '1' then 64 else 32;
			bits(16) imm = imm16;
			integer pos;
			MoveWideOp opcode;
			case opc of
			    when '00' opcode = MoveWideOp_N;
			    when '10' opcode = MoveWideOp_Z;
			    when '11' opcode = MoveWideOp_K;
			    otherwise UNDEFINED;
			if sf == '0' && hw<1> == '1' then UNDEFINED;
			pos = UInt(hw:'0000');

IFORM: MOV_ADD_addsub_imm
	TYPE: alias
	XML: mov_add_addsub_imm.xml
	CLASS: no_s
		FIELDS32: sf=x|op=0|S=0|100010|sh=0|imm12=000000000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_ADD_32_addsub_imm
			OPERATION: MOV
			SYNTAX: <Wd|WSP>,<Wn|WSP>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MOV_ADD_64_addsub_imm
			OPERATION: MOV
			SYNTAX: <Xd|SP>,<Xn|SP>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOV_DUP_advsimd_elt
	TYPE: alias
	XML: mov_dup_advsimd_elt.xml
	CLASS: scalar_from_element
		FIELDS32: 01|op=0|11110000|imm5=xxxxx|0|imm4=0000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_DUP_asisdone_only
			OPERATION: MOV
			SYNTAX: <V><d>,<Vn>.<T>[<index>]

IFORM: MOV_INS_advsimd_elt
	TYPE: alias
	XML: mov_ins_advsimd_elt.xml
	CLASS: advsimd
		FIELDS32: 0|Q=1|op=1|01110000|imm5=xxxxx|0|imm4=xxxx|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_INS_asimdins_IV_v
			OPERATION: MOV
			SYNTAX: <Vd>.<Ts>[<index1>],<Vn>.<Ts>[<index2>]

IFORM: MOV_INS_advsimd_gen
	TYPE: alias
	XML: mov_ins_advsimd_gen.xml
	CLASS: advsimd
		FIELDS32: 0|Q=1|op=0|01110000|imm5=xxxxx|0|imm4=0011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_INS_asimdins_IR_r
			OPERATION: MOV
			SYNTAX: <Vd>.<Ts>[<index>],<R><n>

IFORM: MOV_MOVN
	TYPE: alias
	XML: mov_movn.xml
	CLASS: imm18_packed
		FIELDS32: sf=x|opc=00|100101|hw=xx|imm16=xxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: MOV_MOVN_32_movewide
			OPERATION: MOV
			SYNTAX: <Wd>, #<imm>
			BITDIFFS: sf == '0' && hw == '0x'
			LABEL: 32-bit
		ENCODING: MOV_MOVN_64_movewide
			OPERATION: MOV
			SYNTAX: <Xd>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOV_MOVZ
	TYPE: alias
	XML: mov_movz.xml
	CLASS: imm18_packed
		FIELDS32: sf=x|opc=10|100101|hw=xx|imm16=xxxxxxxxxxxxxxxx|Rd=xxxxx
		ENCODING: MOV_MOVZ_32_movewide
			OPERATION: MOV
			SYNTAX: <Wd>, #<imm>
			BITDIFFS: sf == '0' && hw == '0x'
			LABEL: 32-bit
		ENCODING: MOV_MOVZ_64_movewide
			OPERATION: MOV
			SYNTAX: <Xd>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOV_ORR_advsimd_reg
	TYPE: alias
	XML: mov_orr_advsimd_reg.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=10|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_ORR_asimdsame_only
			OPERATION: MOV
			SYNTAX: <Vd>.<T>,<Vn>.<T>

IFORM: MOV_ORR_log_imm
	TYPE: alias
	XML: mov_orr_log_imm.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=01|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=11111|Rd=xxxxx
		ENCODING: MOV_ORR_32_log_imm
			OPERATION: MOV
			SYNTAX: <Wd|WSP>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: MOV_ORR_64_log_imm
			OPERATION: MOV
			SYNTAX: <Xd|SP>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOV_ORR_log_shift
	TYPE: alias
	XML: mov_orr_log_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=01|01010|shift=00|N=0|Rm=xxxxx|imm6=000000|Rn=11111|Rd=xxxxx
		ENCODING: MOV_ORR_32_log_shift
			OPERATION: MOV
			SYNTAX: <Wd>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MOV_ORR_64_log_shift
			OPERATION: MOV
			SYNTAX: <Xd>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MOV_UMOV_advsimd
	TYPE: alias
	XML: mov_umov_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=0|01110000|imm5=xxx00|0|imm4<3:2>=01|imm4=11|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MOV_UMOV_asimdins_W_w
			OPERATION: MOV
			SYNTAX: <Wd>,<Vn>.S[<index>]
			BITDIFFS: Q == '0' && imm5 == 'xx100'
			LABEL: 32-bit
		ENCODING: MOV_UMOV_asimdins_X_x
			OPERATION: MOV
			SYNTAX: <Xd>,<Vn>.D[<index>]
			BITDIFFS: Q == '1' && imm5 == 'x1000'

IFORM: MOV_and_p_p_pp
	TYPE: alias
	XML: mov_and_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: MOV_and_p_p_pp_z
			OPERATION: MOV
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B

IFORM: MOV_cpy_z_o_i
	TYPE: alias
	XML: mov_cpy_z_o_i.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|0|M=0|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: MOV_cpy_z_o_i_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Pg>/Z, #<imm>{,<shift>}

IFORM: MOV_cpy_z_p_i
	TYPE: alias
	XML: mov_cpy_z_p_i.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|0|M=1|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: MOV_cpy_z_p_i_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Pg>/M, #<imm>{,<shift>}

IFORM: MOV_cpy_z_p_r
	TYPE: alias
	XML: mov_cpy_z_p_r.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|101000101|Pg=xxx|Rn=xxxxx|Zd=xxxxx
		ENCODING: MOV_cpy_z_p_r_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Pg>/M,<R><n|SP>

IFORM: MOV_cpy_z_p_v
	TYPE: alias
	XML: mov_cpy_z_p_v.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|100000100|Pg=xxx|Vn=xxxxx|Zd=xxxxx
		ENCODING: MOV_cpy_z_p_v_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Pg>/M,<V><n>

IFORM: MOV_dup_z_i
	TYPE: alias
	XML: mov_dup_z_i.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|111|opc=00|011|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: MOV_dup_z_i_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>, #<imm>{,<shift>}

IFORM: MOV_dup_z_r
	TYPE: alias
	XML: mov_dup_z_r.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|100000001110|Rn=xxxxx|Zd=xxxxx
		ENCODING: MOV_dup_z_r_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<R><n|SP>

IFORM: MOV_dup_z_zi
	TYPE: alias
	XML: mov_dup_z_zi.xml
	CLASS: sve
		FIELDS32: 00000101|imm2=xx|1|tsz=xxxxx|001000|Zn=xxxxx|Zd=xxxxx
		ENCODING: MOV_dup_z_zi_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<V><n>
			BITDIFFS: BitCount(imm2:tsz)==1
		ENCODING: MOV_dup_z_zi_2
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Zn>.<T>[<imm>]
			BITDIFFS: BitCount(imm2:tsz)>1

IFORM: MOV_dupm_z_i
	TYPE: alias
	XML: mov_dupm_z_i.xml
	CLASS: sve
		FIELDS32: 00000101110000|imm13=xxxxxxxxxxxxx|Zd=xxxxx
		ENCODING: MOV_dupm_z_i_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>, #<const>

IFORM: MOV_orr_p_p_pp
	TYPE: alias
	XML: mov_orr_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=1|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: MOV_orr_p_p_pp_z
			OPERATION: MOV
			SYNTAX: <Pd>.B,<Pn>.B

IFORM: MOV_orr_z_zz
	TYPE: alias
	XML: mov_orr_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|opc=01|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: MOV_orr_z_zz_
			OPERATION: MOV
			SYNTAX: <Zd>.D,<Zn>.D

IFORM: MOV_sel_p_p_pp
	TYPE: alias
	XML: mov_sel_p_p_pp.xml
	CLASS: sve
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: MOV_sel_p_p_pp_
			OPERATION: MOV
			SYNTAX: <Pd>.B,<Pg>/M,<Pn>.B

IFORM: MOV_sel_z_p_zz
	TYPE: alias
	XML: mov_sel_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|11|Pg=xxxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: MOV_sel_z_p_zz_
			OPERATION: MOV
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>

IFORM: MRS
	TYPE: instruction
	XML: mrs.xml
	CLASS: system
		FIELDS32: 1101010100|L=1|op0<1>=1|o0=x|op1=xxx|CRn=xxxx|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: MRS_RS_systemmove
			OPERATION: MRS
			SYNTAX: <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)
		DECODE_PCODE:
			AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
			integer t = UInt(Rt);
			integer sys_op0 = 2 + UInt(o0);
			integer sys_op1 = UInt(op1);
			integer sys_op2 = UInt(op2);
			integer sys_crn = UInt(CRn);
			integer sys_crm = UInt(CRm);
			boolean read = (L == '1');

IFORM: MSR_imm
	TYPE: instruction
	XML: msr_imm.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=xxx|CRn=0100|CRm=xxxx|op2=xxx|Rt =11111
		ENCODING: MSR_SI_pstate
			OPERATION: MSR
			SYNTAX: <pstatefield>, #<imm>
		DECODE_PCODE:
			if op1 == '000' && op2 == '000' then SEE "CFINV";
			if op1 == '000' && op2 == '001' then SEE "XAFLAG";
			if op1 == '000' && op2 == '010' then SEE "AXFLAG";
			AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');
			bits(2) min_EL;
			boolean need_secure = FALSE;
			case op1 of
			    when '00x'
			        min_EL = EL1;
			    when '010'
			        min_EL = EL1;
			    when '011'
			        min_EL = EL0;
			    when '100'
			        min_EL = EL2;
			    when '101'
			        if !HaveVirtHostExt() then
			            UNDEFINED;
			        min_EL = EL2;
			    when '110'
			        min_EL = EL3;
			    when '111'
			        min_EL = EL1;
			        need_secure = TRUE;
			if UInt(PSTATE.EL) < UInt(min_EL) || (need_secure && !IsSecure()) then
			    UNDEFINED;
			bits(4) operand = CRm;
			PSTATEField field;
			case op1:op2 of
			    when '000 011'
			        if !HaveUAOExt() then
			            UNDEFINED;
			        field = PSTATEField_UAO;
			    when '000 100'
			        if !HavePANExt() then
			            UNDEFINED;
			        field = PSTATEField_PAN;
			    when '000 101' field = PSTATEField_SP;
			    when '011 010'
			        if !HaveDITExt() then
			            UNDEFINED;
			        field = PSTATEField_DIT;
			    when '011 011'
			        UNDEFINED;
			    when '011 100'
			        if !HaveMTEExt() then
			            UNDEFINED;
			        field = PSTATEField_TCO;
			    when '011 110' field = PSTATEField_DAIFSet;
			    when '011 111' field = PSTATEField_DAIFClr;
			    when '011 001'
			        if !HaveSSBSExt() then
			            UNDEFINED;
			        field = PSTATEField_SSBS;
			    otherwise      UNDEFINED;
			// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted
			if PSTATE.EL == EL0 && field IN {PSTATEField_DAIFSet, PSTATEField_DAIFClr}  then
			    if !ELUsingAArch32(EL1) && ((EL2Enabled() && HCR_EL2.<E2H,TGE> == '11') || SCTLR_EL1.UMA == '0') then
			        if EL2Enabled() && !ELUsingAArch32(EL2) && HCR_EL2.TGE == '1' then
			            AArch64.SystemAccessTrap(EL2, 0x18);
			        else
			            AArch64.SystemAccessTrap(EL1, 0x18);

IFORM: MSR_reg
	TYPE: instruction
	XML: msr_reg.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0<1>=1|o0=x|op1=xxx|CRn=xxxx|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: MSR_SR_systemmove
			OPERATION: MSR
			SYNTAX: (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>),<Xt>
		DECODE_PCODE:
			AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
			integer t = UInt(Rt);
			integer sys_op0 = 2 + UInt(o0);
			integer sys_op1 = UInt(op1);
			integer sys_op2 = UInt(op2);
			integer sys_crn = UInt(CRn);
			integer sys_crm = UInt(CRm);
			boolean read = (L == '1');

IFORM: MSUB
	TYPE: instruction
	XML: msub.xml
	ALIAS: MNEG_MSUB
		Ra == '11111'
	CLASS: general
		FIELDS32: sf=x|op54=00|11011|op31=000|Rm=xxxxx|o0=1|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: MSUB_32A_dp_3src
			OPERATION: MSUB
			SYNTAX: <Wd>,<Wn>,<Wm>,<Wa>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MSUB_64A_dp_3src
			OPERATION: MSUB
			SYNTAX: <Xd>,<Xn>,<Xm>,<Xa>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = if sf == '1' then 64 else 32;
			integer datasize = destsize;
			boolean sub_op = (o0 == '1');

IFORM: MUL_MADD
	TYPE: alias
	XML: mul_madd.xml
	CLASS: general
		FIELDS32: sf=x|op54=00|11011|op31=000|Rm=xxxxx|o0=0|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: MUL_MADD_32A_dp_3src
			OPERATION: MUL
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MUL_MADD_64A_dp_3src
			OPERATION: MUL
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: MUL_advsimd_elt
	TYPE: instruction
	XML: mul_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1000|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: MUL_asimdelem_R
			OPERATION: MUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: MUL_advsimd_vec
	TYPE: instruction
	XML: mul_advsimd_vec.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: MUL_asimdsame_only
			OPERATION: MUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if U == '1' && size != '00' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean poly = (U == '1');

IFORM: MVNI_advsimd
	TYPE: instruction
	XML: mvni_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=1|0111100000|a=x|b=x|c=x|cmode=xxxx|o2=0|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: MVNI_asimdimm_L_hl
			OPERATION: MVNI
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '10x0'
		ENCODING: MVNI_asimdimm_L_sl
			OPERATION: MVNI
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '0xx0'
		ENCODING: MVNI_asimdimm_M_sm
			OPERATION: MVNI
			SYNTAX: <Vd>.<T>, #<imm8>, MSL #<amount>
			BITDIFFS: cmode == '110x'
		DECODE_PCODE:
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			bits(64) imm64;
			ImmediateOp operation;
			case cmode:op of
			    when '0xx00' operation = ImmediateOp_MOVI;
			    when '0xx01' operation = ImmediateOp_MVNI;
			    when '0xx10' operation = ImmediateOp_ORR;
			    when '0xx11' operation = ImmediateOp_BIC;
			    when '10x00' operation = ImmediateOp_MOVI;
			    when '10x01' operation = ImmediateOp_MVNI;
			    when '10x10' operation = ImmediateOp_ORR;
			    when '10x11' operation = ImmediateOp_BIC;
			    when '110x0' operation = ImmediateOp_MOVI;
			    when '110x1' operation = ImmediateOp_MVNI;
			    when '1110x' operation = ImmediateOp_MOVI;
			    when '11110' operation = ImmediateOp_MOVI;
			    when '11111'
			        // FMOV Dn,#imm is in main FP instruction set
			        if Q == '0' then UNDEFINED;
			        operation = ImmediateOp_MOVI;
			imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
			imm = Replicate(imm64, datasize DIV 64);

IFORM: MVN_NOT_advsimd
	TYPE: alias
	XML: mvn_not_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=00|10000|opcode=00101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: MVN_NOT_asimdmisc_R
			OPERATION: MVN
			SYNTAX: <Vd>.<T>,<Vn>.<T>

IFORM: MVN_ORN_log_shift
	TYPE: alias
	XML: mvn_orn_log_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|opc=01|01010|shift=xx|N=1|Rm=xxxxx|imm6=xxxxxx|Rn=11111|Rd=xxxxx
		ENCODING: MVN_ORN_32_log_shift
			OPERATION: MVN
			SYNTAX: <Wd>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: MVN_ORN_64_log_shift
			OPERATION: MVN
			SYNTAX: <Xd>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: NEGS_SUBS_addsub_shift
	TYPE: alias
	XML: negs_subs_addsub_shift.xml
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=11111|Rd!=11111
		ENCODING: NEGS_SUBS_32_addsub_shift
			OPERATION: NEGS
			SYNTAX: <Wd>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: NEGS_SUBS_64_addsub_shift
			OPERATION: NEGS
			SYNTAX: <Xd>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: NEG_SUB_addsub_shift
	TYPE: alias
	XML: neg_sub_addsub_shift.xml
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=11111|Rd=xxxxx
		ENCODING: NEG_SUB_32_addsub_shift
			OPERATION: NEG
			SYNTAX: <Wd>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: NEG_SUB_64_addsub_shift
			OPERATION: NEG
			SYNTAX: <Xd>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: NEG_advsimd
	TYPE: instruction
	XML: neg_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|opcode=01011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: NEG_asisdmisc_R
			OPERATION: NEG
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean neg = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=01011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: NEG_asimdmisc_R
			OPERATION: NEG
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: NGCS_SBCS
	TYPE: alias
	XML: ngcs_sbcs.xml
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|11010000|Rm=xxxxx|000000|Rn=11111|Rd=xxxxx
		ENCODING: NGCS_SBCS_32_addsub_carry
			OPERATION: NGCS
			SYNTAX: <Wd>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: NGCS_SBCS_64_addsub_carry
			OPERATION: NGCS
			SYNTAX: <Xd>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: NGC_SBC
	TYPE: alias
	XML: ngc_sbc.xml
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|11010000|Rm=xxxxx|000000|Rn=11111|Rd=xxxxx
		ENCODING: NGC_SBC_32_addsub_carry
			OPERATION: NGC
			SYNTAX: <Wd>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: NGC_SBC_64_addsub_carry
			OPERATION: NGC
			SYNTAX: <Xd>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: NOP
	TYPE: instruction
	XML: nop.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=000|Rt=11111
		ENCODING: NOP_HI_hints
			OPERATION: NOP
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: NOTS_eor_p_p_pp
	TYPE: alias
	XML: nots_eor_p_p_pp.xml
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: NOTS_eors_p_p_pp_z
			OPERATION: NOTS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B

IFORM: NOT_advsimd
	TYPE: instruction
	XML: not_advsimd.xml
	ALIAS: MVN_NOT_advsimd
		Unconditionally
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=00|10000|opcode=00101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: NOT_asimdmisc_R
			OPERATION: NOT
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 8;

IFORM: NOT_eor_p_p_pp
	TYPE: alias
	XML: not_eor_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: NOT_eor_p_p_pp_z
			OPERATION: NOT
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B

IFORM: ORN_advsimd
	TYPE: instruction
	XML: orn_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=11|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: ORN_asimdsame_only
			OPERATION: ORN
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean invert = (size<0> == '1');
			LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

IFORM: ORN_log_shift
	TYPE: instruction
	XML: orn_log_shift.xml
	ALIAS: MVN_ORN_log_shift
		Rn == '11111'
	CLASS: no_s
		FIELDS32: sf=x|opc=01|01010|shift=xx|N=1|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ORN_32_log_shift
			OPERATION: ORN
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ORN_64_log_shift
			OPERATION: ORN
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: ORN_orr_z_zi
	TYPE: alias
	XML: orn_orr_z_zi.xml
	CLASS: sve
		FIELDS32: 00000101|opc=00|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: ORN_orr_z_zi_
			OPERATION: ORN
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>

IFORM: ORR_advsimd_imm
	TYPE: instruction
	XML: orr_advsimd_imm.xml
	CLASS: shifted_immediate
		FIELDS32: 0|Q=x|op=0|0111100000|a=x|b=x|c=x|cmode=xxx1|o2=0|1|d=x|e=x|f=x|g=x|h=x|Rd=xxxxx
		ENCODING: ORR_asimdimm_L_hl
			OPERATION: ORR
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '10x1'
		ENCODING: ORR_asimdimm_L_sl
			OPERATION: ORR
			SYNTAX: <Vd>.<T>, #<imm8>{, LSL #<amount>}
			BITDIFFS: cmode == '0xx1'
			LABEL: 32-bit
		DECODE_PCODE:
			integer rd = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			bits(datasize) imm;
			bits(64) imm64;
			ImmediateOp operation;
			case cmode:op of
			    when '0xx00' operation = ImmediateOp_MOVI;
			    when '0xx01' operation = ImmediateOp_MVNI;
			    when '0xx10' operation = ImmediateOp_ORR;
			    when '0xx11' operation = ImmediateOp_BIC;
			    when '10x00' operation = ImmediateOp_MOVI;
			    when '10x01' operation = ImmediateOp_MVNI;
			    when '10x10' operation = ImmediateOp_ORR;
			    when '10x11' operation = ImmediateOp_BIC;
			    when '110x0' operation = ImmediateOp_MOVI;
			    when '110x1' operation = ImmediateOp_MVNI;
			    when '1110x' operation = ImmediateOp_MOVI;
			    when '11110' operation = ImmediateOp_MOVI;
			    when '11111'
			        // FMOV Dn,#imm is in main FP instruction set
			        if Q == '0' then UNDEFINED;
			        operation = ImmediateOp_MOVI;
			imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
			imm = Replicate(imm64, datasize DIV 64);

IFORM: ORR_advsimd_reg
	TYPE: instruction
	XML: orr_advsimd_reg.xml
	ALIAS: MOV_ORR_advsimd_reg
		Rm == Rn
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=10|1|Rm=xxxxx|opcode=00011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: ORR_asimdsame_only
			OPERATION: ORR
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean invert = (size<0> == '1');
			LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;

IFORM: ORR_log_imm
	TYPE: instruction
	XML: orr_log_imm.xml
	ALIAS: MOV_ORR_log_imm
		Rn == '11111' && ! MoveWidePreferred(sf, N, imms, immr)
	CLASS: no_s
		FIELDS32: sf=x|opc=01|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ORR_32_log_imm
			OPERATION: ORR
			SYNTAX: <Wd|WSP>,<Wn>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: ORR_64_log_imm
			OPERATION: ORR
			SYNTAX: <Xd|SP>,<Xn>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			bits(datasize) imm;
			if sf == '0' && N != '0' then UNDEFINED;
			(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

IFORM: ORR_log_shift
	TYPE: instruction
	XML: orr_log_shift.xml
	ALIAS: MOV_ORR_log_shift
		shift == '00' && imm6 == '000000' && Rn == '11111'
	CLASS: no_s
		FIELDS32: sf=x|opc=01|01010|shift=xx|N=0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ORR_32_log_shift
			OPERATION: ORR
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ORR_64_log_shift
			OPERATION: ORR
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean setflags;
			LogicalOp op;
			case opc of
			    when '00' op = LogicalOp_AND; setflags = FALSE;
			    when '01' op = LogicalOp_ORR; setflags = FALSE;
			    when '10' op = LogicalOp_EOR; setflags = FALSE;
			    when '11' op = LogicalOp_AND; setflags = TRUE;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);
			boolean invert = (N == '1');

IFORM: PACDA
	TYPE: instruction
	XML: pacda.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=010|Rn=xxxxx|Rd=xxxxx
		ENCODING: PACDA_64P_dp_1src
			OPERATION: PACDA
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: PACDZA_64Z_dp_1src
			OPERATION: PACDZA
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // PACDA
			    if n == 31 then source_is_sp = TRUE;
			else // PACDZA
			    if n != 31 then UNDEFINED;

IFORM: PACDB
	TYPE: instruction
	XML: pacdb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=011|Rn=xxxxx|Rd=xxxxx
		ENCODING: PACDB_64P_dp_1src
			OPERATION: PACDB
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: PACDZB_64Z_dp_1src
			OPERATION: PACDZB
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // PACDB
			    if n == 31 then source_is_sp = TRUE;
			else // PACDZB
			    if n != 31 then UNDEFINED;

IFORM: PACGA
	TYPE: instruction
	XML: pacga.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|op=0|S=0|11010110|Rm=xxxxx|opcode2=001100|Rn=xxxxx|Rd=xxxxx
		ENCODING: PACGA_64P_dp_2src
			OPERATION: PACGA
			SYNTAX: <Xd>,<Xn>,<Xm|SP>
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HavePACExt() then
			    UNDEFINED;
			if m == 31 then source_is_sp = TRUE;

IFORM: PACIA
	TYPE: instruction
	XML: pacia.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=000|Rn=xxxxx|Rd=xxxxx
		ENCODING: PACIA_64P_dp_1src
			OPERATION: PACIA
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: PACIZA_64Z_dp_1src
			OPERATION: PACIZA
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // PACIA
			    if n == 31 then source_is_sp = TRUE;
			else // PACIZA
			    if n != 31 then UNDEFINED;
	CLASS: system
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=00x1|op2=00x|Rt=11111
		ENCODING: PACIA1716_HI_hints
			OPERATION: PACIA1716
			SYNTAX: 
			BITDIFFS: CRm == '0001' && op2 == '000'
		ENCODING: PACIASP_HI_hints
			OPERATION: PACIASP
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '001'
		ENCODING: PACIAZ_HI_hints
			OPERATION: PACIAZ
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '000'
		DECODE_PCODE:
			integer d;
			integer n;
			boolean source_is_sp = FALSE;
			case CRm:op2 of
			    when '0011 000' // PACIAZ
			        d = 30;
			        n = 31;
			    when '0011 001' // PACIASP
			        d = 30;
			        source_is_sp = TRUE;
			        if HaveBTIExt() then
			            // Check for branch target compatibility between PSTATE.BTYPE
			            // and implicit branch target of PACIASP instruction.
			            SetBTypeCompatible(BTypeCompatible_PACIXSP());
			    when '0001 000' // PACIA1716
			        d = 17;
			        n = 16;
			    when '0001 010' SEE "PACIB";
			    when '0001 100' SEE "AUTIA";
			    when '0001 110' SEE "AUTIB";
			    when '0011 01x' SEE "PACIB";
			    when '0011 10x' SEE "AUTIA";
			    when '0011 11x' SEE "AUTIB";
			    when '0000 111' SEE "XPACLRI";
			    otherwise       SEE "HINT";

IFORM: PACIB
	TYPE: instruction
	XML: pacib.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=0|Z=x|opcode[2:0]=001|Rn=xxxxx|Rd=xxxxx
		ENCODING: PACIB_64P_dp_1src
			OPERATION: PACIB
			SYNTAX: <Xd>,<Xn|SP>
			BITDIFFS: Z == '0'
		ENCODING: PACIZB_64Z_dp_1src
			OPERATION: PACIZB
			SYNTAX: <Xd>
			BITDIFFS: Z == '1' && Rn == '11111'
		DECODE_PCODE:
			boolean source_is_sp = FALSE;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if Z == '0' then // PACIB
			    if n == 31 then source_is_sp = TRUE;
			else // PACIZB
			    if n != 31 then UNDEFINED;
	CLASS: system
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=00x1|op2=01x|Rt=11111
		ENCODING: PACIB1716_HI_hints
			OPERATION: PACIB1716
			SYNTAX: 
			BITDIFFS: CRm == '0001' && op2 == '010'
		ENCODING: PACIBSP_HI_hints
			OPERATION: PACIBSP
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '011'
		ENCODING: PACIBZ_HI_hints
			OPERATION: PACIBZ
			SYNTAX: 
			BITDIFFS: CRm == '0011' && op2 == '010'
		DECODE_PCODE:
			integer d;
			integer n;
			boolean source_is_sp = FALSE;
			case CRm:op2 of
			    when '0011 010' // PACIBZ
			        d = 30;
			        n = 31;
			    when '0011 011' // PACIBSP
			        d = 30;
			        source_is_sp = TRUE;
			        if HaveBTIExt() then
			            // Check for branch target compatibility between PSTATE.BTYPE
			            // and implicit branch target of PACIBSP instruction.
			            SetBTypeCompatible(BTypeCompatible_PACIXSP());
			    when '0001 010' // PACIB1716
			        d = 17;
			        n = 16;
			    when '0001 000' SEE "PACIA";
			    when '0001 100' SEE "AUTIA";
			    when '0001 110' SEE "AUTIB";
			    when '0011 00x' SEE "PACIA";
			    when '0011 10x' SEE "AUTIA";
			    when '0011 11x' SEE "AUTIB";
			    when '0000 111' SEE "XPACLRI";
			    otherwise       SEE "HINT";

IFORM: PMULL_advsimd
	TYPE: instruction
	XML: pmull_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=1110|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: PMULL_asimddiff_L
			OPERATION: PMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '01' || size == '10' then UNDEFINED;
			if size == '11' && !HaveBit128PMULLExt() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: PMUL_advsimd
	TYPE: instruction
	XML: pmul_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=10011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: PMUL_asimdsame_only
			OPERATION: PMUL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if U == '1' && size != '00' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean poly = (U == '1');

IFORM: PRFM_imm
	TYPE: instruction
	XML: prfm_imm.xml
	CLASS: unsigned_scaled_offset
		FIELDS32: size=11|111|V=0|01|opc=10|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: PRFM_P_ldst_pos
			OPERATION: PRFM
			SYNTAX: (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: PRFM_lit
	TYPE: instruction
	XML: prfm_lit.xml
	CLASS: literal
		FIELDS32: opc=11|011|V=0|00|imm19=xxxxxxxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: PRFM_P_loadlit
			OPERATION: PRFM
			SYNTAX: (<prfop>|#<imm5>),<label>
		DECODE_PCODE:
			integer t = UInt(Rt);
			MemOp memop = MemOp_LOAD;
			boolean signed = FALSE;
			integer size;
			bits(64) offset;
			case opc of
			    when '00'
			        size = 4;
			    when '01'
			        size = 8;
			    when '10'
			        size = 4;
			        signed = TRUE;
			    when '11'
			        memop = MemOp_PREFETCH;
			offset = SignExtend(imm19:'00', 64);
			boolean tag_checked = FALSE;

IFORM: PRFM_reg
	TYPE: instruction
	XML: prfm_reg.xml
	CLASS: general
		FIELDS32: size=11|111|V=0|00|opc=10|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: PRFM_P_ldst_regoff
			OPERATION: PRFM
			SYNTAX: (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: PRFUM
	TYPE: instruction
	XML: prfum.xml
	CLASS: base_plus_offset
		FIELDS32: size=11|111|V=0|00|opc=10|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: PRFUM_P_ldst_unscaled
			OPERATION: PRFUM
			SYNTAX: <prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: PSB
	TYPE: instruction
	XML: psb.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SPE
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0010|op2=001|Rt=11111
		ENCODING: PSB_HC_hints
			OPERATION: PSB
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: PSSBB
	TYPE: instruction
	XML: pssbb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=0100|1|opc=00|Rt=11111
		ENCODING: PSSBB_only_barriers
			OPERATION: PSSBB
			SYNTAX: 

IFORM: RADDHN_advsimd
	TYPE: instruction
	XML: raddhn_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|01|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: RADDHN_asimddiff_N
			OPERATION: RADDHN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>,<Vm>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean round = (U == '1');

IFORM: RAX1_advsimd
	TYPE: instruction
	XML: rax1_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA3
		FIELDS32: 11001110011|Rm=xxxxx|1|O=0|00|opcode=11|Rn=xxxxx|Rd=xxxxx
		ENCODING: RAX1_VVV2_cryptosha512_3
			OPERATION: RAX1
			SYNTAX: <Vd>.2D,<Vn>.2D,<Vm>.2D
		DECODE_PCODE:
			if !HaveSHA3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: RBIT_advsimd
	TYPE: instruction
	XML: rbit_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=01|10000|opcode=00101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: RBIT_asimdmisc_R
			OPERATION: RBIT
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 8;

IFORM: RBIT_int
	TYPE: instruction
	XML: rbit_int.xml
	CLASS: general
		FIELDS32: sf=x|1|S=0|11010110|opcode2=00000|opcode[5:2]=0000|opcode[1:0]=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: RBIT_32_dp_1src
			OPERATION: RBIT
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: RBIT_64_dp_1src
			OPERATION: RBIT
			SYNTAX: <Xd>,<Xn>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;

IFORM: RET
	TYPE: instruction
	XML: ret.xml
	CLASS: general
		FIELDS32: 1101011|Z=0|opc[2:1]=0|op=10|op2=11111|op3[5:2]=0000|A=0|M=0|Rn=xxxxx|Rm=00000
		ENCODING: RET_64R_branch_reg
			OPERATION: RET
			SYNTAX: {<Xn>}
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: RETA
	TYPE: instruction
	XML: reta.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101011|Z=0|opc[2:1]=0|op=10|op2=11111|op3[5:2]=0000|A=1|M=x|Rn=11111|Rm=11111
		ENCODING: RETAA_64E_branch_reg
			OPERATION: RETAA
			SYNTAX: 
			BITDIFFS: M == '0'
		ENCODING: RETAB_64E_branch_reg
			OPERATION: RETAB
			SYNTAX: 
			BITDIFFS: M == '1'
		DECODE_PCODE:
			integer n = UInt(Rn);
			BranchType branch_type;
			integer m = UInt(Rm);
			boolean pac = (A == '1');
			boolean use_key_a = (M == '0');
			boolean source_is_sp = ((Z == '1') && (m == 31));
			if !pac && m != 0 then
			    UNDEFINED;
			elsif pac && !HavePACExt() then
			    UNDEFINED;
			case op of
			    when '00' branch_type = BranchType_INDIR;
			    when '01' branch_type = BranchType_INDCALL;
			    when '10' branch_type = BranchType_RET;
			    otherwise UNDEFINED;
			if pac then
			    if Z == '0' && m != 31 then
			        UNDEFINED;
			    if branch_type == BranchType_RET then
			        if n != 31 then UNDEFINED;
			        n = 30;
			        source_is_sp = TRUE;

IFORM: REV
	TYPE: instruction
	XML: rev.xml
	ALIAS: REV64_REV
		Never
	CLASS: general
		FIELDS32: sf=x|1|S=0|11010110|opcode2=00000|opcode[5:2]=0000|opc=1x|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV_32_dp_1src
			OPERATION: REV
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0' && opc == '10'
			LABEL: 32-bit
		ENCODING: REV_64_dp_1src
			OPERATION: REV
			SYNTAX: <Xd>,<Xn>
			BITDIFFS: sf == '1' && opc == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			integer container_size;
			case opc of
			    when '00'
			        Unreachable();
			    when '01'
			        container_size = 16;
			    when '10'
			        container_size = 32;
			    when '11'
			        if sf == '0' then UNDEFINED;
			        container_size = 64;

IFORM: REV16_advsimd
	TYPE: instruction
	XML: rev16_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|0000|o0=1|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV16_asimdmisc_R
			OPERATION: REV16
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			// size=esize:   B(0),  H(1),  S(1), D(S)
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			// op=REVx: 64(0), 32(1), 16(2)
			bits(2) op = o0:U;
			// => op+size:
			//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
			//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
			//    16+B = 2, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// => 3-(op+size) (index bits in group)
			//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
			//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
			//    16+B = 1, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// index bits within group: 1, 2, 3
			if UInt(op)+UInt(size) >= 3 then UNDEFINED;
			integer container_size;
			case op of
			    when '10' container_size = 16;
			    when '01' container_size = 32;
			    when '00' container_size = 64;
			integer containers = datasize DIV container_size;
			integer elements_per_container = container_size DIV esize;

IFORM: REV16_int
	TYPE: instruction
	XML: rev16_int.xml
	CLASS: general
		FIELDS32: sf=x|1|S=0|11010110|opcode2=00000|opcode[5:2]=0000|opc=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV16_32_dp_1src
			OPERATION: REV16
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: REV16_64_dp_1src
			OPERATION: REV16
			SYNTAX: <Xd>,<Xn>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			integer container_size;
			case opc of
			    when '00'
			        Unreachable();
			    when '01'
			        container_size = 16;
			    when '10'
			        container_size = 32;
			    when '11'
			        if sf == '0' then UNDEFINED;
			        container_size = 64;

IFORM: REV32_advsimd
	TYPE: instruction
	XML: rev32_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|0000|o0=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV32_asimdmisc_R
			OPERATION: REV32
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			// size=esize:   B(0),  H(1),  S(1), D(S)
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			// op=REVx: 64(0), 32(1), 16(2)
			bits(2) op = o0:U;
			// => op+size:
			//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
			//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
			//    16+B = 2, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// => 3-(op+size) (index bits in group)
			//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
			//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
			//    16+B = 1, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// index bits within group: 1, 2, 3
			if UInt(op)+UInt(size) >= 3 then UNDEFINED;
			integer container_size;
			case op of
			    when '10' container_size = 16;
			    when '01' container_size = 32;
			    when '00' container_size = 64;
			integer containers = datasize DIV container_size;
			integer elements_per_container = container_size DIV esize;

IFORM: REV32_int
	TYPE: instruction
	XML: rev32_int.xml
	CLASS: 64
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00000|opcode[5:2]=0000|opc=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV32_64_dp_1src
			OPERATION: REV32
			SYNTAX: <Xd>,<Xn>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			integer container_size;
			case opc of
			    when '00'
			        Unreachable();
			    when '01'
			        container_size = 16;
			    when '10'
			        container_size = 32;
			    when '11'
			        if sf == '0' then UNDEFINED;
			        container_size = 64;

IFORM: REV64_REV
	TYPE: alias
	XML: rev64_rev.xml
	CLASS: general
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00000|opcode[5:2]=0000|opc=11|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV64_REV_64_dp_1src
			OPERATION: REV64
			SYNTAX: <Xd>,<Xn>
			LABEL: 64-bit

IFORM: REV64_advsimd
	TYPE: instruction
	XML: rev64_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|0000|o0=0|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: REV64_asimdmisc_R
			OPERATION: REV64
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			// size=esize:   B(0),  H(1),  S(1), D(S)
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			// op=REVx: 64(0), 32(1), 16(2)
			bits(2) op = o0:U;
			// => op+size:
			//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
			//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
			//    16+B = 2, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// => 3-(op+size) (index bits in group)
			//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
			//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
			//    16+B = 1, 16+H = X, 16+S = X, 16+D = X
			//     8+B = X,  8+H = X,  8+S = X,  8+D = X
			// index bits within group: 1, 2, 3
			if UInt(op)+UInt(size) >= 3 then UNDEFINED;
			integer container_size;
			case op of
			    when '10' container_size = 16;
			    when '01' container_size = 32;
			    when '00' container_size = 64;
			integer containers = datasize DIV container_size;
			integer elements_per_container = container_size DIV esize;

IFORM: RMIF
	TYPE: instruction
	XML: rmif.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_FlagM
		FIELDS32: sf=1|op=0|S=1|11010000|imm6=xxxxxx|00001|Rn=xxxxx|o2=0|mask=xxxx
		ENCODING: RMIF_only_rmif
			OPERATION: RMIF
			SYNTAX: <Xn>, #<shift>, #<mask>
		DECODE_PCODE:
			if !HaveFlagManipulateExt() || sf != '1' then UNDEFINED;
			integer lsb = UInt(imm6);
			integer n = UInt(Rn);

IFORM: RORV
	TYPE: instruction
	XML: rorv.xml
	ALIAS: ROR_RORV
		Unconditionally
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=11|Rn=xxxxx|Rd=xxxxx
		ENCODING: RORV_32_dp_2src
			OPERATION: RORV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: RORV_64_dp_2src
			OPERATION: RORV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			ShiftType shift_type = DecodeShift(op2);

IFORM: ROR_EXTR
	TYPE: alias
	XML: ror_extr.xml
	CLASS: general
		FIELDS32: sf=x|op21=00|100111|N=x|o0=0|Rm=xxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: ROR_EXTR_32_extract
			OPERATION: ROR
			SYNTAX: <Wd>,<Ws>, #<shift>
			BITDIFFS: sf == '0' && N == '0' && imms == '0xxxxx'
			LABEL: 32-bit
		ENCODING: ROR_EXTR_64_extract
			OPERATION: ROR
			SYNTAX: <Xd>,<Xs>, #<shift>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: ROR_RORV
	TYPE: alias
	XML: ror_rorv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:2>=0010|op2=11|Rn=xxxxx|Rd=xxxxx
		ENCODING: ROR_RORV_32_dp_2src
			OPERATION: ROR
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: ROR_RORV_64_dp_2src
			OPERATION: ROR
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: RSHRN_advsimd
	TYPE: instruction
	XML: rshrn_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|1000|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: RSHRN_asimdshf_N
			OPERATION: RSHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');

IFORM: RSUBHN_advsimd
	TYPE: instruction
	XML: rsubhn_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|01|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: RSUBHN_asimddiff_N
			OPERATION: RSUBHN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>,<Vm>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean round = (U == '1');

IFORM: SABAL_advsimd
	TYPE: instruction
	XML: sabal_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|01|op=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SABAL_asimddiff_L
			OPERATION: SABAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean accumulate = (op == '0');
			boolean unsigned = (U == '1');

IFORM: SABA_advsimd
	TYPE: instruction
	XML: saba_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0111|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SABA_asimdsame_only
			OPERATION: SABA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean accumulate = (ac == '1');

IFORM: SABDL_advsimd
	TYPE: instruction
	XML: sabdl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|01|op=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SABDL_asimddiff_L
			OPERATION: SABDL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean accumulate = (op == '0');
			boolean unsigned = (U == '1');

IFORM: SABD_advsimd
	TYPE: instruction
	XML: sabd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0111|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SABD_asimdsame_only
			OPERATION: SABD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean accumulate = (ac == '1');

IFORM: SADALP_advsimd
	TYPE: instruction
	XML: sadalp_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|00|op=1|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SADALP_asimdmisc_P
			OPERATION: SADALP
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV (2*esize);
			boolean acc = (op == '1');
			boolean unsigned = (U == '1');

IFORM: SADDLP_advsimd
	TYPE: instruction
	XML: saddlp_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|00|op=0|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SADDLP_asimdmisc_P
			OPERATION: SADDLP
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV (2*esize);
			boolean acc = (op == '1');
			boolean unsigned = (U == '1');

IFORM: SADDLV_advsimd
	TYPE: instruction
	XML: saddlv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|11000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SADDLV_asimdall_only
			OPERATION: SADDLV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SADDL_advsimd
	TYPE: instruction
	XML: saddl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|00|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SADDL_asimddiff_L
			OPERATION: SADDL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: SADDW_advsimd
	TYPE: instruction
	XML: saddw_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|00|o1=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SADDW_asimddiff_W
			OPERATION: SADDW
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Ta>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: SB
	TYPE: instruction
	XML: sb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=(0)(0)(0)(0)|1|opc=11|Rt=11111
		ENCODING: SB_only_barriers
			OPERATION: SB
			SYNTAX: 
		DECODE_PCODE:
			if !HaveSBExt() then UNDEFINED;

IFORM: SBC
	TYPE: instruction
	XML: sbc.xml
	ALIAS: NGC_SBC
		Rn == '11111'
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|11010000|Rm=xxxxx|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: SBC_32_addsub_carry
			OPERATION: SBC
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SBC_64_addsub_carry
			OPERATION: SBC
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');

IFORM: SBCS
	TYPE: instruction
	XML: sbcs.xml
	ALIAS: NGCS_SBCS
		Rn == '11111'
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|11010000|Rm=xxxxx|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: SBCS_32_addsub_carry
			OPERATION: SBCS
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SBCS_64_addsub_carry
			OPERATION: SBCS
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');

IFORM: SBFIZ_SBFM
	TYPE: alias
	XML: sbfiz_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SBFIZ_SBFM_32M_bitfield
			OPERATION: SBFIZ
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: SBFIZ_SBFM_64M_bitfield
			OPERATION: SBFIZ
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: SBFM
	TYPE: instruction
	XML: sbfm.xml
	ALIAS: ASR_SBFM
		imms == '011111' && EncodingLabeled32Bit()
		imms == '111111' && EncodingLabeled64Bit()
	ALIAS: SBFIZ_SBFM
		UInt(imms) < UInt(immr)
	ALIAS: SBFX_SBFM
		BFXPreferred(sf, opc<1>, imms, immr)
	ALIAS: SXTB_SBFM
		immr == '000000' && imms == '000111'
	ALIAS: SXTH_SBFM
		immr == '000000' && imms == '001111'
	ALIAS: SXTW_SBFM
		immr == '000000' && imms == '011111'
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SBFM_32M_bitfield
			OPERATION: SBFM
			SYNTAX: <Wd>,<Wn>, #<immr>, #<imms>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: SBFM_64M_bitfield
			OPERATION: SBFM
			SYNTAX: <Xd>,<Xn>, #<immr>, #<imms>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean inzero;
			boolean extend;
			integer R;
			integer S;
			bits(datasize) wmask;
			bits(datasize) tmask;
			case opc of
			    when '00' inzero = TRUE;  extend = TRUE;    // SBFM
			    when '01' inzero = FALSE; extend = FALSE;   // BFM
			    when '10' inzero = TRUE;  extend = FALSE;   // UBFM
			    when '11' UNDEFINED;
			if sf == '1' && N != '1' then UNDEFINED;
			if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
			R = UInt(immr);
			S = UInt(imms);
			(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

IFORM: SBFX_SBFM
	TYPE: alias
	XML: sbfx_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SBFX_SBFM_32M_bitfield
			OPERATION: SBFX
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: SBFX_SBFM_64M_bitfield
			OPERATION: SBFX
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: SCVTF_advsimd_fix
	TYPE: instruction
	XML: scvtf_advsimd_fix.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|opcode=11100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asisdshf_C
			OPERATION: SCVTF
			SYNTAX: <V><d>,<V><n>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = esize;
			integer elements = 1;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|opcode=11100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asimdshf_C
			OPERATION: SCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRoundingMode(FPCR[]);

IFORM: SCVTF_advsimd_int
	TYPE: instruction
	XML: scvtf_advsimd_int.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=0|11110|a=0|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asisdmiscfp16_R
			OPERATION: SCVTF
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=0|11110|0|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asisdmisc_R
			OPERATION: SCVTF
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=0|01110|a=0|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asimdmiscfp16_R
			OPERATION: SCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=0|01110|0|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_asimdmisc_R
			OPERATION: SCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SCVTF_float_fix
	TYPE: instruction
	XML: scvtf_float_fix.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|0|rmode=00|opcode=010|scale=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_H32_float2fix
			OPERATION: SCVTF
			SYNTAX: <Hd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: SCVTF_S32_float2fix
			OPERATION: SCVTF
			SYNTAX: <Sd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: SCVTF_D32_float2fix
			OPERATION: SCVTF
			SYNTAX: <Dd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: SCVTF_H64_float2fix
			OPERATION: SCVTF
			SYNTAX: <Hd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: SCVTF_S64_float2fix
			OPERATION: SCVTF
			SYNTAX: <Sd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: SCVTF_D64_float2fix
			OPERATION: SCVTF
			SYNTAX: <Dd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			case ftype of
			    when '00' fltsize = 32;
			    when '01' fltsize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			if sf == '0' && scale<5> == '0' then UNDEFINED;
			integer fracbits = 64 - UInt(scale);
			case opcode<2:1>:rmode of
			    when '00 11'        // FCVTZ
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    otherwise
			        UNDEFINED;

IFORM: SCVTF_float_int
	TYPE: instruction
	XML: scvtf_float_int.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=010|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: SCVTF_H32_float2int
			OPERATION: SCVTF
			SYNTAX: <Hd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: SCVTF_S32_float2int
			OPERATION: SCVTF
			SYNTAX: <Sd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: SCVTF_D32_float2int
			OPERATION: SCVTF
			SYNTAX: <Dd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: SCVTF_H64_float2int
			OPERATION: SCVTF
			SYNTAX: <Hd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: SCVTF_S64_float2int
			OPERATION: SCVTF
			SYNTAX: <Sd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: SCVTF_D64_float2int
			OPERATION: SCVTF
			SYNTAX: <Dd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: SDIV
	TYPE: instruction
	XML: sdiv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:1>=00001|o1=1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SDIV_32_dp_2src
			OPERATION: SDIV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SDIV_64_dp_2src
			OPERATION: SDIV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean unsigned = (o1 == '0');

IFORM: SDOT_advsimd_elt
	TYPE: instruction
	XML: sdot_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_DotProd
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1110|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SDOT_asimdelem_D
			OPERATION: SDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.4B[<index>]
		DECODE_PCODE:
			if !HaveDOTPExt() then UNDEFINED;
			if size  != '10' then UNDEFINED;
			boolean signed = (U=='0');
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			integer index = UInt(H:L);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: SDOT_advsimd_vec
	TYPE: instruction
	XML: sdot_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_DotProd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|0|Rm=xxxxx|1|opcode=0010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SDOT_asimdsame2_D
			OPERATION: SDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveDOTPExt() then UNDEFINED;
			if size!= '10' then UNDEFINED;
			boolean signed = (U=='0');
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: SETF
	TYPE: instruction
	XML: setf.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_FlagM
		FIELDS32: sf=0|op=0|S=1|11010000|opcode2=000000|sz=x|0010|Rn=xxxxx|o3=0|mask=1101
		ENCODING: SETF8_only_setf
			OPERATION: SETF8
			SYNTAX: <Wn>
			BITDIFFS: sz == '0'
		ENCODING: SETF16_only_setf
			OPERATION: SETF16
			SYNTAX: <Wn>
			BITDIFFS: sz == '1'
		DECODE_PCODE:
			if !HaveFlagManipulateExt() || sf != '0' then UNDEFINED;
			integer msb = if sz=='1' then 15 else 7;
			integer n = UInt(Rn);

IFORM: SEV
	TYPE: instruction
	XML: sev.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=100|Rt=11111
		ENCODING: SEV_HI_hints
			OPERATION: SEV
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: SEVL
	TYPE: instruction
	XML: sevl.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=101|Rt=11111
		ENCODING: SEVL_HI_hints
			OPERATION: SEVL
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: SHA1C_advsimd
	TYPE: instruction
	XML: sha1c_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|opcode=000|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1C_QSV_cryptosha3
			OPERATION: SHA1C
			SYNTAX: <Qd>,<Sn>,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA1H_advsimd
	TYPE: instruction
	XML: sha1h_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|10100|opcode=00000|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1H_SS_cryptosha2
			OPERATION: SHA1H
			SYNTAX: <Sd>,<Sn>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA1M_advsimd
	TYPE: instruction
	XML: sha1m_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|opcode=010|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1M_QSV_cryptosha3
			OPERATION: SHA1M
			SYNTAX: <Qd>,<Sn>,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA1P_advsimd
	TYPE: instruction
	XML: sha1p_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|opcode=001|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1P_QSV_cryptosha3
			OPERATION: SHA1P
			SYNTAX: <Qd>,<Sn>,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA1SU0_advsimd
	TYPE: instruction
	XML: sha1su0_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|opcode=011|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1SU0_VVV_cryptosha3
			OPERATION: SHA1SU0
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA1SU1_advsimd
	TYPE: instruction
	XML: sha1su1_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|10100|opcode=00001|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA1SU1_VV_cryptosha2
			OPERATION: SHA1SU1
			SYNTAX: <Vd>.4S,<Vn>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveSHA1Ext() then UNDEFINED;

IFORM: SHA256H2_advsimd
	TYPE: instruction
	XML: sha256h2_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|10|P=1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA256H2_QQV_cryptosha3
			OPERATION: SHA256H2
			SYNTAX: <Qd>,<Qn>,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA256Ext() then UNDEFINED;
			boolean part1 = (P == '0');

IFORM: SHA256H_advsimd
	TYPE: instruction
	XML: sha256h_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|10|P=0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA256H_QQV_cryptosha3
			OPERATION: SHA256H
			SYNTAX: <Qd>,<Qn>,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA256Ext() then UNDEFINED;
			boolean part1 = (P == '0');

IFORM: SHA256SU0_advsimd
	TYPE: instruction
	XML: sha256su0_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|10100|opcode=00010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA256SU0_VV_cryptosha2
			OPERATION: SHA256SU0
			SYNTAX: <Vd>.4S,<Vn>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HaveSHA256Ext() then UNDEFINED;

IFORM: SHA256SU1_advsimd
	TYPE: instruction
	XML: sha256su1_advsimd.xml
	CLASS: advsimd
		FIELDS32: 01011110|size=00|0|Rm=xxxxx|0|opcode=110|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA256SU1_VVV_cryptosha3
			OPERATION: SHA256SU1
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if !HaveSHA256Ext() then UNDEFINED;

IFORM: SHA512H2_advsimd
	TYPE: instruction
	XML: sha512h2_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA512
		FIELDS32: 11001110011|Rm=xxxxx|1|O=0|00|opcode=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA512H2_QQV_cryptosha512_3
			OPERATION: SHA512H2
			SYNTAX: <Qd>,<Qn>,<Vm>.2D
		DECODE_PCODE:
			if !HaveSHA512Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SHA512H_advsimd
	TYPE: instruction
	XML: sha512h_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA512
		FIELDS32: 11001110011|Rm=xxxxx|1|O=0|00|opcode=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA512H_QQV_cryptosha512_3
			OPERATION: SHA512H
			SYNTAX: <Qd>,<Qn>,<Vm>.2D
		DECODE_PCODE:
			if !HaveSHA512Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SHA512SU0_advsimd
	TYPE: instruction
	XML: sha512su0_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA512
		FIELDS32: 11001110110000001000|opcode=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA512SU0_VV2_cryptosha512_2
			OPERATION: SHA512SU0
			SYNTAX: <Vd>.2D,<Vn>.2D
		DECODE_PCODE:
			if !HaveSHA512Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);

IFORM: SHA512SU1_advsimd
	TYPE: instruction
	XML: sha512su1_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA512
		FIELDS32: 11001110011|Rm=xxxxx|1|O=0|00|opcode=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHA512SU1_VVV2_cryptosha512_3
			OPERATION: SHA512SU1
			SYNTAX: <Vd>.2D,<Vn>.2D,<Vm>.2D
		DECODE_PCODE:
			if !HaveSHA512Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SHADD_advsimd
	TYPE: instruction
	XML: shadd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=00000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHADD_asimdsame_only
			OPERATION: SHADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SHLL_advsimd
	TYPE: instruction
	XML: shll_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=10011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHLL_asimdmisc_S
			OPERATION: SHLL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = esize;
			boolean unsigned = FALSE; // Or TRUE without change of functionality

IFORM: SHL_advsimd
	TYPE: instruction
	XML: shl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|opcode=01010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHL_asisdshf_R
			OPERATION: SHL
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = UInt(immh:immb) - esize;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|opcode=01010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHL_asimdshf_R
			OPERATION: SHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;

IFORM: SHRN_advsimd
	TYPE: instruction
	XML: shrn_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|1000|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHRN_asimdshf_N
			OPERATION: SHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');

IFORM: SHSUB_advsimd
	TYPE: instruction
	XML: shsub_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=00100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SHSUB_asimdsame_only
			OPERATION: SHSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SLI_advsimd
	TYPE: instruction
	XML: sli_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|opcode=01010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SLI_asisdshf_R
			OPERATION: SLI
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = UInt(immh:immb) - esize;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|opcode=01010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SLI_asimdshf_R
			OPERATION: SLI
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;

IFORM: SM3PARTW1_advsimd
	TYPE: instruction
	XML: sm3partw1_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110011|Rm=xxxxx|1|O=1|00|opcode=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3PARTW1_VVV4_cryptosha512_3
			OPERATION: SM3PARTW1
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SM3PARTW2_advsimd
	TYPE: instruction
	XML: sm3partw2_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110011|Rm=xxxxx|1|O=1|00|opcode=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3PARTW2_VVV4_cryptosha512_3
			OPERATION: SM3PARTW2
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SM3SS1_advsimd
	TYPE: instruction
	XML: sm3ss1_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 110011100|Op0=10|Rm=xxxxx|0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3SS1_VVV4_crypto4
			OPERATION: SM3SS1
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S,<Va>.4S
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);

IFORM: SM3TT1A_advsimd
	TYPE: instruction
	XML: sm3tt1a_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110010|Rm=xxxxx|10|imm2=xx|opcode=00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3TT1A_VVV4_crypto3_imm2
			OPERATION: SM3TT1A
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.S[<imm2>]
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer i = UInt(imm2);

IFORM: SM3TT1B_advsimd
	TYPE: instruction
	XML: sm3tt1b_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110010|Rm=xxxxx|10|imm2=xx|opcode=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3TT1B_VVV4_crypto3_imm2
			OPERATION: SM3TT1B
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.S[<imm2>]
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer i = UInt(imm2);

IFORM: SM3TT2A_advsimd
	TYPE: instruction
	XML: sm3tt2a_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110010|Rm=xxxxx|10|imm2=xx|opcode=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3TT2A_VVV4_crypto3_imm2
			OPERATION: SM3TT2A
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.S[<imm2>]
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer i = UInt(imm2);

IFORM: SM3TT2B_advsimd
	TYPE: instruction
	XML: sm3tt2b_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM3
		FIELDS32: 11001110010|Rm=xxxxx|10|imm2=xx|opcode=11|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM3TT2B_VVV_crypto3_imm2
			OPERATION: SM3TT2B
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.S[<imm2>]
		DECODE_PCODE:
			if !HaveSM3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer i = UInt(imm2);

IFORM: SM4EKEY_advsimd
	TYPE: instruction
	XML: sm4ekey_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM4
		FIELDS32: 11001110011|Rm=xxxxx|1|O=1|00|opcode=10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM4EKEY_VVV4_cryptosha512_3
			OPERATION: SM4EKEY
			SYNTAX: <Vd>.4S,<Vn>.4S,<Vm>.4S
		DECODE_PCODE:
			if !HaveSM4Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: SM4E_advsimd
	TYPE: instruction
	XML: sm4e_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SM4
		FIELDS32: 11001110110000001000|opcode=01|Rn=xxxxx|Rd=xxxxx
		ENCODING: SM4E_VV4_cryptosha512_2
			OPERATION: SM4E
			SYNTAX: <Vd>.4S,<Vn>.4S
		DECODE_PCODE:
			if !HaveSM4Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);

IFORM: SMADDL
	TYPE: instruction
	XML: smaddl.xml
	ALIAS: SMULL_SMADDL
		Ra == '11111'
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=0|01|Rm=xxxxx|o0=0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMADDL_64WA_dp_3src
			OPERATION: SMADDL
			SYNTAX: <Xd>,<Wn>,<Wm>,<Xa>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = 64;
			integer datasize = 32;
			boolean sub_op = (o0 == '1');
			boolean unsigned = (U == '1');

IFORM: SMAXP_advsimd
	TYPE: instruction
	XML: smaxp_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|1010|o1=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMAXP_asimdsame_only
			OPERATION: SMAXP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: SMAXV_advsimd
	TYPE: instruction
	XML: smaxv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|11000|op=0|1010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMAXV_asimdall_only
			OPERATION: SMAXV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean min = (op == '1');

IFORM: SMAX_advsimd
	TYPE: instruction
	XML: smax_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0110|o1=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMAX_asimdsame_only
			OPERATION: SMAX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: SMC
	TYPE: instruction
	XML: smc.xml
	CLASS: system
		FIELDS32: 11010100|opc=000|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=11
		ENCODING: SMC_EX_exception
			OPERATION: SMC
			SYNTAX: #<imm>

IFORM: SMINP_advsimd
	TYPE: instruction
	XML: sminp_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|1010|o1=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMINP_asimdsame_only
			OPERATION: SMINP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: SMINV_advsimd
	TYPE: instruction
	XML: sminv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|11000|op=1|1010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMINV_asimdall_only
			OPERATION: SMINV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean min = (op == '1');

IFORM: SMIN_advsimd
	TYPE: instruction
	XML: smin_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|0110|o1=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMIN_asimdsame_only
			OPERATION: SMIN
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: SMLAL_advsimd_elt
	TYPE: instruction
	XML: smlal_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=0|10|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMLAL_asimdelem_L
			OPERATION: SMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean sub_op = (o2 == '1');

IFORM: SMLAL_advsimd_vec
	TYPE: instruction
	XML: smlal_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|10|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMLAL_asimddiff_L
			OPERATION: SMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: SMLSL_advsimd_elt
	TYPE: instruction
	XML: smlsl_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=1|10|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMLSL_asimdelem_L
			OPERATION: SMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean sub_op = (o2 == '1');

IFORM: SMLSL_advsimd_vec
	TYPE: instruction
	XML: smlsl_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|10|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMLSL_asimddiff_L
			OPERATION: SMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: SMMLA_advsimd_vec
	TYPE: instruction
	XML: smmla_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=1|U=0|01110|size=10|0|Rm=xxxxx|1|010|B=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMMLA_asimdsame2_G
			OPERATION: SMMLA
			SYNTAX: <Vd>.4S,<Vn>.16B,<Vm>.16B
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			case B:U of
			    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
			    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
			    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
			    when '11' UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);

IFORM: SMNEGL_SMSUBL
	TYPE: alias
	XML: smnegl_smsubl.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=0|01|Rm=xxxxx|o0=1|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMNEGL_SMSUBL_64WA_dp_3src
			OPERATION: SMNEGL
			SYNTAX: <Xd>,<Wn>,<Wm>

IFORM: SMOV_advsimd
	TYPE: instruction
	XML: smov_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=0|01110000|imm5=xxxxx|0|imm4<3:2>=01|imm4=01|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMOV_asimdins_W_w
			OPERATION: SMOV
			SYNTAX: <Wd>,<Vn>.<Ts>[<index>]
			BITDIFFS: Q == '0'
			LABEL: 32-bit
		ENCODING: SMOV_asimdins_X_x
			OPERATION: SMOV
			SYNTAX: <Xd>,<Vn>.<Ts>[<index>]
			BITDIFFS: Q == '1'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size;
			case Q:imm5 of
			    when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B
			    when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H
			    when '1xx100' size = 2;     // SMOV Xd, Vn.S
			    otherwise     UNDEFINED;
			integer idxdsize = if imm5<4> == '1' then 128 else 64;
			integer index = UInt(imm5<4:size+1>);
			integer esize = 8 << size;
			integer datasize = if Q == '1' then 64 else 32;

IFORM: SMSUBL
	TYPE: instruction
	XML: smsubl.xml
	ALIAS: SMNEGL_SMSUBL
		Ra == '11111'
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=0|01|Rm=xxxxx|o0=1|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMSUBL_64WA_dp_3src
			OPERATION: SMSUBL
			SYNTAX: <Xd>,<Wn>,<Wm>,<Xa>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = 64;
			integer datasize = 32;
			boolean sub_op = (o0 == '1');
			boolean unsigned = (U == '1');

IFORM: SMULH
	TYPE: instruction
	XML: smulh.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=0|10|Rm=xxxxx|o0=0|Ra=(1)(1)(1)(1)(1)|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMULH_64_dp_3src
			OPERATION: SMULH
			SYNTAX: <Xd>,<Xn>,<Xm>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);           // ignored by UMULH/SMULH
			integer destsize = 64;
			integer datasize = destsize;
			boolean unsigned = (U == '1');

IFORM: SMULL_SMADDL
	TYPE: alias
	XML: smull_smaddl.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=0|01|Rm=xxxxx|o0=0|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMULL_SMADDL_64WA_dp_3src
			OPERATION: SMULL
			SYNTAX: <Xd>,<Wn>,<Wm>

IFORM: SMULL_advsimd_elt
	TYPE: instruction
	XML: smull_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1010|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMULL_asimdelem_L
			OPERATION: SMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SMULL_advsimd_vec
	TYPE: instruction
	XML: smull_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=1100|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SMULL_asimddiff_L
			OPERATION: SMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SQABS_advsimd
	TYPE: instruction
	XML: sqabs_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|opcode=00111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQABS_asisdmisc_R
			OPERATION: SQABS
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean neg = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=00111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQABS_asimdmisc_R
			OPERATION: SQABS
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: SQADD_advsimd
	TYPE: instruction
	XML: sqadd_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=00001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQADD_asisdsame_only
			OPERATION: SQADD
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=00001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQADD_asimdsame_only
			OPERATION: SQADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SQDMLAL_advsimd_elt
	TYPE: instruction
	XML: sqdmlal_advsimd_elt.xml
	CLASS: 2reg_scalar
		FIELDS32: 01|U=0|11111|size=xx|L=x|M=x|Rm=xxxx|0|o2=0|11|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLAL_asisdelem_L
			OPERATION: SQDMLAL
			SYNTAX: <Va><d>,<Vb><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=0|11|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLAL_asimdelem_L
			OPERATION: SQDMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: SQDMLAL_advsimd_vec
	TYPE: instruction
	XML: sqdmlal_advsimd_vec.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|10|o1=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLAL_asisddiff_only
			OPERATION: SQDMLAL
			SYNTAX: <Va><d>,<Vb><n>,<Vb><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			boolean sub_op = (o1 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|10|o1=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLAL_asimddiff_L
			OPERATION: SQDMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');

IFORM: SQDMLSL_advsimd_elt
	TYPE: instruction
	XML: sqdmlsl_advsimd_elt.xml
	CLASS: 2reg_scalar
		FIELDS32: 01|U=0|11111|size=xx|L=x|M=x|Rm=xxxx|0|o2=1|11|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLSL_asisdelem_L
			OPERATION: SQDMLSL
			SYNTAX: <Va><d>,<Vb><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			boolean sub_op = (o2 == '1');
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=1|11|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLSL_asimdelem_L
			OPERATION: SQDMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o2 == '1');

IFORM: SQDMLSL_advsimd_vec
	TYPE: instruction
	XML: sqdmlsl_advsimd_vec.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|10|o1=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLSL_asisddiff_only
			OPERATION: SQDMLSL
			SYNTAX: <Va><d>,<Vb><n>,<Vb><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			boolean sub_op = (o1 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|10|o1=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMLSL_asimddiff_L
			OPERATION: SQDMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');

IFORM: SQDMULH_advsimd_elt
	TYPE: instruction
	XML: sqdmulh_advsimd_elt.xml
	CLASS: 2reg_scalar
		FIELDS32: 01|U=0|11111|size=xx|L=x|M=x|Rm=xxxx|110|op=0|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULH_asisdelem_R
			OPERATION: SQDMULH
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean round = (op == '1');
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|110|op=0|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULH_asimdelem_R
			OPERATION: SQDMULH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean round = (op == '1');

IFORM: SQDMULH_advsimd_vec
	TYPE: instruction
	XML: sqdmulh_advsimd_vec.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=10110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULH_asisdsame_only
			OPERATION: SQDMULH
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=10110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULH_asimdsame_only
			OPERATION: SQDMULH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = (U == '1');

IFORM: SQDMULL_advsimd_elt
	TYPE: instruction
	XML: sqdmull_advsimd_elt.xml
	CLASS: 2reg_scalar
		FIELDS32: 01|U=0|11111|size=xx|L=x|M=x|Rm=xxxx|opcode=1011|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULL_asisdelem_L
			OPERATION: SQDMULL
			SYNTAX: <Va><d>,<Vb><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1011|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULL_asimdelem_L
			OPERATION: SQDMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: SQDMULL_advsimd_vec
	TYPE: instruction
	XML: sqdmull_advsimd_vec.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=1101|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULL_asisddiff_only
			OPERATION: SQDMULL
			SYNTAX: <Va><d>,<Vb><n>,<Vb><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=1101|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQDMULL_asimddiff_L
			OPERATION: SQDMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '00' || size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: SQNEG_advsimd
	TYPE: instruction
	XML: sqneg_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|opcode=00111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQNEG_asisdmisc_R
			OPERATION: SQNEG
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean neg = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=00111|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQNEG_asimdmisc_R
			OPERATION: SQNEG
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean neg = (U == '1');

IFORM: SQRDMLAH_advsimd_elt
	TYPE: instruction
	XML: sqrdmlah_advsimd_elt.xml
	CLASS: 2reg_scalar
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 01|U=1|11111|size=xx|L=x|M=x|Rm=xxxx|11|S=0|1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLAH_asisdelem_R
			OPERATION: SQRDMLAH
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = TRUE;
			boolean sub_op = (S  == '1');
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|11|S=0|1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLAH_asimdelem_R
			OPERATION: SQRDMLAH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = TRUE;
			boolean sub_op = (S  == '1');

IFORM: SQRDMLAH_advsimd_vec
	TYPE: instruction
	XML: sqrdmlah_advsimd_vec.xml
	CLASS: sisd
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 01|U=1|11110|size=xx|0|Rm=xxxxx|1|000|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLAH_asisdsame2_only
			OPERATION: SQRDMLAH
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = TRUE;
			boolean sub_op = (S == '1');
	CLASS: simd
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 0|Q=x|U=1|01110|size=xx|0|Rm=xxxxx|1|000|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLAH_asimdsame2_only
			OPERATION: SQRDMLAH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = TRUE;
			boolean sub_op = (S == '1');

IFORM: SQRDMLSH_advsimd_elt
	TYPE: instruction
	XML: sqrdmlsh_advsimd_elt.xml
	CLASS: 2reg_scalar
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 01|U=1|11111|size=xx|L=x|M=x|Rm=xxxx|11|S=1|1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLSH_asisdelem_R
			OPERATION: SQRDMLSH
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = TRUE;
			boolean sub_op = (S  == '1');
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|11|S=1|1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLSH_asimdelem_R
			OPERATION: SQRDMLSH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = TRUE;
			boolean sub_op = (S  == '1');

IFORM: SQRDMLSH_advsimd_vec
	TYPE: instruction
	XML: sqrdmlsh_advsimd_vec.xml
	CLASS: sisd
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 01|U=1|11110|size=xx|0|Rm=xxxxx|1|000|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLSH_asisdsame2_only
			OPERATION: SQRDMLSH
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = TRUE;
			boolean sub_op = (S == '1');
	CLASS: simd
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_RDM
		FIELDS32: 0|Q=x|U=1|01110|size=xx|0|Rm=xxxxx|1|000|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMLSH_asimdsame2_only
			OPERATION: SQRDMLSH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			if !HaveQRDMLAHExt() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = TRUE;
			boolean sub_op = (S == '1');

IFORM: SQRDMULH_advsimd_elt
	TYPE: instruction
	XML: sqrdmulh_advsimd_elt.xml
	CLASS: 2reg_scalar
		FIELDS32: 01|U=0|11111|size=xx|L=x|M=x|Rm=xxxx|110|op=1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMULH_asisdelem_R
			OPERATION: SQRDMULH
			SYNTAX: <V><d>,<V><n>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean round = (op == '1');
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=0|01111|size=xx|L=x|M=x|Rm=xxxx|110|op=1|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMULH_asimdelem_R
			OPERATION: SQRDMULH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean round = (op == '1');

IFORM: SQRDMULH_advsimd_vec
	TYPE: instruction
	XML: sqrdmulh_advsimd_vec.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|opcode=10110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMULH_asisdsame_only
			OPERATION: SQRDMULH
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean rounding = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=10110|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRDMULH_asimdsame_only
			OPERATION: SQRDMULH
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' || size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean rounding = (U == '1');

IFORM: SQRSHL_advsimd
	TYPE: instruction
	XML: sqrshl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|010|R=1|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHL_asisdsame_only
			OPERATION: SQRSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|010|R=1|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHL_asimdsame_only
			OPERATION: SQRSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: SQRSHRN_advsimd
	TYPE: instruction
	XML: sqrshrn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|1001|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHRN_asisdshf_N
			OPERATION: SQRSHRN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|1001|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHRN_asimdshf_N
			OPERATION: SQRSHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');

IFORM: SQRSHRUN_advsimd
	TYPE: instruction
	XML: sqrshrun_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|1000|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHRUN_asisdshf_N
			OPERATION: SQRSHRUN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|1000|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQRSHRUN_asimdshf_N
			OPERATION: SQRSHRUN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');

IFORM: SQSHLU_advsimd
	TYPE: instruction
	XML: sqshlu_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|011|op=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHLU_asisdshf_R
			OPERATION: SQSHLU
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|011|op=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHLU_asimdshf_R
			OPERATION: SQSHLU
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

IFORM: SQSHL_advsimd_imm
	TYPE: instruction
	XML: sqshl_advsimd_imm.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|011|op=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHL_asisdshf_R
			OPERATION: SQSHL
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|011|op=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHL_asimdshf_R
			OPERATION: SQSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

IFORM: SQSHL_advsimd_reg
	TYPE: instruction
	XML: sqshl_advsimd_reg.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|010|R=0|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHL_asisdsame_only
			OPERATION: SQSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|010|R=0|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHL_asimdsame_only
			OPERATION: SQSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: SQSHRN_advsimd
	TYPE: instruction
	XML: sqshrn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|1001|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHRN_asisdshf_N
			OPERATION: SQSHRN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|1001|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHRN_asimdshf_N
			OPERATION: SQSHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');

IFORM: SQSHRUN_advsimd
	TYPE: instruction
	XML: sqshrun_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|1000|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHRUN_asisdshf_N
			OPERATION: SQSHRUN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|1000|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSHRUN_asimdshf_N
			OPERATION: SQSHRUN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');

IFORM: SQSUB_advsimd
	TYPE: instruction
	XML: sqsub_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|opcode=00101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSUB_asisdsame_only
			OPERATION: SQSUB
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=00101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQSUB_asimdsame_only
			OPERATION: SQSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SQXTN_advsimd
	TYPE: instruction
	XML: sqxtn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|opcode=10100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQXTN_asisdmisc_N
			OPERATION: SQXTN
			SYNTAX: <Vb><d>,<Va><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer part = 0;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=10100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQXTN_asimdmisc_N
			OPERATION: SQXTN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SQXTUN_advsimd
	TYPE: instruction
	XML: sqxtun_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|opcode=10010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQXTUN_asisdmisc_N
			OPERATION: SQXTUN
			SYNTAX: <Vb><d>,<Va><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer part = 0;
			integer elements = 1;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=10010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SQXTUN_asimdmisc_N
			OPERATION: SQXTUN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: SRHADD_advsimd
	TYPE: instruction
	XML: srhadd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|opcode=00010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRHADD_asimdsame_only
			OPERATION: SRHADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SRI_advsimd
	TYPE: instruction
	XML: sri_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|opcode=01000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRI_asisdshf_R
			OPERATION: SRI
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|opcode=01000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRI_asimdshf_R
			OPERATION: SRI
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);

IFORM: SRSHL_advsimd
	TYPE: instruction
	XML: srshl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|010|R=1|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSHL_asisdsame_only
			OPERATION: SRSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|010|R=1|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSHL_asimdsame_only
			OPERATION: SRSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: SRSHR_advsimd
	TYPE: instruction
	XML: srshr_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|00|o1=1|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSHR_asisdshf_R
			OPERATION: SRSHR
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|00|o1=1|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSHR_asimdshf_R
			OPERATION: SRSHR
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: SRSRA_advsimd
	TYPE: instruction
	XML: srsra_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|00|o1=1|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSRA_asisdshf_R
			OPERATION: SRSRA
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|00|o1=1|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SRSRA_asimdshf_R
			OPERATION: SRSRA
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: SSBB
	TYPE: instruction
	XML: ssbb.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0011|CRm=0000|1|opc=00|Rt=11111
		ENCODING: SSBB_only_barriers
			OPERATION: SSBB
			SYNTAX: 

IFORM: SSHLL_advsimd
	TYPE: instruction
	XML: sshll_advsimd.xml
	ALIAS: SXTL_SSHLL_advsimd
		immb == '000' && BitCount(immh) == 1
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|opcode=10100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSHLL_asimdshf_L
			OPERATION: SSHLL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;
			boolean unsigned = (U == '1');

IFORM: SSHL_advsimd
	TYPE: instruction
	XML: sshl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|1|Rm=xxxxx|010|R=0|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSHL_asisdsame_only
			OPERATION: SSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|010|R=0|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSHL_asimdsame_only
			OPERATION: SSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: SSHR_advsimd
	TYPE: instruction
	XML: sshr_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|00|o1=0|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSHR_asisdshf_R
			OPERATION: SSHR
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|00|o1=0|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSHR_asimdshf_R
			OPERATION: SSHR
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: SSRA_advsimd
	TYPE: instruction
	XML: ssra_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|111110|immh!=0000|immb=xxx|00|o1=0|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSRA_asisdshf_R
			OPERATION: SSRA
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=xxx|00|o1=0|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSRA_asimdshf_R
			OPERATION: SSRA
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: SSUBL_advsimd
	TYPE: instruction
	XML: ssubl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|00|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSUBL_asimddiff_L
			OPERATION: SSUBL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: SSUBW_advsimd
	TYPE: instruction
	XML: ssubw_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|00|o1=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SSUBW_asimddiff_W
			OPERATION: SSUBW
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Ta>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: ST1_advsimd_mult
	TYPE: instruction
	XML: st1_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=0|000000|opcode=xx1x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST1_asisdlse_R1_1v
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0111'
		ENCODING: ST1_asisdlse_R2_2v
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '1010'
		ENCODING: ST1_asisdlse_R3_3v
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0110'
		ENCODING: ST1_asisdlse_R4_4v
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>]
			BITDIFFS: opcode == '0010'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=0|0|Rm=xxxxx|opcode=xx1x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST1_asisdlsep_I1_i1
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0111'
		ENCODING: ST1_asisdlsep_R1_r1
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0111'
		ENCODING: ST1_asisdlsep_I2_i2
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '1010'
		ENCODING: ST1_asisdlsep_R2_r2
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '1010'
		ENCODING: ST1_asisdlsep_I3_i3
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0110'
		ENCODING: ST1_asisdlsep_R3_r3
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0110'
		ENCODING: ST1_asisdlsep_I4_i4
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111' && opcode == '0010'
		ENCODING: ST1_asisdlsep_R4_r4
			OPERATION: ST1
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '0010'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: ST1_advsimd_sngl
	TYPE: instruction
	XML: st1_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=0|R=0|00000|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST1_asisdlso_B1_1b
			OPERATION: ST1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '000'
		ENCODING: ST1_asisdlso_H1_1h
			OPERATION: ST1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '010' && size == 'x0'
		ENCODING: ST1_asisdlso_S1_1s
			OPERATION: ST1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && size == '00'
			LABEL: 32-bit
		ENCODING: ST1_asisdlso_D1_1d
			OPERATION: ST1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=0|R=0|Rm=xxxxx|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST1_asisdlsop_B1_i1b
			OPERATION: ST1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>], #1
			BITDIFFS: Rm == '11111' && opcode == '000'
		ENCODING: ST1_asisdlsop_BX1_r1b
			OPERATION: ST1
			SYNTAX: {<Vt>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '000'
		ENCODING: ST1_asisdlsop_H1_i1h
			OPERATION: ST1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>], #2
			BITDIFFS: Rm == '11111' && opcode == '010' && size == 'x0'
		ENCODING: ST1_asisdlsop_HX1_r1h
			OPERATION: ST1
			SYNTAX: {<Vt>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '010' && size == 'x0'
		ENCODING: ST1_asisdlsop_S1_i1s
			OPERATION: ST1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '100' && size == '00'
		ENCODING: ST1_asisdlsop_SX1_r1s
			OPERATION: ST1
			SYNTAX: {<Vt>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && size == '00'
		ENCODING: ST1_asisdlsop_D1_i1d
			OPERATION: ST1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '100' && S == '0' && size == '01'
		ENCODING: ST1_asisdlsop_DX1_r1d
			OPERATION: ST1
			SYNTAX: {<Vt>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: ST2G
	TYPE: instruction
	XML: st2g.xml
	CLASS: post_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=10|1|imm9=xxxxxxxxx|op2=01|Xn=xxxxx|Xt=xxxxx
		ENCODING: ST2G_64Spost_ldsttags
			OPERATION: ST2G
			SYNTAX: <Xt|SP>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = TRUE;
			boolean zero_data = FALSE;
	CLASS: pre_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=10|1|imm9=xxxxxxxxx|op2=11|Xn=xxxxx|Xt=xxxxx
		ENCODING: ST2G_64Spre_ldsttags
			OPERATION: ST2G
			SYNTAX: <Xt|SP>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = FALSE;
			boolean zero_data = FALSE;
	CLASS: signed_scaled_offset
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=10|1|imm9=xxxxxxxxx|op2=10|Xn=xxxxx|Xt=xxxxx
		ENCODING: ST2G_64Soffset_ldsttags
			OPERATION: ST2G
			SYNTAX: <Xt|SP>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = FALSE;
			boolean postindex = FALSE;
			boolean zero_data = FALSE;

IFORM: ST2_advsimd_mult
	TYPE: instruction
	XML: st2_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=0|000000|opcode=1000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST2_asisdlse_R2
			OPERATION: ST2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=0|0|Rm=xxxxx|opcode=1000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST2_asisdlsep_I2_i
			OPERATION: ST2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: ST2_asisdlsep_R2_r
			OPERATION: ST2
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: ST2_advsimd_sngl
	TYPE: instruction
	XML: st2_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=0|R=1|00000|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST2_asisdlso_B2_2b
			OPERATION: ST2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '000'
		ENCODING: ST2_asisdlso_H2_2h
			OPERATION: ST2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '010' && size == 'x0'
		ENCODING: ST2_asisdlso_S2_2s
			OPERATION: ST2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && size == '00'
			LABEL: 32-bit
		ENCODING: ST2_asisdlso_D2_2d
			OPERATION: ST2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '100' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=0|R=1|Rm=xxxxx|opcode=xx0|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST2_asisdlsop_B2_i2b
			OPERATION: ST2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>], #2
			BITDIFFS: Rm == '11111' && opcode == '000'
		ENCODING: ST2_asisdlsop_BX2_r2b
			OPERATION: ST2
			SYNTAX: {<Vt>.B,<Vt2>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '000'
		ENCODING: ST2_asisdlsop_H2_i2h
			OPERATION: ST2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '010' && size == 'x0'
		ENCODING: ST2_asisdlsop_HX2_r2h
			OPERATION: ST2
			SYNTAX: {<Vt>.H,<Vt2>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '010' && size == 'x0'
		ENCODING: ST2_asisdlsop_S2_i2s
			OPERATION: ST2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '100' && size == '00'
		ENCODING: ST2_asisdlsop_SX2_r2s
			OPERATION: ST2
			SYNTAX: {<Vt>.S,<Vt2>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && size == '00'
		ENCODING: ST2_asisdlsop_D2_i2d
			OPERATION: ST2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>], #16
			BITDIFFS: Rm == '11111' && opcode == '100' && S == '0' && size == '01'
		ENCODING: ST2_asisdlsop_DX2_r2d
			OPERATION: ST2
			SYNTAX: {<Vt>.D,<Vt2>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '100' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: ST3_advsimd_mult
	TYPE: instruction
	XML: st3_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=0|000000|opcode=0100|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST3_asisdlse_R3
			OPERATION: ST3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=0|0|Rm=xxxxx|opcode=0100|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST3_asisdlsep_I3_i
			OPERATION: ST3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: ST3_asisdlsep_R3_r
			OPERATION: ST3
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: ST3_advsimd_sngl
	TYPE: instruction
	XML: st3_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=0|R=0|00000|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST3_asisdlso_B3_3b
			OPERATION: ST3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '001'
		ENCODING: ST3_asisdlso_H3_3h
			OPERATION: ST3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '011' && size == 'x0'
		ENCODING: ST3_asisdlso_S3_3s
			OPERATION: ST3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && size == '00'
			LABEL: 32-bit
		ENCODING: ST3_asisdlso_D3_3d
			OPERATION: ST3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=0|R=0|Rm=xxxxx|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST3_asisdlsop_B3_i3b
			OPERATION: ST3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>], #3
			BITDIFFS: Rm == '11111' && opcode == '001'
		ENCODING: ST3_asisdlsop_BX3_r3b
			OPERATION: ST3
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '001'
		ENCODING: ST3_asisdlsop_H3_i3h
			OPERATION: ST3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>], #6
			BITDIFFS: Rm == '11111' && opcode == '011' && size == 'x0'
		ENCODING: ST3_asisdlsop_HX3_r3h
			OPERATION: ST3
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '011' && size == 'x0'
		ENCODING: ST3_asisdlsop_S3_i3s
			OPERATION: ST3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>], #12
			BITDIFFS: Rm == '11111' && opcode == '101' && size == '00'
		ENCODING: ST3_asisdlsop_SX3_r3s
			OPERATION: ST3
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && size == '00'
		ENCODING: ST3_asisdlsop_D3_i3d
			OPERATION: ST3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>], #24
			BITDIFFS: Rm == '11111' && opcode == '101' && S == '0' && size == '01'
		ENCODING: ST3_asisdlsop_DX3_r3d
			OPERATION: ST3
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: ST4_advsimd_mult
	TYPE: instruction
	XML: st4_advsimd_mult.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011000|L=0|000000|opcode=0000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST4_asisdlse_R4
			OPERATION: ST4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>]
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011001|L=0|0|Rm=xxxxx|opcode=0000|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST4_asisdlsep_I4_i
			OPERATION: ST4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<imm>
			BITDIFFS: Rm == '11111'
		ENCODING: ST4_asisdlsep_R4_r
			OPERATION: ST4
			SYNTAX: {<Vt>.<T>,<Vt2>.<T>,<Vt3>.<T>,<Vt4>.<T>}, [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << UInt(size);
		integer elements = datasize DIV esize;
		integer rpt;    // number of iterations
		integer selem;  // structure elements
		case opcode of
		    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
		    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
		    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
		    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
		    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
		    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
		    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
		    otherwise UNDEFINED;
		// .1D format only permitted with LD1 & ST1
		if size:Q == '110' && selem != 1 then UNDEFINED;

IFORM: ST4_advsimd_sngl
	TYPE: instruction
	XML: st4_advsimd_sngl.xml
	CLASS: as_no_post_index
		FIELDS32: 0|Q=x|0011010|L=0|R=1|00000|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST4_asisdlso_B4_4b
			OPERATION: ST4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '001'
		ENCODING: ST4_asisdlso_H4_4h
			OPERATION: ST4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '011' && size == 'x0'
		ENCODING: ST4_asisdlso_S4_4s
			OPERATION: ST4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && size == '00'
			LABEL: 32-bit
		ENCODING: ST4_asisdlso_D4_4d
			OPERATION: ST4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>]
			BITDIFFS: opcode == '101' && S == '0' && size == '01'
			LABEL: 64-bit
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = integer UNKNOWN;
			boolean wback = FALSE;
			boolean tag_checked = wback || n != 31;
	CLASS: as_post_index
		FIELDS32: 0|Q=x|0011011|L=0|R=1|Rm=xxxxx|opcode=xx1|S=x|size=xx|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST4_asisdlsop_B4_i4b
			OPERATION: ST4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>], #4
			BITDIFFS: Rm == '11111' && opcode == '001'
		ENCODING: ST4_asisdlsop_BX4_r4b
			OPERATION: ST4
			SYNTAX: {<Vt>.B,<Vt2>.B,<Vt3>.B,<Vt4>.B}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '001'
		ENCODING: ST4_asisdlsop_H4_i4h
			OPERATION: ST4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>], #8
			BITDIFFS: Rm == '11111' && opcode == '011' && size == 'x0'
		ENCODING: ST4_asisdlsop_HX4_r4h
			OPERATION: ST4
			SYNTAX: {<Vt>.H,<Vt2>.H,<Vt3>.H,<Vt4>.H}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '011' && size == 'x0'
		ENCODING: ST4_asisdlsop_S4_i4s
			OPERATION: ST4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>], #16
			BITDIFFS: Rm == '11111' && opcode == '101' && size == '00'
		ENCODING: ST4_asisdlsop_SX4_r4s
			OPERATION: ST4
			SYNTAX: {<Vt>.S,<Vt2>.S,<Vt3>.S,<Vt4>.S}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && size == '00'
		ENCODING: ST4_asisdlsop_D4_i4d
			OPERATION: ST4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>], #32
			BITDIFFS: Rm == '11111' && opcode == '101' && S == '0' && size == '01'
		ENCODING: ST4_asisdlsop_DX4_r4d
			OPERATION: ST4
			SYNTAX: {<Vt>.D,<Vt2>.D,<Vt3>.D,<Vt4>.D}[<index>], [<Xn|SP>],<Xm>
			BITDIFFS: Rm != '11111' && opcode == '101' && S == '0' && size == '01'
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			boolean wback = TRUE;
			boolean tag_checked = wback || n != 31;
	POSTDECODE_PCODE:
		integer init_scale = UInt(opcode<2:1>);
		integer scale = init_scale;
		integer selem = UInt(opcode<0>:R) + 1;
		boolean replicate = FALSE;
		integer index;
		case scale of
		    when 3
		        // load and replicate
		        if L == '0' || S == '1' then UNDEFINED;
		        scale = UInt(size);
		        replicate = TRUE;
		    when 0
		        index = UInt(Q:S:size);         // B[0-15]
		    when 1
		        if size<0> == '1' then UNDEFINED;
		        index = UInt(Q:S:size<1>);      // H[0-7]
		    when 2
		        if size<1> == '1' then UNDEFINED;
		        if size<0> == '0' then
		            index = UInt(Q:S);          // S[0-3]
		        else
		            if S == '1' then UNDEFINED;
		            index = UInt(Q);            // D[0-1]
		            scale = 3;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = if Q == '1' then 128 else 64;
		integer esize = 8 << scale;

IFORM: ST64B
	TYPE: instruction
	XML: st64b.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_LS64
		FIELDS32: size=11|111|V=0|00|A=0|R=0|1|Rs=11111|o3=1|opc=001|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST64B_64L_memop
			OPERATION: ST64B
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			if !HaveFeatLS64() then UNDEFINED;
			if Rt<4:3> == '11' || Rt<0> == '1' then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			boolean tag_checked = n != 31;

IFORM: ST64BV
	TYPE: instruction
	XML: st64bv.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_LS64_V
		FIELDS32: size=11|111|V=0|00|A=0|R=0|1|Rs=xxxxx|o3=1|opc=011|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST64BV_64_memop
			OPERATION: ST64BV
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
		DECODE_PCODE:
			if !HaveFeatLS64() then UNDEFINED;
			if Rt<4:3> == '11' || Rt<0> == '1' then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			boolean tag_checked = n != 31;

IFORM: ST64BV0
	TYPE: instruction
	XML: st64bv0.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_LS64_V
		FIELDS32: size=11|111|V=0|00|A=0|R=0|1|Rs=xxxxx|o3=1|opc=010|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: ST64BV0_64_memop
			OPERATION: ST64BV0
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
		DECODE_PCODE:
			if !HaveFeatLS64() then UNDEFINED;
			if Rt<4:3> == '11' || Rt<0> == '1' then UNDEFINED;
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer s = UInt(Rs);
			boolean tag_checked = n != 31;

IFORM: STADDB_LDADDB
	TYPE: alias
	XML: staddb_ldaddb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=11111
		ENCODING: STADDB_LDADDB_32_memop
			OPERATION: STADDB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STADDLB_LDADDLB_32_memop
			OPERATION: STADDLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STADDH_LDADDH
	TYPE: alias
	XML: staddh_ldaddh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=11111
		ENCODING: STADDH_LDADDH_32_memop
			OPERATION: STADDH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STADDLH_LDADDLH_32_memop
			OPERATION: STADDLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STADD_LDADD
	TYPE: alias
	XML: stadd_ldadd.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=000|00|Rn=xxxxx|Rt=11111
		ENCODING: STADD_LDADD_32_memop
			OPERATION: STADD
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STADDL_LDADDL_32_memop
			OPERATION: STADDL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STADD_LDADD_64_memop
			OPERATION: STADD
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STADDL_LDADDL_64_memop
			OPERATION: STADDL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STCLRB_LDCLRB
	TYPE: alias
	XML: stclrb_ldclrb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=11111
		ENCODING: STCLRB_LDCLRB_32_memop
			OPERATION: STCLRB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STCLRLB_LDCLRLB_32_memop
			OPERATION: STCLRLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STCLRH_LDCLRH
	TYPE: alias
	XML: stclrh_ldclrh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=11111
		ENCODING: STCLRH_LDCLRH_32_memop
			OPERATION: STCLRH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STCLRLH_LDCLRLH_32_memop
			OPERATION: STCLRLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STCLR_LDCLR
	TYPE: alias
	XML: stclr_ldclr.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=001|00|Rn=xxxxx|Rt=11111
		ENCODING: STCLR_LDCLR_32_memop
			OPERATION: STCLR
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STCLRL_LDCLRL_32_memop
			OPERATION: STCLRL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STCLR_LDCLR_64_memop
			OPERATION: STCLR
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STCLRL_LDCLRL_64_memop
			OPERATION: STCLRL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STEORB_LDEORB
	TYPE: alias
	XML: steorb_ldeorb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=11111
		ENCODING: STEORB_LDEORB_32_memop
			OPERATION: STEORB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STEORLB_LDEORLB_32_memop
			OPERATION: STEORLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STEORH_LDEORH
	TYPE: alias
	XML: steorh_ldeorh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=11111
		ENCODING: STEORH_LDEORH_32_memop
			OPERATION: STEORH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STEORLH_LDEORLH_32_memop
			OPERATION: STEORLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STEOR_LDEOR
	TYPE: alias
	XML: steor_ldeor.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=010|00|Rn=xxxxx|Rt=11111
		ENCODING: STEOR_LDEOR_32_memop
			OPERATION: STEOR
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STEORL_LDEORL_32_memop
			OPERATION: STEORL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STEOR_LDEOR_64_memop
			OPERATION: STEOR
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STEORL_LDEORL_64_memop
			OPERATION: STEORL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STG
	TYPE: instruction
	XML: stg.xml
	CLASS: post_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=00|1|imm9=xxxxxxxxx|op2=01|Xn=xxxxx|Xt=xxxxx
		ENCODING: STG_64Spost_ldsttags
			OPERATION: STG
			SYNTAX: <Xt|SP>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = TRUE;
			boolean zero_data = FALSE;
	CLASS: pre_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=00|1|imm9=xxxxxxxxx|op2=11|Xn=xxxxx|Xt=xxxxx
		ENCODING: STG_64Spre_ldsttags
			OPERATION: STG
			SYNTAX: <Xt|SP>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = FALSE;
			boolean zero_data = FALSE;
	CLASS: signed_scaled_offset
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=00|1|imm9=xxxxxxxxx|op2=10|Xn=xxxxx|Xt=xxxxx
		ENCODING: STG_64Soffset_ldsttags
			OPERATION: STG
			SYNTAX: <Xt|SP>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = FALSE;
			boolean postindex = FALSE;
			boolean zero_data = FALSE;

IFORM: STGM
	TYPE: instruction
	XML: stgm.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE2
		FIELDS32: 11011001|opc=10|1|imm9=000000000|op2=00|Xn=xxxxx|Xt=xxxxx
		ENCODING: STGM_64bulk_ldsttags
			OPERATION: STGM
			SYNTAX: <Xt>, [<Xn|SP>]
		DECODE_PCODE:
			if !HaveMTE2Ext() then UNDEFINED;
			integer t = UInt(Xt);
			integer n = UInt(Xn);

IFORM: STGP
	TYPE: instruction
	XML: stgp.xml
	CLASS: post_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: opc=01|101|V=0|001|L=0|simm7=xxxxxxx|Xt2=xxxxx|Xn=xxxxx|Xt=xxxxx
		ENCODING: STGP_64_ldstpair_post
			OPERATION: STGP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>], #<imm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			integer t2 = UInt(Xt2);
			bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = TRUE;
	CLASS: pre_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: opc=01|101|V=0|011|L=0|simm7=xxxxxxx|Xt2=xxxxx|Xn=xxxxx|Xt=xxxxx
		ENCODING: STGP_64_ldstpair_pre
			OPERATION: STGP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>, #<imm>]!
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			integer t2 = UInt(Xt2);
			bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = FALSE;
	CLASS: signed_scaled_offset
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: opc=01|101|V=0|010|L=0|simm7=xxxxxxx|Xt2=xxxxx|Xn=xxxxx|Xt=xxxxx
		ENCODING: STGP_64_ldstpair_off
			OPERATION: STGP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			integer t2 = UInt(Xt2);
			bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
			boolean writeback = FALSE;
			boolean postindex = FALSE;

IFORM: STLLR
	TYPE: instruction
	XML: stllr.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=1x|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLLR_SL32_ldstexcl
			OPERATION: STLLR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STLLR_SL64_ldstexcl
			OPERATION: STLLR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLLRB
	TYPE: instruction
	XML: stllrb.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=00|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLLRB_SL32_ldstexcl
			OPERATION: STLLRB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLLRH
	TYPE: instruction
	XML: stllrh.xml
	CLASS: base_register
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LOR
		FIELDS32: size=01|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLLRH_SL32_ldstexcl
			OPERATION: STLLRH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLR
	TYPE: instruction
	XML: stlr.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLR_SL32_ldstexcl
			OPERATION: STLR
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STLR_SL64_ldstexcl
			OPERATION: STLR
			SYNTAX: <Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLRB
	TYPE: instruction
	XML: stlrb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLRB_SL32_ldstexcl
			OPERATION: STLRB
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLRH
	TYPE: instruction
	XML: stlrh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=1|L=0|o1=0|Rs=(1)(1)(1)(1)(1)|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLRH_SL32_ldstexcl
			OPERATION: STLRH
			SYNTAX: <Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = elsize;
			boolean tag_checked = n != 31;

IFORM: STLURB
	TYPE: instruction
	XML: stlurb.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=00|011001|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLURB_32_ldapstl_unscaled
			OPERATION: STLURB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STLURH
	TYPE: instruction
	XML: stlurh.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=01|011001|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLURH_32_ldapstl_unscaled
			OPERATION: STLURH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STLUR_gen
	TYPE: instruction
	XML: stlur_gen.xml
	CLASS: base_plus_offset
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_LRCPC2
		FIELDS32: size=1x|011001|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLUR_32_ldapstl_unscaled
			OPERATION: STLUR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STLUR_64_ldapstl_unscaled
			OPERATION: STLUR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_ORDERED;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STLXP
	TYPE: instruction
	XML: stlxp.xml
	CLASS: base_register
		FIELDS32: 1|sz=x|001000|o2=0|L=0|o1=1|Rs=xxxxx|o0=1|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLXP_SP32_ldstexcl
			OPERATION: STLXP
			SYNTAX: <Ws>,<Wt1>,<Wt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0'
			LABEL: 32-bit
		ENCODING: STLXP_SP64_ldstexcl
			OPERATION: STLXP
			SYNTAX: <Ws>,<Xt1>,<Xt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = TRUE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 32 << UInt(sz);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STLXR
	TYPE: instruction
	XML: stlxr.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLXR_SR32_ldstexcl
			OPERATION: STLXR
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STLXR_SR64_ldstexcl
			OPERATION: STLXR
			SYNTAX: <Ws>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STLXRB
	TYPE: instruction
	XML: stlxrb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLXRB_SR32_ldstexcl
			OPERATION: STLXRB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STLXRH
	TYPE: instruction
	XML: stlxrh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=1|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STLXRH_SR32_ldstexcl
			OPERATION: STLXRH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STNP_fpsimd
	TYPE: instruction
	XML: stnp_fpsimd.xml
	CLASS: signed_scaled_offset
		FIELDS32: opc=xx|101|V=1|000|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STNP_S_ldstnapair_offs
			OPERATION: STNP
			SYNTAX: <St1>,<St2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STNP_D_ldstnapair_offs
			OPERATION: STNP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: STNP_Q_ldstnapair_offs
			OPERATION: STNP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_VECSTREAM;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc == '11' then UNDEFINED;
		integer scale = 2 + UInt(opc);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STNP_gen
	TYPE: instruction
	XML: stnp_gen.xml
	CLASS: signed_scaled_offset
		FIELDS32: opc=x0|101|V=0|000|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STNP_32_ldstnapair_offs
			OPERATION: STNP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STNP_64_ldstnapair_offs
			OPERATION: STNP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_STREAM;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc<0> == '1' then UNDEFINED;
		integer scale = 2 + UInt(opc<1>);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STP_fpsimd
	TYPE: instruction
	XML: stp_fpsimd.xml
	CLASS: post_indexed
		FIELDS32: opc=xx|101|V=1|001|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_S_ldstpair_post
			OPERATION: STP
			SYNTAX: <St1>,<St2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_D_ldstpair_post
			OPERATION: STP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: STP_Q_ldstpair_post
			OPERATION: STP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '10'
	CLASS: pre_indexed
		FIELDS32: opc=xx|101|V=1|011|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_S_ldstpair_pre
			OPERATION: STP
			SYNTAX: <St1>,<St2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_D_ldstpair_pre
			OPERATION: STP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: STP_Q_ldstpair_pre
			OPERATION: STP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '10'
	CLASS: signed_scaled_offset
		FIELDS32: opc=xx|101|V=1|010|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_S_ldstpair_off
			OPERATION: STP
			SYNTAX: <St1>,<St2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_D_ldstpair_off
			OPERATION: STP
			SYNTAX: <Dt1>,<Dt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '01'
			LABEL: 64-bit
		ENCODING: STP_Q_ldstpair_off
			OPERATION: STP
			SYNTAX: <Qt1>,<Qt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_VEC;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if opc == '11' then UNDEFINED;
		integer scale = 2 + UInt(opc);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STP_gen
	TYPE: instruction
	XML: stp_gen.xml
	CLASS: post_indexed
		FIELDS32: opc=x0|101|V=0|001|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_32_ldstpair_post
			OPERATION: STP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_64_ldstpair_post
			OPERATION: STP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>], #<imm>
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	CLASS: pre_indexed
		FIELDS32: opc=x0|101|V=0|011|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_32_ldstpair_pre
			OPERATION: STP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_64_ldstpair_pre
			OPERATION: STP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>, #<imm>]!
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	CLASS: signed_scaled_offset
		FIELDS32: opc=x0|101|V=0|010|L=0|imm7=xxxxxxx|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STP_32_ldstpair_off
			OPERATION: STP
			SYNTAX: <Wt1>,<Wt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '00'
			LABEL: 32-bit
		ENCODING: STP_64_ldstpair_off
			OPERATION: STP
			SYNTAX: <Xt1>,<Xt2>, [<Xn|SP>{, #<imm>}]
			BITDIFFS: opc == '10'
			LABEL: 64-bit
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer t2 = UInt(Rt2);
		AccType acctype = AccType_NORMAL;
		MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
		if L:opc<0> == '01' || opc == '11' then UNDEFINED;
		boolean signed = (opc<0> != '0');
		integer scale = 2 + UInt(opc<1>);
		integer datasize = 8 << scale;
		bits(64) offset = LSL(SignExtend(imm7, 64), scale);
		boolean tag_checked = wback || n != 31;
		boolean rt_unknown = FALSE;
		boolean wb_unknown = FALSE;
		if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_LOAD && t == t2 then
		    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
		    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STRB_imm
	TYPE: instruction
	XML: strb_imm.xml
	CLASS: post_indexed
		FIELDS32: size=00|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRB_32_ldst_immpost
			OPERATION: STRB
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=00|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRB_32_ldst_immpre
			OPERATION: STRB
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=00|111|V=0|01|opc=00|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRB_32_ldst_pos
			OPERATION: STRB
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STRB_reg
	TYPE: instruction
	XML: strb_reg.xml
	CLASS: 32
		FIELDS32: size=00|111|V=0|00|opc=00|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRB_32B_ldst_regoff
			OPERATION: STRB
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: option != '011'
		ENCODING: STRB_32BL_ldst_regoff
			OPERATION: STRB
			SYNTAX: <Wt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: option == '011'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STRH_imm
	TYPE: instruction
	XML: strh_imm.xml
	CLASS: post_indexed
		FIELDS32: size=01|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRH_32_ldst_immpost
			OPERATION: STRH
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=01|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRH_32_ldst_immpre
			OPERATION: STRH
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=01|111|V=0|01|opc=00|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRH_32_ldst_pos
			OPERATION: STRH
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STRH_reg
	TYPE: instruction
	XML: strh_reg.xml
	CLASS: 32
		FIELDS32: size=01|111|V=0|00|opc=00|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STRH_32_ldst_regoff
			OPERATION: STRH
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STR_imm_fpsimd
	TYPE: instruction
	XML: str_imm_fpsimd.xml
	CLASS: post_indexed
		FIELDS32: size=xx|111|V=1|00|opc=x0|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_B_ldst_immpost
			OPERATION: STR
			SYNTAX: <Bt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '00' && opc == '00'
		ENCODING: STR_H_ldst_immpost
			OPERATION: STR
			SYNTAX: <Ht>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '01' && opc == '00'
		ENCODING: STR_S_ldst_immpost
			OPERATION: STR
			SYNTAX: <St>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '10' && opc == '00'
			LABEL: 32-bit
		ENCODING: STR_D_ldst_immpost
			OPERATION: STR
			SYNTAX: <Dt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '11' && opc == '00'
			LABEL: 64-bit
		ENCODING: STR_Q_ldst_immpost
			OPERATION: STR
			SYNTAX: <Qt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '00' && opc == '10'
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=xx|111|V=1|00|opc=x0|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_B_ldst_immpre
			OPERATION: STR
			SYNTAX: <Bt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '00' && opc == '00'
		ENCODING: STR_H_ldst_immpre
			OPERATION: STR
			SYNTAX: <Ht>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '01' && opc == '00'
		ENCODING: STR_S_ldst_immpre
			OPERATION: STR
			SYNTAX: <St>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '10' && opc == '00'
			LABEL: 32-bit
		ENCODING: STR_D_ldst_immpre
			OPERATION: STR
			SYNTAX: <Dt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '11' && opc == '00'
			LABEL: 64-bit
		ENCODING: STR_Q_ldst_immpre
			OPERATION: STR
			SYNTAX: <Qt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '00' && opc == '10'
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=xx|111|V=1|01|opc=x0|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_B_ldst_pos
			OPERATION: STR
			SYNTAX: <Bt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '00' && opc == '00'
		ENCODING: STR_H_ldst_pos
			OPERATION: STR
			SYNTAX: <Ht>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '01' && opc == '00'
		ENCODING: STR_S_ldst_pos
			OPERATION: STR
			SYNTAX: <St>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '10' && opc == '00'
			LABEL: 32-bit
		ENCODING: STR_D_ldst_pos
			OPERATION: STR
			SYNTAX: <Dt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '11' && opc == '00'
			LABEL: 64-bit
		ENCODING: STR_Q_ldst_pos
			OPERATION: STR
			SYNTAX: <Qt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '00' && opc == '10'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

IFORM: STR_imm_gen
	TYPE: instruction
	XML: str_imm_gen.xml
	CLASS: post_indexed
		FIELDS32: size=1x|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|01|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_32_ldst_immpost
			OPERATION: STR
			SYNTAX: <Wt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STR_64_ldst_immpost
			OPERATION: STR
			SYNTAX: <Xt>, [<Xn|SP>], #<simm>
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = TRUE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: pre_indexed
		FIELDS32: size=1x|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|11|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_32_ldst_immpre
			OPERATION: STR
			SYNTAX: <Wt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STR_64_ldst_immpre
			OPERATION: STR
			SYNTAX: <Xt>, [<Xn|SP>, #<simm>]!
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = TRUE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	CLASS: unsigned_scaled_offset
		FIELDS32: size=1x|111|V=0|01|opc=00|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_32_ldst_pos
			OPERATION: STR
			SYNTAX: <Wt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STR_64_ldst_pos
			OPERATION: STR
			SYNTAX: <Xt>, [<Xn|SP>{, #<pimm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STR_reg_fpsimd
	TYPE: instruction
	XML: str_reg_fpsimd.xml
	CLASS: fpsimd
		FIELDS32: size=xx|111|V=1|00|opc=x0|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_B_ldst_regoff
			OPERATION: STR
			SYNTAX: <Bt>, [<Xn|SP>, (<Wm>|<Xm>),<extend>{<amount>}]
			BITDIFFS: size == '00' && opc == '00' && option != '011'
		ENCODING: STR_BL_ldst_regoff
			OPERATION: STR
			SYNTAX: <Bt>, [<Xn|SP>,<Xm>{, LSL<amount>}]
			BITDIFFS: size == '00' && opc == '00' && option == '011'
		ENCODING: STR_H_ldst_regoff
			OPERATION: STR
			SYNTAX: <Ht>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '01' && opc == '00'
		ENCODING: STR_S_ldst_regoff
			OPERATION: STR
			SYNTAX: <St>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '10' && opc == '00'
		ENCODING: STR_D_ldst_regoff
			OPERATION: STR
			SYNTAX: <Dt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '11' && opc == '00'
		ENCODING: STR_Q_ldst_regoff
			OPERATION: STR
			SYNTAX: <Qt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '00' && opc == '10'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;

IFORM: STR_reg_gen
	TYPE: instruction
	XML: str_reg_gen.xml
	CLASS: general
		FIELDS32: size=1x|111|V=0|00|opc=00|1|Rm=xxxxx|option=xxx|S=x|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STR_32_ldst_regoff
			OPERATION: STR
			SYNTAX: <Wt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STR_64_ldst_regoff
			OPERATION: STR
			SYNTAX: <Xt>, [<Xn|SP>, (<Wm>|<Xm>){,<extend>{<amount>}}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			if option<1> == '0' then UNDEFINED;             // sub-word index
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = if S == '1' then scale else 0;
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		integer m = UInt(Rm);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH;
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STSETB_LDSETB
	TYPE: alias
	XML: stsetb_ldsetb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=11111
		ENCODING: STSETB_LDSETB_32_memop
			OPERATION: STSETB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSETLB_LDSETLB_32_memop
			OPERATION: STSETLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSETH_LDSETH
	TYPE: alias
	XML: stseth_ldseth.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=11111
		ENCODING: STSETH_LDSETH_32_memop
			OPERATION: STSETH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSETLH_LDSETLH_32_memop
			OPERATION: STSETLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSET_LDSET
	TYPE: alias
	XML: stset_ldset.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=011|00|Rn=xxxxx|Rt=11111
		ENCODING: STSET_LDSET_32_memop
			OPERATION: STSET
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STSETL_LDSETL_32_memop
			OPERATION: STSETL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STSET_LDSET_64_memop
			OPERATION: STSET
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STSETL_LDSETL_64_memop
			OPERATION: STSETL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STSMAXB_LDSMAXB
	TYPE: alias
	XML: stsmaxb_ldsmaxb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMAXB_LDSMAXB_32_memop
			OPERATION: STSMAXB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSMAXLB_LDSMAXLB_32_memop
			OPERATION: STSMAXLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSMAXH_LDSMAXH
	TYPE: alias
	XML: stsmaxh_ldsmaxh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMAXH_LDSMAXH_32_memop
			OPERATION: STSMAXH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSMAXLH_LDSMAXLH_32_memop
			OPERATION: STSMAXLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSMAX_LDSMAX
	TYPE: alias
	XML: stsmax_ldsmax.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=100|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMAX_LDSMAX_32_memop
			OPERATION: STSMAX
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STSMAXL_LDSMAXL_32_memop
			OPERATION: STSMAXL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STSMAX_LDSMAX_64_memop
			OPERATION: STSMAX
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STSMAXL_LDSMAXL_64_memop
			OPERATION: STSMAXL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STSMINB_LDSMINB
	TYPE: alias
	XML: stsminb_ldsminb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMINB_LDSMINB_32_memop
			OPERATION: STSMINB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSMINLB_LDSMINLB_32_memop
			OPERATION: STSMINLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSMINH_LDSMINH
	TYPE: alias
	XML: stsminh_ldsminh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMINH_LDSMINH_32_memop
			OPERATION: STSMINH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STSMINLH_LDSMINLH_32_memop
			OPERATION: STSMINLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STSMIN_LDSMIN
	TYPE: alias
	XML: stsmin_ldsmin.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=101|00|Rn=xxxxx|Rt=11111
		ENCODING: STSMIN_LDSMIN_32_memop
			OPERATION: STSMIN
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STSMINL_LDSMINL_32_memop
			OPERATION: STSMINL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STSMIN_LDSMIN_64_memop
			OPERATION: STSMIN
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STSMINL_LDSMINL_64_memop
			OPERATION: STSMINL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STTR
	TYPE: instruction
	XML: sttr.xml
	CLASS: base_plus_offset
		FIELDS32: size=1x|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STTR_32_ldst_unpriv
			OPERATION: STTR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STTR_64_ldst_unpriv
			OPERATION: STTR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STTRB
	TYPE: instruction
	XML: sttrb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STTRB_32_ldst_unpriv
			OPERATION: STTRB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STTRH
	TYPE: instruction
	XML: sttrh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|10|Rn=xxxxx|Rt=xxxxx
		ENCODING: STTRH_32_ldst_unpriv
			OPERATION: STTRH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
		unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
		user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
		if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
		    acctype = AccType_UNPRIV;
		else
		    acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STUMAXB_LDUMAXB
	TYPE: alias
	XML: stumaxb_ldumaxb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMAXB_LDUMAXB_32_memop
			OPERATION: STUMAXB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STUMAXLB_LDUMAXLB_32_memop
			OPERATION: STUMAXLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STUMAXH_LDUMAXH
	TYPE: alias
	XML: stumaxh_ldumaxh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMAXH_LDUMAXH_32_memop
			OPERATION: STUMAXH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STUMAXLH_LDUMAXLH_32_memop
			OPERATION: STUMAXLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STUMAX_LDUMAX
	TYPE: alias
	XML: stumax_ldumax.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=110|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMAX_LDUMAX_32_memop
			OPERATION: STUMAX
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STUMAXL_LDUMAXL_32_memop
			OPERATION: STUMAXL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STUMAX_LDUMAX_64_memop
			OPERATION: STUMAX
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STUMAXL_LDUMAXL_64_memop
			OPERATION: STUMAXL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STUMINB_LDUMINB
	TYPE: alias
	XML: stuminb_lduminb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMINB_LDUMINB_32_memop
			OPERATION: STUMINB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STUMINLB_LDUMINLB_32_memop
			OPERATION: STUMINLB
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STUMINH_LDUMINH
	TYPE: alias
	XML: stuminh_lduminh.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMINH_LDUMINH_32_memop
			OPERATION: STUMINH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '0'
		ENCODING: STUMINLH_LDUMINLH_32_memop
			OPERATION: STUMINLH
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: R == '1'

IFORM: STUMIN_LDUMIN
	TYPE: alias
	XML: stumin_ldumin.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=0|R=x|1|Rs=xxxxx|o3=0|opc=111|00|Rn=xxxxx|Rt=11111
		ENCODING: STUMIN_LDUMIN_32_memop
			OPERATION: STUMIN
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '0'
		ENCODING: STUMINL_LDUMINL_32_memop
			OPERATION: STUMINL
			SYNTAX: <Ws>, [<Xn|SP>]
			BITDIFFS: size == '10' && R == '1'
		ENCODING: STUMIN_LDUMIN_64_memop
			OPERATION: STUMIN
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '0'
		ENCODING: STUMINL_LDUMINL_64_memop
			OPERATION: STUMINL
			SYNTAX: <Xs>, [<Xn|SP>]
			BITDIFFS: size == '11' && R == '1'

IFORM: STURB
	TYPE: instruction
	XML: sturb.xml
	CLASS: base_plus_offset
		FIELDS32: size=00|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STURB_32_ldst_unscaled
			OPERATION: STURB
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STURH
	TYPE: instruction
	XML: sturh.xml
	CLASS: base_plus_offset
		FIELDS32: size=01|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STURH_32_ldst_unscaled
			OPERATION: STURH
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STUR_fpsimd
	TYPE: instruction
	XML: stur_fpsimd.xml
	CLASS: base_plus_offset
		FIELDS32: size=xx|111|V=1|00|opc=x0|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STUR_B_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Bt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '00' && opc == '00'
		ENCODING: STUR_H_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Ht>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '01' && opc == '00'
		ENCODING: STUR_S_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <St>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10' && opc == '00'
			LABEL: 32-bit
		ENCODING: STUR_D_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Dt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11' && opc == '00'
			LABEL: 64-bit
		ENCODING: STUR_Q_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Qt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '00' && opc == '10'
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(opc<1>:size);
			if scale > 4 then UNDEFINED;
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_VEC;
		MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

IFORM: STUR_gen
	TYPE: instruction
	XML: stur_gen.xml
	CLASS: base_plus_offset
		FIELDS32: size=1x|111|V=0|00|opc=00|0|imm9=xxxxxxxxx|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: STUR_32_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Wt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STUR_64_ldst_unscaled
			OPERATION: STUR
			SYNTAX: <Xt>, [<Xn|SP>{, #<simm>}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			boolean wback = FALSE;
			boolean postindex = FALSE;
			integer scale = UInt(size);
			bits(64) offset = SignExtend(imm9, 64);
	POSTDECODE_PCODE:
		integer n = UInt(Rn);
		integer t = UInt(Rt);
		AccType acctype = AccType_NORMAL;
		MemOp memop;
		boolean signed;
		integer regsize;
		if opc<1> == '0' then
		    // store or zero-extending load
		    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
		    regsize = if size == '11' then 64 else 32;
		    signed = FALSE;
		else
		    if size == '11' then
		        memop = MemOp_PREFETCH;
		        if opc<0> == '1' then UNDEFINED;
		    else
		        // sign-extending load
		        memop = MemOp_LOAD;
		        if size == '10' && opc<0> == '1' then UNDEFINED;
		        regsize = if opc<0> == '1' then 32 else 64;
		        signed = TRUE;
		integer datasize = 8 << scale;
		boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);
		boolean wb_unknown = FALSE;
		boolean rt_unknown = FALSE;
		if memop == MemOp_LOAD && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
		    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
		        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();
		if memop == MemOp_STORE && wback && n == t && n != 31 then
		    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
		    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
		    case c of
		        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
		        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
		        when Constraint_UNDEF      UNDEFINED;
		        when Constraint_NOP        EndOfInstruction();

IFORM: STXP
	TYPE: instruction
	XML: stxp.xml
	CLASS: base_register
		FIELDS32: 1|sz=x|001000|o2=0|L=0|o1=1|Rs=xxxxx|o0=0|Rt2=xxxxx|Rn=xxxxx|Rt=xxxxx
		ENCODING: STXP_SP32_ldstexcl
			OPERATION: STXP
			SYNTAX: <Ws>,<Wt1>,<Wt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '0'
			LABEL: 32-bit
		ENCODING: STXP_SP64_ldstexcl
			OPERATION: STXP
			SYNTAX: <Ws>,<Xt1>,<Xt2>, [<Xn|SP>{,#0}]
			BITDIFFS: sz == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = TRUE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 32 << UInt(sz);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STXR
	TYPE: instruction
	XML: stxr.xml
	CLASS: base_register
		FIELDS32: size=1x|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STXR_SR32_ldstexcl
			OPERATION: STXR
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '10'
			LABEL: 32-bit
		ENCODING: STXR_SR64_ldstexcl
			OPERATION: STXR
			SYNTAX: <Ws>,<Xt>, [<Xn|SP>{,#0}]
			BITDIFFS: size == '11'
			LABEL: 64-bit
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STXRB
	TYPE: instruction
	XML: stxrb.xml
	CLASS: base_register
		FIELDS32: size=00|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STXRB_SR32_ldstexcl
			OPERATION: STXRB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STXRH
	TYPE: instruction
	XML: stxrh.xml
	CLASS: base_register
		FIELDS32: size=01|001000|o2=0|L=0|o1=0|Rs=xxxxx|o0=0|Rt2=(1)(1)(1)(1)(1)|Rn=xxxxx|Rt=xxxxx
		ENCODING: STXRH_SR32_ldstexcl
			OPERATION: STXRH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>{,#0}]
		DECODE_PCODE:
			integer n = UInt(Rn);
			integer t = UInt(Rt);
			integer t2 = UInt(Rt2); // ignored by load/store single register
			integer s = UInt(Rs);   // ignored by all loads and store-release
			AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
			boolean pair = FALSE;
			MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
			integer elsize = 8 << UInt(size);
			integer regsize = if elsize == 64 then 64 else 32;
			integer datasize = if pair then elsize * 2 else elsize;
			boolean tag_checked = n != 31;
			boolean rt_unknown = FALSE;
			boolean rn_unknown = FALSE;
			if memop == MemOp_LOAD && pair && t == t2 then
			    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
			    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
			    case c of
			        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
			        when Constraint_UNDEF      UNDEFINED;
			        when Constraint_NOP        EndOfInstruction();
			if memop == MemOp_STORE then
			    if s == t || (pair && s == t2) then
			        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
			            when Constraint_NONE       rt_unknown = FALSE;   // store original value
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();
			    if s == n && n != 31 then
			        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
			        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
			        case c of
			            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
			            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
			            when Constraint_UNDEF      UNDEFINED;
			            when Constraint_NOP        EndOfInstruction();

IFORM: STZ2G
	TYPE: instruction
	XML: stz2g.xml
	CLASS: post_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=11|1|imm9=xxxxxxxxx|op2=01|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZ2G_64Spost_ldsttags
			OPERATION: STZ2G
			SYNTAX: <Xt|SP>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = TRUE;
			boolean zero_data = TRUE;
	CLASS: pre_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=11|1|imm9=xxxxxxxxx|op2=11|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZ2G_64Spre_ldsttags
			OPERATION: STZ2G
			SYNTAX: <Xt|SP>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = FALSE;
			boolean zero_data = TRUE;
	CLASS: signed_scaled_offset
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=11|1|imm9=xxxxxxxxx|op2=10|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZ2G_64Soffset_ldsttags
			OPERATION: STZ2G
			SYNTAX: <Xt|SP>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = FALSE;
			boolean postindex = FALSE;
			boolean zero_data = TRUE;

IFORM: STZG
	TYPE: instruction
	XML: stzg.xml
	CLASS: post_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=01|1|imm9=xxxxxxxxx|op2=01|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZG_64Spost_ldsttags
			OPERATION: STZG
			SYNTAX: <Xt|SP>, [<Xn|SP>], #<simm>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = TRUE;
			boolean zero_data = TRUE;
	CLASS: pre_indexed
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=01|1|imm9=xxxxxxxxx|op2=11|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZG_64Spre_ldsttags
			OPERATION: STZG
			SYNTAX: <Xt|SP>, [<Xn|SP>, #<simm>]!
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = TRUE;
			boolean postindex = FALSE;
			boolean zero_data = TRUE;
	CLASS: signed_scaled_offset
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: 11011001|opc=01|1|imm9=xxxxxxxxx|op2=10|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZG_64Soffset_ldsttags
			OPERATION: STZG
			SYNTAX: <Xt|SP>, [<Xn|SP>{, #<simm>}]
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer n = UInt(Xn);
			integer t = UInt(Xt);
			bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
			boolean writeback = FALSE;
			boolean postindex = FALSE;
			boolean zero_data = TRUE;

IFORM: STZGM
	TYPE: instruction
	XML: stzgm.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE2
		FIELDS32: 11011001|opc=00|1|imm9=000000000|op2=00|Xn=xxxxx|Xt=xxxxx
		ENCODING: STZGM_64bulk_ldsttags
			OPERATION: STZGM
			SYNTAX: <Xt>, [<Xn|SP>]
		DECODE_PCODE:
			if !HaveMTE2Ext() then UNDEFINED;
			integer t = UInt(Xt);
			integer n = UInt(Xn);

IFORM: SUBG
	TYPE: instruction
	XML: subg.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|op=1|S=0|100011|o2=0|uimm6=xxxxxx|op3=(0)(0)|uimm4=xxxx|Xn=xxxxx|Xd=xxxxx
		ENCODING: SUBG_64_addsub_immtags
			OPERATION: SUBG
			SYNTAX: <Xd|SP>,<Xn|SP>, #<uimm6>, #<uimm4>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			bits(4) tag_offset = uimm4;
			bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
			boolean ADD = FALSE;

IFORM: SUBHN_advsimd
	TYPE: instruction
	XML: subhn_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=0|01110|size=xx|1|Rm=xxxxx|01|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUBHN_asimddiff_N
			OPERATION: SUBHN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>,<Vm>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean round = (U == '1');

IFORM: SUBP
	TYPE: instruction
	XML: subp.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|0|S=0|11010110|Xm=xxxxx|opcode=000000|Xn=xxxxx|Xd=xxxxx
		ENCODING: SUBP_64S_dp_2src
			OPERATION: SUBP
			SYNTAX: <Xd>,<Xn|SP>,<Xm|SP>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			integer m = UInt(Xm);
			boolean setflags = FALSE;

IFORM: SUBPS
	TYPE: instruction
	XML: subps.xml
	ALIAS: CMPP_SUBPS
		S == '1' && Xd == '11111'
	CLASS: general
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_MTE
		FIELDS32: sf=1|0|S=1|11010110|Xm=xxxxx|opcode=000000|Xn=xxxxx|Xd=xxxxx
		ENCODING: SUBPS_64S_dp_2src
			OPERATION: SUBPS
			SYNTAX: <Xd>,<Xn|SP>,<Xm|SP>
		DECODE_PCODE:
			if !HaveMTEExt() then UNDEFINED;
			integer d = UInt(Xd);
			integer n = UInt(Xn);
			integer m = UInt(Xm);
			boolean setflags = TRUE;

IFORM: SUBS_addsub_ext
	TYPE: instruction
	XML: subs_addsub_ext.xml
	ALIAS: CMP_SUBS_addsub_ext
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUBS_32S_addsub_ext
			OPERATION: SUBS
			SYNTAX: <Wd>,<Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUBS_64S_addsub_ext
			OPERATION: SUBS
			SYNTAX: <Xd>,<Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = UInt(imm3);
			if shift > 4 then UNDEFINED;

IFORM: SUBS_addsub_imm
	TYPE: instruction
	XML: subs_addsub_imm.xml
	ALIAS: CMP_SUBS_addsub_imm
		Rd == '11111'
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUBS_32S_addsub_imm
			OPERATION: SUBS
			SYNTAX: <Wd>,<Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUBS_64S_addsub_imm
			OPERATION: SUBS
			SYNTAX: <Xd>,<Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			bits(datasize) imm;
			case sh of
			    when '0' imm = ZeroExtend(imm12, datasize);
			    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

IFORM: SUBS_addsub_shift
	TYPE: instruction
	XML: subs_addsub_shift.xml
	ALIAS: CMP_SUBS_addsub_shift
		Rd == '11111'
	ALIAS: NEGS_SUBS_addsub_shift
		Rn == '11111' && Rd != '11111'
	CLASS: s
		FIELDS32: sf=x|op=1|S=1|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUBS_32_addsub_shift
			OPERATION: SUBS
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUBS_64_addsub_shift
			OPERATION: SUBS
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			if shift == '11' then UNDEFINED;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);

IFORM: SUB_addsub_ext
	TYPE: instruction
	XML: sub_addsub_ext.xml
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|01011|opt=00|1|Rm=xxxxx|option=xxx|imm3=xxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUB_32_addsub_ext
			OPERATION: SUB
			SYNTAX: <Wd|WSP>,<Wn|WSP>,<Wm>{,<extend>{#<amount>}}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUB_64_addsub_ext
			OPERATION: SUB
			SYNTAX: <Xd|SP>,<Xn|SP>,<R><m>{,<extend>{#<amount>}}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			ExtendType extend_type = DecodeRegExtend(option);
			integer shift = UInt(imm3);
			if shift > 4 then UNDEFINED;

IFORM: SUB_addsub_imm
	TYPE: instruction
	XML: sub_addsub_imm.xml
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|100010|sh=x|imm12=xxxxxxxxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUB_32_addsub_imm
			OPERATION: SUB
			SYNTAX: <Wd|WSP>,<Wn|WSP>, #<imm>{,<shift>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUB_64_addsub_imm
			OPERATION: SUB
			SYNTAX: <Xd|SP>,<Xn|SP>, #<imm>{,<shift>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			bits(datasize) imm;
			case sh of
			    when '0' imm = ZeroExtend(imm12, datasize);
			    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

IFORM: SUB_addsub_shift
	TYPE: instruction
	XML: sub_addsub_shift.xml
	ALIAS: NEG_SUB_addsub_shift
		Rn == '11111'
	CLASS: no_s
		FIELDS32: sf=x|op=1|S=0|01011|shift=xx|0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUB_32_addsub_shift
			OPERATION: SUB
			SYNTAX: <Wd>,<Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: SUB_64_addsub_shift
			OPERATION: SUB
			SYNTAX: <Xd>,<Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean sub_op = (op == '1');
			boolean setflags = (S == '1');
			if shift == '11' then UNDEFINED;
			if sf == '0' && imm6<5> == '1' then UNDEFINED;
			ShiftType shift_type = DecodeShift(shift);
			integer shift_amount = UInt(imm6);

IFORM: SUB_advsimd
	TYPE: instruction
	XML: sub_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|opcode=10000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUB_asisdsame_only
			OPERATION: SUB
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean sub_op = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=10000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUB_asimdsame_only
			OPERATION: SUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean sub_op = (U == '1');

IFORM: SUDOT_advsimd_elt
	TYPE: instruction
	XML: sudot_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=x|U=0|01111|US=0|0|L=x|M=x|Rm=xxxx|opcode=1111|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUDOT_asimdelem_D
			OPERATION: SUDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.4B[<index>]
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			boolean op1_unsigned = (US == '1');
			boolean op2_unsigned = (US == '0');
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			integer d = UInt(Rd);
			integer i = UInt(H:L);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 32;

IFORM: SUQADD_advsimd
	TYPE: instruction
	XML: suqadd_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=0|11110|size=xx|10000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUQADD_asisdmisc_R
			OPERATION: SUQADD
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: SUQADD_asimdmisc_R
			OPERATION: SUQADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: SVC
	TYPE: instruction
	XML: svc.xml
	CLASS: system
		FIELDS32: 11010100|opc=000|imm16=xxxxxxxxxxxxxxxx|op2=000|LL=01
		ENCODING: SVC_EX_exception
			OPERATION: SVC
			SYNTAX: #<imm>

IFORM: SWP
	TYPE: instruction
	XML: swp.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=1x|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=1|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: SWP_32_memop
			OPERATION: SWP
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '0'
		ENCODING: SWPA_32_memop
			OPERATION: SWPA
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '0'
		ENCODING: SWPAL_32_memop
			OPERATION: SWPAL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '1' && R == '1'
		ENCODING: SWPL_32_memop
			OPERATION: SWPL
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: size == '10' && A == '0' && R == '1'
		ENCODING: SWP_64_memop
			OPERATION: SWP
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '0'
		ENCODING: SWPA_64_memop
			OPERATION: SWPA
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '0'
		ENCODING: SWPAL_64_memop
			OPERATION: SWPAL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '1' && R == '1'
		ENCODING: SWPL_64_memop
			OPERATION: SWPL
			SYNTAX: <Xs>,<Xt>, [<Xn|SP>]
			BITDIFFS: size == '11' && A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: SWPB
	TYPE: instruction
	XML: swpb.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=00|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=1|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: SWPAB_32_memop
			OPERATION: SWPAB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: SWPALB_32_memop
			OPERATION: SWPALB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: SWPB_32_memop
			OPERATION: SWPB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: SWPLB_32_memop
			OPERATION: SWPLB
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: SWPH
	TYPE: instruction
	XML: swph.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.1
		ARCH_FEATURE: FEAT_LSE
		FIELDS32: size=01|111|V=0|00|A=x|R=x|1|Rs=xxxxx|o3=1|opc=000|00|Rn=xxxxx|Rt=xxxxx
		ENCODING: SWPAH_32_memop
			OPERATION: SWPAH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '0'
		ENCODING: SWPALH_32_memop
			OPERATION: SWPALH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '1' && R == '1'
		ENCODING: SWPH_32_memop
			OPERATION: SWPH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '0'
		ENCODING: SWPLH_32_memop
			OPERATION: SWPLH
			SYNTAX: <Ws>,<Wt>, [<Xn|SP>]
			BITDIFFS: A == '0' && R == '1'
		DECODE_PCODE:
			if !HaveAtomicExt() then UNDEFINED;
			integer t = UInt(Rt);
			integer n = UInt(Rn);
			integer s = UInt(Rs);
			integer datasize = 8 << UInt(size);
			integer regsize = if datasize == 64 then 64 else 32;
			AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
			boolean tag_checked = n != 31;

IFORM: SXTB_SBFM
	TYPE: alias
	XML: sxtb_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=000000|imms=000111|Rn=xxxxx|Rd=xxxxx
		ENCODING: SXTB_SBFM_32M_bitfield
			OPERATION: SXTB
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: SXTB_SBFM_64M_bitfield
			OPERATION: SXTB
			SYNTAX: <Xd>,<Wn>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: SXTH_SBFM
	TYPE: alias
	XML: sxth_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=x|opc=00|100110|N=x|immr=000000|imms=001111|Rn=xxxxx|Rd=xxxxx
		ENCODING: SXTH_SBFM_32M_bitfield
			OPERATION: SXTH
			SYNTAX: <Wd>,<Wn>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: SXTH_SBFM_64M_bitfield
			OPERATION: SXTH
			SYNTAX: <Xd>,<Wn>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: SXTL_SSHLL_advsimd
	TYPE: alias
	XML: sxtl_sshll_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|011110|immh!=0000|immb=000|opcode=10100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: SXTL_SSHLL_asimdshf_L
			OPERATION: SXTL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>

IFORM: SXTW_SBFM
	TYPE: alias
	XML: sxtw_sbfm.xml
	CLASS: signed_fill
		FIELDS32: sf=1|opc=00|100110|N=1|immr=000000|imms=011111|Rn=xxxxx|Rd=xxxxx
		ENCODING: SXTW_SBFM_64M_bitfield
			OPERATION: SXTW
			SYNTAX: <Xd>,<Wn>
			LABEL: 64-bit

IFORM: SYS
	TYPE: instruction
	XML: sys.xml
	ALIAS: AT_SYS
		CRn == '0111' && CRm == '100x' && SysOp(op1,'0111',CRm,op2) == Sys_AT
	ALIAS: CFP_SYS
		op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '100'
	ALIAS: CPP_SYS
		op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '111'
	ALIAS: DC_SYS
		CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_DC
	ALIAS: DVP_SYS
		op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '101'
	ALIAS: IC_SYS
		CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_IC
	ALIAS: TLBI_SYS
		CRn == '1000' && SysOp(op1,'1000',CRm,op2) == Sys_TLBI
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=01|op1=xxx|CRn=xxxx|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: SYS_CR_systeminstrs
			OPERATION: SYS
			SYNTAX: #<op1>,<Cn>,<Cm>, #<op2>{,<Xt>}
		DECODE_PCODE:
			AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
			integer t = UInt(Rt);
			integer sys_op0 = 1;
			integer sys_op1 = UInt(op1);
			integer sys_op2 = UInt(op2);
			integer sys_crn = UInt(CRn);
			integer sys_crm = UInt(CRm);
			boolean has_result = (L == '1');

IFORM: SYSL
	TYPE: instruction
	XML: sysl.xml
	CLASS: system
		FIELDS32: 1101010100|L=1|op0=01|op1=xxx|CRn=xxxx|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: SYSL_RC_systeminstrs
			OPERATION: SYSL
			SYNTAX: <Xt>, #<op1>,<Cn>,<Cm>, #<op2>
		DECODE_PCODE:
			AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
			integer t = UInt(Rt);
			integer sys_op0 = 1;
			integer sys_op1 = UInt(op1);
			integer sys_op2 = UInt(op2);
			integer sys_crn = UInt(CRn);
			integer sys_crm = UInt(CRm);
			boolean has_result = (L == '1');

IFORM: TBL_advsimd
	TYPE: instruction
	XML: tbl_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|op2=00|0|Rm=xxxxx|0|len=xx|op=0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: TBL_asimdtbl_L2_2
			OPERATION: TBL
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B},<Vm>.<Ta>
			BITDIFFS: len == '01'
		ENCODING: TBL_asimdtbl_L3_3
			OPERATION: TBL
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B,<Vn+2>.16B},<Vm>.<Ta>
			BITDIFFS: len == '10'
		ENCODING: TBL_asimdtbl_L4_4
			OPERATION: TBL
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B,<Vn+2>.16B,<Vn+3>.16B},<Vm>.<Ta>
			BITDIFFS: len == '11'
		ENCODING: TBL_asimdtbl_L1_1
			OPERATION: TBL
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B},<Vm>.<Ta>
			BITDIFFS: len == '00'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 8;
			integer regs = UInt(len) + 1;
			boolean is_tbl = (op == '0');

IFORM: TBNZ
	TYPE: instruction
	XML: tbnz.xml
	CLASS: br14
		FIELDS32: b5=x|011011|op=1|b40=xxxxx|imm14=xxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: TBNZ_only_testbranch
			OPERATION: TBNZ
			SYNTAX: <R><t>, #<imm>,<label>
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer datasize = if b5 == '1' then 64 else 32;
			integer bit_pos = UInt(b5:b40);
			bit bit_val = op;
			bits(64) offset = SignExtend(imm14:'00', 64);

IFORM: TBX_advsimd
	TYPE: instruction
	XML: tbx_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|op2=00|0|Rm=xxxxx|0|len=xx|op=1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: TBX_asimdtbl_L2_2
			OPERATION: TBX
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B},<Vm>.<Ta>
			BITDIFFS: len == '01'
		ENCODING: TBX_asimdtbl_L3_3
			OPERATION: TBX
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B,<Vn+2>.16B},<Vm>.<Ta>
			BITDIFFS: len == '10'
		ENCODING: TBX_asimdtbl_L4_4
			OPERATION: TBX
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B,<Vn+1>.16B,<Vn+2>.16B,<Vn+3>.16B},<Vm>.<Ta>
			BITDIFFS: len == '11'
		ENCODING: TBX_asimdtbl_L1_1
			OPERATION: TBX
			SYNTAX: <Vd>.<Ta>,{<Vn>.16B},<Vm>.<Ta>
			BITDIFFS: len == '00'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 8;
			integer regs = UInt(len) + 1;
			boolean is_tbl = (op == '0');

IFORM: TBZ
	TYPE: instruction
	XML: tbz.xml
	CLASS: br14
		FIELDS32: b5=x|011011|op=0|b40=xxxxx|imm14=xxxxxxxxxxxxxx|Rt=xxxxx
		ENCODING: TBZ_only_testbranch
			OPERATION: TBZ
			SYNTAX: <R><t>, #<imm>,<label>
		DECODE_PCODE:
			integer t = UInt(Rt);
			integer datasize = if b5 == '1' then 64 else 32;
			integer bit_pos = UInt(b5:b40);
			bit bit_val = op;
			bits(64) offset = SignExtend(imm14:'00', 64);

IFORM: TLBI_SYS
	TYPE: alias
	XML: tlbi_sys.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=01|op1=xxx|CRn=1000|CRm=xxxx|op2=xxx|Rt=xxxxx
		ENCODING: TLBI_SYS_CR_systeminstrs
			OPERATION: TLBI
			SYNTAX: <tlbi_op>{,<Xt>}

IFORM: TRN1_advsimd
	TYPE: instruction
	XML: trn1_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=0|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: TRN1_asimdperm_only
			OPERATION: TRN1
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);
			integer pairs = elements DIV 2;

IFORM: TRN2_advsimd
	TYPE: instruction
	XML: trn2_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=1|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: TRN2_asimdperm_only
			OPERATION: TRN2
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);
			integer pairs = elements DIV 2;

IFORM: TSB
	TYPE: instruction
	XML: tsb.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.4
		ARCH_FEATURE: FEAT_TRF
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0010|op2=010|Rt=11111
		ENCODING: TSB_HC_hints
			OPERATION: TSB
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: TST_ANDS_log_imm
	TYPE: alias
	XML: tst_ands_log_imm.xml
	CLASS: s
		FIELDS32: sf=x|opc=11|100100|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: TST_ANDS_32S_log_imm
			OPERATION: TST
			SYNTAX: <Wn>, #<imm>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: TST_ANDS_64S_log_imm
			OPERATION: TST
			SYNTAX: <Xn>, #<imm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: TST_ANDS_log_shift
	TYPE: alias
	XML: tst_ands_log_shift.xml
	CLASS: s
		FIELDS32: sf=x|opc=11|01010|shift=xx|N=0|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=11111
		ENCODING: TST_ANDS_32_log_shift
			OPERATION: TST
			SYNTAX: <Wn>,<Wm>{,<shift>#<amount>}
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: TST_ANDS_64_log_shift
			OPERATION: TST
			SYNTAX: <Xn>,<Xm>{,<shift>#<amount>}
			BITDIFFS: sf == '1'
			LABEL: 64-bit

IFORM: UABAL_advsimd
	TYPE: instruction
	XML: uabal_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|01|op=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UABAL_asimddiff_L
			OPERATION: UABAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean accumulate = (op == '0');
			boolean unsigned = (U == '1');

IFORM: UABA_advsimd
	TYPE: instruction
	XML: uaba_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0111|ac=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UABA_asimdsame_only
			OPERATION: UABA
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean accumulate = (ac == '1');

IFORM: UABDL_advsimd
	TYPE: instruction
	XML: uabdl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|01|op=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UABDL_asimddiff_L
			OPERATION: UABDL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean accumulate = (op == '0');
			boolean unsigned = (U == '1');

IFORM: UABD_advsimd
	TYPE: instruction
	XML: uabd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0111|ac=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UABD_asimdsame_only
			OPERATION: UABD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean accumulate = (ac == '1');

IFORM: UADALP_advsimd
	TYPE: instruction
	XML: uadalp_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|00|op=1|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UADALP_asimdmisc_P
			OPERATION: UADALP
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV (2*esize);
			boolean acc = (op == '1');
			boolean unsigned = (U == '1');

IFORM: UADDLP_advsimd
	TYPE: instruction
	XML: uaddlp_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|00|op=0|10|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UADDLP_asimdmisc_P
			OPERATION: UADDLP
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV (2*esize);
			boolean acc = (op == '1');
			boolean unsigned = (U == '1');

IFORM: UADDLV_advsimd
	TYPE: instruction
	XML: uaddlv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|11000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UADDLV_asimdall_only
			OPERATION: UADDLV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UADDL_advsimd
	TYPE: instruction
	XML: uaddl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|00|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UADDL_asimddiff_L
			OPERATION: UADDL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: UADDW_advsimd
	TYPE: instruction
	XML: uaddw_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|00|o1=0|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UADDW_asimddiff_W
			OPERATION: UADDW
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Ta>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: UBFIZ_UBFM
	TYPE: alias
	XML: ubfiz_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=x|opc=10|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UBFIZ_UBFM_32M_bitfield
			OPERATION: UBFIZ
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: UBFIZ_UBFM_64M_bitfield
			OPERATION: UBFIZ
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: UBFM
	TYPE: instruction
	XML: ubfm.xml
	ALIAS: LSL_UBFM
		imms != '011111' && imms + 1 == immr && EncodingLabeled32Bit()
		imms != '111111' && imms + 1 == immr && EncodingLabeled64Bit()
	ALIAS: LSR_UBFM
		imms == '011111' && EncodingLabeled32Bit()
		imms == '111111' && EncodingLabeled64Bit()
	ALIAS: UBFIZ_UBFM
		UInt(imms) < UInt(immr)
	ALIAS: UBFX_UBFM
		BFXPreferred(sf, opc<1>, imms, immr)
	ALIAS: UXTB_UBFM
		immr == '000000' && imms == '000111'
	ALIAS: UXTH_UBFM
		immr == '000000' && imms == '001111'
	CLASS: zero_fill
		FIELDS32: sf=x|opc=10|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UBFM_32M_bitfield
			OPERATION: UBFM
			SYNTAX: <Wd>,<Wn>, #<immr>, #<imms>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: UBFM_64M_bitfield
			OPERATION: UBFM
			SYNTAX: <Xd>,<Xn>, #<immr>, #<imms>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer datasize = if sf == '1' then 64 else 32;
			boolean inzero;
			boolean extend;
			integer R;
			integer S;
			bits(datasize) wmask;
			bits(datasize) tmask;
			case opc of
			    when '00' inzero = TRUE;  extend = TRUE;    // SBFM
			    when '01' inzero = FALSE; extend = FALSE;   // BFM
			    when '10' inzero = TRUE;  extend = FALSE;   // UBFM
			    when '11' UNDEFINED;
			if sf == '1' && N != '1' then UNDEFINED;
			if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
			R = UInt(immr);
			S = UInt(imms);
			(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

IFORM: UBFX_UBFM
	TYPE: alias
	XML: ubfx_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=x|opc=10|100110|N=x|immr=xxxxxx|imms=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UBFX_UBFM_32M_bitfield
			OPERATION: UBFX
			SYNTAX: <Wd>,<Wn>, #<lsb>, #<width>
			BITDIFFS: sf == '0' && N == '0'
			LABEL: 32-bit
		ENCODING: UBFX_UBFM_64M_bitfield
			OPERATION: UBFX
			SYNTAX: <Xd>,<Xn>, #<lsb>, #<width>
			BITDIFFS: sf == '1' && N == '1'
			LABEL: 64-bit

IFORM: UCVTF_advsimd_fix
	TYPE: instruction
	XML: ucvtf_advsimd_fix.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|opcode=11100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asisdshf_C
			OPERATION: UCVTF
			SYNTAX: <V><d>,<V><n>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = esize;
			integer elements = 1;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|opcode=11100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asimdshf_C
			OPERATION: UCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<fbits>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer fracbits = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			FPRounding rounding = FPRoundingMode(FPCR[]);

IFORM: UCVTF_advsimd_int
	TYPE: instruction
	XML: ucvtf_advsimd_int.xml
	CLASS: sisd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 01|U=1|11110|a=0|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asisdmiscfp16_R
			OPERATION: UCVTF
			SYNTAX: <Hd>,<Hn>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: sisd_single_and_double
		FIELDS32: 01|U=1|11110|0|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asisdmisc_R
			OPERATION: UCVTF
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 32 << UInt(sz);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd_half
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_FP16
		FIELDS32: 0|Q=x|U=1|01110|a=0|111100|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asimdmiscfp16_R
			OPERATION: UCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			if !HaveFP16Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 16;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
	CLASS: simd_single_and_double
		FIELDS32: 0|Q=x|U=1|01110|0|sz=x|10000|opcode=11101|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_asimdmisc_R
			OPERATION: UCVTF
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz:Q == '10' then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UCVTF_float_fix
	TYPE: instruction
	XML: ucvtf_float_fix.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|0|rmode=00|opcode=011|scale=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_H32_float2fix
			OPERATION: UCVTF
			SYNTAX: <Hd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: UCVTF_S32_float2fix
			OPERATION: UCVTF
			SYNTAX: <Sd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: UCVTF_D32_float2fix
			OPERATION: UCVTF
			SYNTAX: <Dd>,<Wn>, #<fbits>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: UCVTF_H64_float2fix
			OPERATION: UCVTF
			SYNTAX: <Hd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: UCVTF_S64_float2fix
			OPERATION: UCVTF
			SYNTAX: <Sd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: UCVTF_D64_float2fix
			OPERATION: UCVTF
			SYNTAX: <Dd>,<Xn>, #<fbits>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			case ftype of
			    when '00' fltsize = 32;
			    when '01' fltsize = 64;
			    when '10' UNDEFINED;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			if sf == '0' && scale<5> == '0' then UNDEFINED;
			integer fracbits = 64 - UInt(scale);
			case opcode<2:1>:rmode of
			    when '00 11'        // FCVTZ
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    otherwise
			        UNDEFINED;

IFORM: UCVTF_float_int
	TYPE: instruction
	XML: ucvtf_float_int.xml
	CLASS: float
		FIELDS32: sf=x|0|S=0|11110|ftype=xx|1|rmode=00|opcode=011|000000|Rn=xxxxx|Rd=xxxxx
		ENCODING: UCVTF_H32_float2int
			OPERATION: UCVTF
			SYNTAX: <Hd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '11'
		ENCODING: UCVTF_S32_float2int
			OPERATION: UCVTF
			SYNTAX: <Sd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '00'
		ENCODING: UCVTF_D32_float2int
			OPERATION: UCVTF
			SYNTAX: <Dd>,<Wn>
			BITDIFFS: sf == '0' && ftype == '01'
		ENCODING: UCVTF_H64_float2int
			OPERATION: UCVTF
			SYNTAX: <Hd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '11'
		ENCODING: UCVTF_S64_float2int
			OPERATION: UCVTF
			SYNTAX: <Sd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '00'
		ENCODING: UCVTF_D64_float2int
			OPERATION: UCVTF
			SYNTAX: <Dd>,<Xn>
			BITDIFFS: sf == '1' && ftype == '01'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer intsize = if sf == '1' then 64 else 32;
			integer fltsize;
			FPConvOp op;
			FPRounding rounding;
			boolean unsigned;
			integer part;
			case ftype of
			    when '00'
			        fltsize = 32;
			    when '01'
			        fltsize = 64;
			    when '10'
			        if opcode<2:1>:rmode != '11 01' then UNDEFINED;
			        fltsize = 128;
			    when '11'
			        if HaveFP16Ext() then
			            fltsize = 16;
			        else
			            UNDEFINED;
			case opcode<2:1>:rmode of
			    when '00 xx'        // FCVT[NPMZ][US]
			        rounding = FPDecodeRounding(rmode);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '01 00'        // [US]CVTF
			        rounding = FPRoundingMode(FPCR[]);
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_ItoF;
			    when '10 00'        // FCVTA[US]
			        rounding = FPRounding_TIEAWAY;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI;
			    when '11 00'        // FMOV
			        if fltsize != 16 && fltsize != intsize then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 0;
			    when '11 01'        // FMOV D[1]
			        if intsize != 64 || fltsize != 128 then UNDEFINED;
			        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
			        part = 1;
			        fltsize = 64;  // size of D[1] is 64
			    when '11 11'       // FJCVTZS
			        if !HaveFJCVTZSExt() then UNDEFINED;
			        rounding = FPRounding_ZERO;
			        unsigned = (opcode<0> == '1');
			        op = FPConvOp_CVT_FtoI_JS;
			    otherwise
			        UNDEFINED;

IFORM: UDF_perm_undef
	TYPE: instruction
	XML: udf_perm_undef.xml
	CLASS: general
		FIELDS32: 0000000000000000|imm16=xxxxxxxxxxxxxxxx
		ENCODING: UDF_only_perm_undef
			OPERATION: UDF
			SYNTAX: #<imm>

IFORM: UDIV
	TYPE: instruction
	XML: udiv.xml
	CLASS: general
		FIELDS32: sf=x|op=0|S=0|11010110|Rm=xxxxx|opcode2<5:1>=00001|o1=0|Rn=xxxxx|Rd=xxxxx
		ENCODING: UDIV_32_dp_2src
			OPERATION: UDIV
			SYNTAX: <Wd>,<Wn>,<Wm>
			BITDIFFS: sf == '0'
			LABEL: 32-bit
		ENCODING: UDIV_64_dp_2src
			OPERATION: UDIV
			SYNTAX: <Xd>,<Xn>,<Xm>
			BITDIFFS: sf == '1'
			LABEL: 64-bit
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer datasize = if sf == '1' then 64 else 32;
			boolean unsigned = (o1 == '0');

IFORM: UDOT_advsimd_elt
	TYPE: instruction
	XML: udot_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_DotProd
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1110|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: UDOT_asimdelem_D
			OPERATION: UDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.4B[<index>]
		DECODE_PCODE:
			if !HaveDOTPExt() then UNDEFINED;
			if size  != '10' then UNDEFINED;
			boolean signed = (U=='0');
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			integer index = UInt(H:L);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: UDOT_advsimd_vec
	TYPE: instruction
	XML: udot_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_DotProd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|0|Rm=xxxxx|1|opcode=0010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UDOT_asimdsame2_D
			OPERATION: UDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveDOTPExt() then UNDEFINED;
			if size!= '10' then UNDEFINED;
			boolean signed = (U=='0');
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: UHADD_advsimd
	TYPE: instruction
	XML: uhadd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=00000|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UHADD_asimdsame_only
			OPERATION: UHADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UHSUB_advsimd
	TYPE: instruction
	XML: uhsub_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=00100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UHSUB_asimdsame_only
			OPERATION: UHSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UMADDL
	TYPE: instruction
	XML: umaddl.xml
	ALIAS: UMULL_UMADDL
		Ra == '11111'
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=1|01|Rm=xxxxx|o0=0|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMADDL_64WA_dp_3src
			OPERATION: UMADDL
			SYNTAX: <Xd>,<Wn>,<Wm>,<Xa>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = 64;
			integer datasize = 32;
			boolean sub_op = (o0 == '1');
			boolean unsigned = (U == '1');

IFORM: UMAXP_advsimd
	TYPE: instruction
	XML: umaxp_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|1010|o1=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMAXP_asimdsame_only
			OPERATION: UMAXP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: UMAXV_advsimd
	TYPE: instruction
	XML: umaxv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|11000|op=0|1010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMAXV_asimdall_only
			OPERATION: UMAXV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean min = (op == '1');

IFORM: UMAX_advsimd
	TYPE: instruction
	XML: umax_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0110|o1=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMAX_asimdsame_only
			OPERATION: UMAX
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: UMINP_advsimd
	TYPE: instruction
	XML: uminp_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|1010|o1=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMINP_asimdsame_only
			OPERATION: UMINP
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: UMINV_advsimd
	TYPE: instruction
	XML: uminv_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|11000|op=1|1010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMINV_asimdall_only
			OPERATION: UMINV
			SYNTAX: <V><d>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '100' then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean min = (op == '1');

IFORM: UMIN_advsimd
	TYPE: instruction
	XML: umin_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|0110|o1=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMIN_asimdsame_only
			OPERATION: UMIN
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean minimum = (o1 == '1');

IFORM: UMLAL_advsimd_elt
	TYPE: instruction
	XML: umlal_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=0|10|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMLAL_asimdelem_L
			OPERATION: UMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean sub_op = (o2 == '1');

IFORM: UMLAL_advsimd_vec
	TYPE: instruction
	XML: umlal_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|10|o1=0|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMLAL_asimddiff_L
			OPERATION: UMLAL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: UMLSL_advsimd_elt
	TYPE: instruction
	XML: umlsl_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|0|o2=1|10|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMLSL_asimdelem_L
			OPERATION: UMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean sub_op = (o2 == '1');

IFORM: UMLSL_advsimd_vec
	TYPE: instruction
	XML: umlsl_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|10|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMLSL_asimddiff_L
			OPERATION: UMLSL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: UMMLA_advsimd_vec
	TYPE: instruction
	XML: ummla_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=1|U=1|01110|size=10|0|Rm=xxxxx|1|010|B=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMMLA_asimdsame2_G
			OPERATION: UMMLA
			SYNTAX: <Vd>.4S,<Vn>.16B,<Vm>.16B
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			case B:U of
			    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
			    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
			    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
			    when '11' UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);

IFORM: UMNEGL_UMSUBL
	TYPE: alias
	XML: umnegl_umsubl.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=1|01|Rm=xxxxx|o0=1|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMNEGL_UMSUBL_64WA_dp_3src
			OPERATION: UMNEGL
			SYNTAX: <Xd>,<Wn>,<Wm>

IFORM: UMOV_advsimd
	TYPE: instruction
	XML: umov_advsimd.xml
	ALIAS: MOV_UMOV_advsimd
		imm5 == 'x1000'
		imm5 == 'xx100'
	CLASS: advsimd
		FIELDS32: 0|Q=x|op=0|01110000|imm5=xxxxx|0|imm4<3:2>=01|imm4=11|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMOV_asimdins_W_w
			OPERATION: UMOV
			SYNTAX: <Wd>,<Vn>.<Ts>[<index>]
			BITDIFFS: Q == '0'
			LABEL: 32-bit
		ENCODING: UMOV_asimdins_X_x
			OPERATION: UMOV
			SYNTAX: <Xd>,<Vn>.<Ts>[<index>]
			BITDIFFS: Q == '1' && imm5 == 'x1000'
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer size;
			case Q:imm5 of
			    when '0xxxx1' size = 0;     // UMOV Wd, Vn.B
			    when '0xxx10' size = 1;     // UMOV Wd, Vn.H
			    when '0xx100' size = 2;     // UMOV Wd, Vn.S
			    when '1x1000' size = 3;     // UMOV Xd, Vn.D
			    otherwise     UNDEFINED;
			integer idxdsize = if imm5<4> == '1' then 128 else 64;
			integer index = UInt(imm5<4:size+1>);
			integer esize = 8 << size;
			integer datasize = if Q == '1' then 64 else 32;

IFORM: UMSUBL
	TYPE: instruction
	XML: umsubl.xml
	ALIAS: UMNEGL_UMSUBL
		Ra == '11111'
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=1|01|Rm=xxxxx|o0=1|Ra=xxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMSUBL_64WA_dp_3src
			OPERATION: UMSUBL
			SYNTAX: <Xd>,<Wn>,<Wm>,<Xa>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);
			integer destsize = 64;
			integer datasize = 32;
			boolean sub_op = (o0 == '1');
			boolean unsigned = (U == '1');

IFORM: UMULH
	TYPE: instruction
	XML: umulh.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=1|10|Rm=xxxxx|o0=0|Ra=(1)(1)(1)(1)(1)|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMULH_64_dp_3src
			OPERATION: UMULH
			SYNTAX: <Xd>,<Xn>,<Xm>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer a = UInt(Ra);           // ignored by UMULH/SMULH
			integer destsize = 64;
			integer datasize = destsize;
			boolean unsigned = (U == '1');

IFORM: UMULL_UMADDL
	TYPE: alias
	XML: umull_umaddl.xml
	CLASS: 64
		FIELDS32: sf=1|op54=00|11011|U=1|01|Rm=xxxxx|o0=0|Ra=11111|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMULL_UMADDL_64WA_dp_3src
			OPERATION: UMULL
			SYNTAX: <Xd>,<Wn>,<Wm>

IFORM: UMULL_advsimd_elt
	TYPE: instruction
	XML: umull_advsimd_elt.xml
	CLASS: 2reg_element
		FIELDS32: 0|Q=x|U=1|01111|size=xx|L=x|M=x|Rm=xxxx|opcode=1010|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMULL_asimdelem_L
			OPERATION: UMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Ts>[<index>]
		DECODE_PCODE:
			integer idxdsize = if H == '1' then 128 else 64;
			integer index;
			bit Rmhi;
			case size of
			    when '01' index = UInt(H:L:M); Rmhi = '0';
			    when '10' index = UInt(H:L);   Rmhi = M;
			    otherwise UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rmhi:Rm);
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UMULL_advsimd_vec
	TYPE: instruction
	XML: umull_advsimd_vec.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=1100|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: UMULL_asimddiff_L
			OPERATION: UMULL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UQADD_advsimd
	TYPE: instruction
	XML: uqadd_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|opcode=00001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQADD_asisdsame_only
			OPERATION: UQADD
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=00001|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQADD_asimdsame_only
			OPERATION: UQADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UQRSHL_advsimd
	TYPE: instruction
	XML: uqrshl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|010|R=1|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQRSHL_asisdsame_only
			OPERATION: UQRSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|010|R=1|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQRSHL_asimdsame_only
			OPERATION: UQRSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: UQRSHRN_advsimd
	TYPE: instruction
	XML: uqrshrn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|1001|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQRSHRN_asisdshf_N
			OPERATION: UQRSHRN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|1001|op=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQRSHRN_asimdshf_N
			OPERATION: UQRSHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');

IFORM: UQSHL_advsimd_imm
	TYPE: instruction
	XML: uqshl_advsimd_imm.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|011|op=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHL_asisdshf_R
			OPERATION: UQSHL
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|011|op=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHL_asimdshf_R
			OPERATION: UQSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;
			boolean src_unsigned;
			boolean dst_unsigned;
			case op:U of
			    when '00' UNDEFINED;
			    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
			    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
			    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

IFORM: UQSHL_advsimd_reg
	TYPE: instruction
	XML: uqshl_advsimd_reg.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|010|R=0|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHL_asisdsame_only
			OPERATION: UQSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|010|R=0|S=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHL_asimdsame_only
			OPERATION: UQSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: UQSHRN_advsimd
	TYPE: instruction
	XML: uqshrn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|1001|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHRN_asisdshf_N
			OPERATION: UQSHRN
			SYNTAX: <Vb><d>,<Va><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then UNDEFINED;
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = esize;
			integer elements = 1;
			integer part = 0;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|1001|op=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSHRN_asimdshf_N
			OPERATION: UQSHRN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = (2 * esize) - UInt(immh:immb);
			boolean round = (op == '1');
			boolean unsigned = (U == '1');

IFORM: UQSUB_advsimd
	TYPE: instruction
	XML: uqsub_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|opcode=00101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSUB_asisdsame_only
			OPERATION: UQSUB
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=00101|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQSUB_asimdsame_only
			OPERATION: UQSUB
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: UQXTN_advsimd
	TYPE: instruction
	XML: uqxtn_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|opcode=10100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQXTN_asisdmisc_N
			OPERATION: UQXTN
			SYNTAX: <Vb><d>,<Va><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer part = 0;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=10100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UQXTN_asimdmisc_N
			OPERATION: UQXTN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: URECPE_advsimd
	TYPE: instruction
	XML: urecpe_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|1|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: URECPE_asimdmisc_R
			OPERATION: URECPE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: URHADD_advsimd
	TYPE: instruction
	XML: urhadd_advsimd.xml
	CLASS: 3reg_same
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|opcode=00010|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URHADD_asimdsame_only
			OPERATION: URHADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: URSHL_advsimd
	TYPE: instruction
	XML: urshl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|010|R=1|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSHL_asisdsame_only
			OPERATION: URSHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|010|R=1|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSHL_asimdsame_only
			OPERATION: URSHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: URSHR_advsimd
	TYPE: instruction
	XML: urshr_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|00|o1=1|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSHR_asisdshf_R
			OPERATION: URSHR
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|00|o1=1|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSHR_asimdshf_R
			OPERATION: URSHR
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: URSQRTE_advsimd
	TYPE: instruction
	XML: ursqrte_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|1|sz=x|10000|opcode=11100|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSQRTE_asimdmisc_R
			OPERATION: URSQRTE
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if sz == '1' then UNDEFINED;
			integer esize = 32;
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;

IFORM: URSRA_advsimd
	TYPE: instruction
	XML: ursra_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|00|o1=1|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSRA_asisdshf_R
			OPERATION: URSRA
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|00|o1=1|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: URSRA_asimdshf_R
			OPERATION: URSRA
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: USDOT_advsimd_elt
	TYPE: instruction
	XML: usdot_advsimd_elt.xml
	CLASS: 2reg_element
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=x|U=0|01111|US=1|0|L=x|M=x|Rm=xxxx|opcode=1111|H=x|0|Rn=xxxxx|Rd=xxxxx
		ENCODING: USDOT_asimdelem_D
			OPERATION: USDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.4B[<index>]
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			boolean op1_unsigned = (US == '1');
			boolean op2_unsigned = (US == '0');
			integer n = UInt(Rn);
			integer m = UInt(M:Rm);
			integer d = UInt(Rd);
			integer i = UInt(H:L);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 32;

IFORM: USDOT_advsimd_vec
	TYPE: instruction
	XML: usdot_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=x|U=0|01110|size=10|0|Rm=xxxxx|1|opcode=0011|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USDOT_asimdsame2_D
			OPERATION: USDOT
			SYNTAX: <Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV 32;

IFORM: USHLL_advsimd
	TYPE: instruction
	XML: ushll_advsimd.xml
	ALIAS: UXTL_USHLL_advsimd
		immb == '000' && BitCount(immh) == 1
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|opcode=10100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USHLL_asimdshf_L
			OPERATION: USHLL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3> == '1' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			integer shift = UInt(immh:immb) - esize;
			boolean unsigned = (U == '1');

IFORM: USHL_advsimd
	TYPE: instruction
	XML: ushl_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|1|Rm=xxxxx|010|R=0|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USHL_asisdsame_only
			OPERATION: USHL
			SYNTAX: <V><d>,<V><n>,<V><m>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');
			if S == '0' && size != '11' then UNDEFINED;
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|010|R=0|S=0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USHL_asimdsame_only
			OPERATION: USHL
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');
			boolean rounding = (R == '1');
			boolean saturating = (S == '1');

IFORM: USHR_advsimd
	TYPE: instruction
	XML: ushr_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|00|o1=0|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USHR_asisdshf_R
			OPERATION: USHR
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|00|o1=0|o0=0|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USHR_asimdshf_R
			OPERATION: USHR
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: USMMLA_advsimd_vec
	TYPE: instruction
	XML: usmmla_advsimd_vec.xml
	CLASS: simd
		ARCH_VARIANT: ARMv8.6
		ARCH_FEATURE: FEAT_I8MM
		FIELDS32: 0|Q=1|U=0|01110|size=10|0|Rm=xxxxx|1|010|B=1|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USMMLA_asimdsame2_G
			OPERATION: USMMLA
			SYNTAX: <Vd>.4S,<Vn>.16B,<Vm>.16B
		DECODE_PCODE:
			if !HaveInt8MatMulExt() then UNDEFINED;
			case B:U of
			    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
			    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
			    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
			    when '11' UNDEFINED;
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Rd);

IFORM: USQADD_advsimd
	TYPE: instruction
	XML: usqadd_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|11110|size=xx|10000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: USQADD_asisdmisc_R
			OPERATION: USQADD
			SYNTAX: <V><d>,<V><n>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer esize = 8 << UInt(size);
			integer datasize = esize;
			integer elements = 1;
			boolean unsigned = (U == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|01110|size=xx|10000|opcode=00011|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: USQADD_asimdmisc_R
			OPERATION: USQADD
			SYNTAX: <Vd>.<T>,<Vn>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			boolean unsigned = (U == '1');

IFORM: USRA_advsimd
	TYPE: instruction
	XML: usra_advsimd.xml
	CLASS: sisd
		FIELDS32: 01|U=1|111110|immh!=0000|immb=xxx|00|o1=0|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USRA_asisdshf_R
			OPERATION: USRA
			SYNTAX: <V><d>,<V><n>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh<3> != '1' then UNDEFINED;
			integer esize = 8 << 3;
			integer datasize = esize;
			integer elements = 1;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=xxx|00|o1=0|o0=1|0|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: USRA_asimdshf_R
			OPERATION: USRA
			SYNTAX: <Vd>.<T>,<Vn>.<T>, #<shift>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if immh == '0000' then SEE(asimdimm);
			if immh<3>:Q == '10' then UNDEFINED;
			integer esize = 8 << HighestSetBit(immh);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer shift = (esize * 2) - UInt(immh:immb);
			boolean unsigned = (U == '1');
			boolean round = (o1 == '1');
			boolean accumulate = (o0 == '1');

IFORM: USUBL_advsimd
	TYPE: instruction
	XML: usubl_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|00|o1=1|0|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: USUBL_asimddiff_L
			OPERATION: USUBL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: USUBW_advsimd
	TYPE: instruction
	XML: usubw_advsimd.xml
	CLASS: 3reg_diff
		FIELDS32: 0|Q=x|U=1|01110|size=xx|1|Rm=xxxxx|00|o1=1|1|00|Rn=xxxxx|Rd=xxxxx
		ENCODING: USUBW_asimddiff_W
			OPERATION: USUBW
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Ta>,<Vm>.<Tb>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;
			boolean sub_op = (o1 == '1');
			boolean unsigned = (U == '1');

IFORM: UXTB_UBFM
	TYPE: alias
	XML: uxtb_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=0|opc=10|100110|N=0|immr=000000|imms=000111|Rn=xxxxx|Rd=xxxxx
		ENCODING: UXTB_UBFM_32M_bitfield
			OPERATION: UXTB
			SYNTAX: <Wd>,<Wn>
			LABEL: 32-bit

IFORM: UXTH_UBFM
	TYPE: alias
	XML: uxth_ubfm.xml
	CLASS: zero_fill
		FIELDS32: sf=0|opc=10|100110|N=0|immr=000000|imms=001111|Rn=xxxxx|Rd=xxxxx
		ENCODING: UXTH_UBFM_32M_bitfield
			OPERATION: UXTH
			SYNTAX: <Wd>,<Wn>
			LABEL: 32-bit

IFORM: UXTL_USHLL_advsimd
	TYPE: alias
	XML: uxtl_ushll_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=1|011110|immh!=0000|immb=000|opcode=10100|1|Rn=xxxxx|Rd=xxxxx
		ENCODING: UXTL_USHLL_asimdshf_L
			OPERATION: UXTL
			SYNTAX: {2}<Vd>.<Ta>,<Vn>.<Tb>

IFORM: UZP1_advsimd
	TYPE: instruction
	XML: uzp1_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=0|01|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UZP1_asimdperm_only
			OPERATION: UZP1
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);

IFORM: UZP2_advsimd
	TYPE: instruction
	XML: uzp2_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=1|01|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: UZP2_asimdperm_only
			OPERATION: UZP2
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);

IFORM: WFE
	TYPE: instruction
	XML: wfe.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=010|Rt=11111
		ENCODING: WFE_HI_hints
			OPERATION: WFE
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: WFET
	TYPE: instruction
	XML: wfet.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_WFxT
		FIELDS32: 11010101000000110001|CRm=0000|op2=000|Rd=xxxxx
		ENCODING: WFET_only_systeminstrswithreg
			OPERATION: WFET
			SYNTAX: <Xt>
		DECODE_PCODE:
			if !HaveFeatWFxT() then UNDEFINED;
			integer d = UInt(Rd);
			SystemHintOp op;
			case op2 of
			    when '000' op = SystemHintOp_WFET;
			    when '001' op = SystemHintOp_WFIT;
			    otherwise   // Do nothing

IFORM: WFI
	TYPE: instruction
	XML: wfi.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=011|Rt=11111
		ENCODING: WFI_HI_hints
			OPERATION: WFI
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: WFIT
	TYPE: instruction
	XML: wfit.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.7
		ARCH_FEATURE: FEAT_WFxT
		FIELDS32: 11010101000000110001|CRm=0000|op2=001|Rd=xxxxx
		ENCODING: WFIT_only_systeminstrswithreg
			OPERATION: WFIT
			SYNTAX: <Xt>
		DECODE_PCODE:
			if !HaveFeatWFxT() then UNDEFINED;
			integer d = UInt(Rd);
			SystemHintOp op;
			case op2 of
			    when '000' op = SystemHintOp_WFET;
			    when '001' op = SystemHintOp_WFIT;
			    otherwise   // Do nothing

IFORM: XAFLAG
	TYPE: instruction
	XML: xaflag.xml
	CLASS: system
		ARCH_VARIANT: ARMv8.5
		ARCH_FEATURE: FEAT_FlagM2
		FIELDS32: 1101010100|L=0|op0=00|op1=000|CRn=0100|CRm=(0)(0)(0)(0)|op2=001|Rt =11111
		ENCODING: XAFLAG_M_pstate
			OPERATION: XAFLAG
			SYNTAX: 
		DECODE_PCODE:
			if !HaveFlagFormatExt() then UNDEFINED;

IFORM: XAR_advsimd
	TYPE: instruction
	XML: xar_advsimd.xml
	CLASS: advsimd
		ARCH_VARIANT: ARMv8.2
		ARCH_FEATURE: FEAT_SHA3
		FIELDS32: 11001110100|Rm=xxxxx|imm6=xxxxxx|Rn=xxxxx|Rd=xxxxx
		ENCODING: XAR_VVV2_crypto3_imm6
			OPERATION: XAR
			SYNTAX: <Vd>.2D,<Vn>.2D,<Vm>.2D, #<imm6>
		DECODE_PCODE:
			if !HaveSHA3Ext() then UNDEFINED;
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);

IFORM: XPAC
	TYPE: instruction
	XML: xpac.xml
	CLASS: general
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: sf=1|1|S=0|11010110|opcode2=00001|opcode[5]=0|opcode[4]=1|opcode[3:1]=000|D=x|Rn=11111|Rd=xxxxx
		ENCODING: XPACD_64Z_dp_1src
			OPERATION: XPACD
			SYNTAX: <Xd>
			BITDIFFS: D == '1'
		ENCODING: XPACI_64Z_dp_1src
			OPERATION: XPACI
			SYNTAX: <Xd>
			BITDIFFS: D == '0'
		DECODE_PCODE:
			boolean data = (D == '1');
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if !HavePACExt() then
			    UNDEFINED;
			if n != 31 then UNDEFINED;
	CLASS: system
		ARCH_VARIANT: ARMv8.3
		ARCH_FEATURE: FEAT_PAuth
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=111|Rt=11111
		ENCODING: XPACLRI_HI_hints
			OPERATION: XPACLRI
			SYNTAX: 

IFORM: XTN_advsimd
	TYPE: instruction
	XML: xtn_advsimd.xml
	CLASS: simd
		FIELDS32: 0|Q=x|U=0|01110|size=xx|10000|opcode=10010|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: XTN_asimdmisc_N
			OPERATION: XTN
			SYNTAX: {2}<Vd>.<Tb>,<Vn>.<Ta>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = 64;
			integer part = UInt(Q);
			integer elements = datasize DIV esize;

IFORM: YIELD
	TYPE: instruction
	XML: yield.xml
	CLASS: system
		FIELDS32: 1101010100|L=0|op0=00|op1=011|CRn=0010|CRm=0000|op2=001|Rt=11111
		ENCODING: YIELD_HI_hints
			OPERATION: YIELD
			SYNTAX: 
		DECODE_PCODE:
			SystemHintOp op;
			case CRm:op2 of
			    when '0000 000' op = SystemHintOp_NOP;
			    when '0000 001' op = SystemHintOp_YIELD;
			    when '0000 010' op = SystemHintOp_WFE;
			    when '0000 011' op = SystemHintOp_WFI;
			    when '0000 100' op = SystemHintOp_SEV;
			    when '0000 101' op = SystemHintOp_SEVL;
			    when '0000 110'
			        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_DGH;
			    when '0000 111' SEE "XPACLRI";
			    when '0001 xxx'
			        case op2 of
			            when '000' SEE "PACIA1716";
			            when '010' SEE "PACIB1716";
			            when '100' SEE "AUTIA1716";
			            when '110' SEE "AUTIB1716";
			            otherwise EndOfInstruction();                          // Instruction executes as NOP
			    when '0010 000'
			        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
			        op = SystemHintOp_ESB;
			    when '0010 001'
			        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
			        op = SystemHintOp_PSB;
			    when '0010 010'
			        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
			        op = SystemHintOp_TSB;
			    when '0010 100'
			        op = SystemHintOp_CSDB;
			    when '0011 xxx'
			        case op2 of
			            when '000' SEE "PACIAZ";
			            when '001' SEE "PACIASP";
			            when '010' SEE "PACIBZ";
			            when '011' SEE "PACIBSP";
			            when '100' SEE "AUTIAZ";
			            when '101' SEE "AUTHASP";
			            when '110' SEE "AUTIBZ";
			            when '111' SEE "AUTIBSP";
			    when '0100 xx0'
			        op = SystemHintOp_BTI;
			        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
			        SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
			    otherwise EndOfInstruction();                                 // Instruction executes as NOP

IFORM: ZIP1_advsimd
	TYPE: instruction
	XML: zip1_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=0|11|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ZIP1_asimdperm_only
			OPERATION: ZIP1
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);
			integer pairs = elements DIV 2;

IFORM: ZIP2_advsimd
	TYPE: instruction
	XML: zip2_advsimd.xml
	CLASS: advsimd
		FIELDS32: 0|Q=x|001110|size=xx|0|Rm=xxxxx|0|op=1|11|10|Rn=xxxxx|Rd=xxxxx
		ENCODING: ZIP2_asimdperm_only
			OPERATION: ZIP2
			SYNTAX: <Vd>.<T>,<Vn>.<T>,<Vm>.<T>
		DECODE_PCODE:
			integer d = UInt(Rd);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			if size:Q == '110' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer datasize = if Q == '1' then 128 else 64;
			integer elements = datasize DIV esize;
			integer part = UInt(op);
			integer pairs = elements DIV 2;

IFORM: abs_z_p_z
	TYPE: instruction
	XML: abs_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|opc<2:1>=11|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: abs_z_p_z_
			OPERATION: ABS
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: add_z_p_zz
	TYPE: instruction
	XML: add_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|000|opc<2:1>=00|opc<0>=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: add_z_p_zz_
			OPERATION: ADD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: add_z_zi
	TYPE: instruction
	XML: add_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|opc<2:1>=00|opc<0>=0|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: add_z_zi_
			OPERATION: ADD
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: add_z_zz
	TYPE: instruction
	XML: add_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|opc<2:1>=00|opc<0>=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: add_z_zz_
			OPERATION: ADD
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: addpl_r_ri
	TYPE: instruction
	XML: addpl_r_ri.xml
	CLASS: sve
		FIELDS32: 000001000|op=1|1|Rn=xxxxx|01010|imm6=xxxxxx|Rd=xxxxx
		ENCODING: addpl_r_ri_
			OPERATION: ADDPL
			SYNTAX: <Xd|SP>,<Xn|SP>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Rn);
			integer d = UInt(Rd);
			integer imm = SInt(imm6);

IFORM: addvl_r_ri
	TYPE: instruction
	XML: addvl_r_ri.xml
	CLASS: sve
		FIELDS32: 000001000|op=0|1|Rn=xxxxx|01010|imm6=xxxxxx|Rd=xxxxx
		ENCODING: addvl_r_ri_
			OPERATION: ADDVL
			SYNTAX: <Xd|SP>,<Xn|SP>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Rn);
			integer d = UInt(Rd);
			integer imm = SInt(imm6);

IFORM: adr_z_az
	TYPE: instruction
	XML: adr_z_az.xml
	CLASS: off_pkd
		FIELDS32: 00000100|1|sz=x|1|Zm=xxxxx|1010|msz=xx|Zn=xxxxx|Zd=xxxxx
		ENCODING: adr_z_az_sd_same_scaled
			OPERATION: ADR
			SYNTAX: <Zd>.<T>, [<Zn>.<T>,<Zm>.<T>{,<mod><amount>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer osize = esize;
			boolean unsigned = TRUE;
			integer mbytes = 1 << UInt(msz);
	CLASS: off_s_s32
		FIELDS32: 00000100|opc=00|1|Zm=xxxxx|1010|msz=xx|Zn=xxxxx|Zd=xxxxx
		ENCODING: adr_z_az_d_s32_scaled
			OPERATION: ADR
			SYNTAX: <Zd>.D, [<Zn>.D,<Zm>.D, SXTW{<amount>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer osize = 32;
			boolean unsigned = FALSE;
			integer mbytes = 1 << UInt(msz);
	CLASS: off_s_u32
		FIELDS32: 00000100|opc=01|1|Zm=xxxxx|1010|msz=xx|Zn=xxxxx|Zd=xxxxx
		ENCODING: adr_z_az_d_u32_scaled
			OPERATION: ADR
			SYNTAX: <Zd>.D, [<Zn>.D,<Zm>.D, UXTW{<amount>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer osize = 32;
			boolean unsigned = TRUE;
			integer mbytes = 1 << UInt(msz);

IFORM: and_p_p_pp
	TYPE: instruction
	XML: and_p_p_pp.xml
	ALIAS: MOVS_and_p_p_pp
		S == '1' && Pn == Pm
	ALIAS: MOV_and_p_p_pp
		S == '0' && Pn == Pm
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: and_p_p_pp_z
			OPERATION: AND
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: ands_p_p_pp_z
			OPERATION: ANDS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: and_z_p_zz
	TYPE: instruction
	XML: and_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=01|opc<0>=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: and_z_p_zz_
			OPERATION: AND
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: and_z_zi
	TYPE: instruction
	XML: and_z_zi.xml
	ALIAS: BIC_and_z_zi
		Never
	CLASS: sve
		FIELDS32: 00000101|opc=10|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: and_z_zi_
			OPERATION: AND
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer dn = UInt(Zdn);
			bits(64) imm;
			(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

IFORM: and_z_zz
	TYPE: instruction
	XML: and_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|opc=00|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: and_z_zz_
			OPERATION: AND
			SYNTAX: <Zd>.D,<Zn>.D,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: andv_r_p_z
	TYPE: instruction
	XML: andv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=01|opc<0>=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: andv_r_p_z_
			OPERATION: ANDV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: asr_z_p_zi
	TYPE: instruction
	XML: asr_z_p_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|00|opc=00|L=0|U=0|100|Pg=xxx|tszl=xx|imm3=xxx|Zdn=xxxxx
		ENCODING: asr_z_p_zi_
			OPERATION: ASR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer shift = (2 * esize) - UInt(tsize:imm3);

IFORM: asr_z_p_zw
	TYPE: instruction
	XML: asr_z_p_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|R=0|L=0|U=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: asr_z_p_zw_
			OPERATION: ASR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: asr_z_p_zz
	TYPE: instruction
	XML: asr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=0|L=0|U=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: asr_z_p_zz_
			OPERATION: ASR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: asr_z_zi
	TYPE: instruction
	XML: asr_z_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|1|tszl=xx|imm3=xxx|1001|0|U=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: asr_z_zi_
			OPERATION: ASR
			SYNTAX: <Zd>.<T>,<Zn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer shift = (2 * esize) - UInt(tsize:imm3);

IFORM: asr_z_zw
	TYPE: instruction
	XML: asr_z_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|1000|0|U=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: asr_z_zw_
			OPERATION: ASR
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: asrd_z_p_zi
	TYPE: instruction
	XML: asrd_z_p_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|00|opc=01|L=0|U=0|100|Pg=xxx|tszl=xx|imm3=xxx|Zdn=xxxxx
		ENCODING: asrd_z_p_zi_
			OPERATION: ASRD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer shift = (2 * esize) - UInt(tsize:imm3);

IFORM: asrr_z_p_zz
	TYPE: instruction
	XML: asrr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=1|L=0|U=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: asrr_z_p_zz_
			OPERATION: ASRR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: bfcvt_z_p_z
	TYPE: instruction
	XML: bfcvt_z_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|opc=10|0010|opc2=10|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: bfcvt_z_p_z_s2bf
			OPERATION: BFCVT
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: bfcvtnt_z_p_z
	TYPE: instruction
	XML: bfcvtnt_z_p_z.xml
	CLASS: sve
		FIELDS32: 01100100|opc=10|0010|opc2=10|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: bfcvtnt_z_p_z_s2bf
			OPERATION: BFCVTNT
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: bfdot_z_zzz
	TYPE: instruction
	XML: bfdot_z_zzz.xml
	CLASS: sve
		FIELDS32: 011001000|op=1|1|Zm=xxxxx|100000|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfdot_z_zzz_
			OPERATION: BFDOT
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: bfdot_z_zzzi
	TYPE: instruction
	XML: bfdot_z_zzzi.xml
	CLASS: sve
		FIELDS32: 011001000|op=1|1|i2=xx|Zm=xxx|010000|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfdot_z_zzzi_
			OPERATION: BFDOT
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer index = UInt(i2);

IFORM: bfmlalb_z_zzz
	TYPE: instruction
	XML: bfmlalb_z_zzz.xml
	CLASS: sve
		FIELDS32: 011001001|o2=1|1|Zm=xxxxx|10|op=0|00|T=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfmlalb_z_zzz_
			OPERATION: BFMLALB
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: bfmlalb_z_zzzi
	TYPE: instruction
	XML: bfmlalb_z_zzzi.xml
	CLASS: sve
		FIELDS32: 011001001|o2=1|1|i3h=xx|Zm=xxx|01|op=0|0|i3l=x|T=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfmlalb_z_zzzi_
			OPERATION: BFMLALB
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer index = UInt(i3h:i3l);

IFORM: bfmlalt_z_zzz
	TYPE: instruction
	XML: bfmlalt_z_zzz.xml
	CLASS: sve
		FIELDS32: 011001001|o2=1|1|Zm=xxxxx|10|op=0|00|T=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfmlalt_z_zzz_
			OPERATION: BFMLALT
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: bfmlalt_z_zzzi
	TYPE: instruction
	XML: bfmlalt_z_zzzi.xml
	CLASS: sve
		FIELDS32: 011001001|o2=1|1|i3h=xx|Zm=xxx|01|op=0|0|i3l=x|T=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfmlalt_z_zzzi_
			OPERATION: BFMLALT
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer index = UInt(i3h:i3l);

IFORM: bfmmla_z_zzz
	TYPE: instruction
	XML: bfmmla_z_zzz.xml
	CLASS: sve
		FIELDS32: 01100100|opc=01|1|Zm=xxxxx|111001|Zn=xxxxx|Zda=xxxxx
		ENCODING: bfmmla_z_zzz_
			OPERATION: BFMMLA
			SYNTAX: <Zda>.S,<Zn>.H,<Zm>.H
		DECODE_PCODE:
			if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: bic_p_p_pp
	TYPE: instruction
	XML: bic_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: bic_p_p_pp_z
			OPERATION: BIC
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: bics_p_p_pp_z
			OPERATION: BICS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: bic_z_p_zz
	TYPE: instruction
	XML: bic_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=01|opc<0>=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: bic_z_p_zz_
			OPERATION: BIC
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: bic_z_zz
	TYPE: instruction
	XML: bic_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|opc=11|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: bic_z_zz_
			OPERATION: BIC
			SYNTAX: <Zd>.D,<Zn>.D,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: brka_p_p_p
	TYPE: instruction
	XML: brka_p_p_p.xml
	CLASS: no_s
		FIELDS32: 00100101|B=0|S=0|01000001|Pg=xxxx|0|Pn=xxxx|M=x|Pd=xxxx
		ENCODING: brka_p_p_p_
			OPERATION: BRKA
			SYNTAX: <Pd>.B,<Pg>/<ZM>,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean merging = (M == '1');
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|B=0|S=1|01000001|Pg=xxxx|0|Pn=xxxx|M=0|Pd=xxxx
		ENCODING: brkas_p_p_p_z
			OPERATION: BRKAS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean merging = FALSE;
			boolean setflags = TRUE;

IFORM: brkb_p_p_p
	TYPE: instruction
	XML: brkb_p_p_p.xml
	CLASS: no_s
		FIELDS32: 00100101|B=1|S=0|01000001|Pg=xxxx|0|Pn=xxxx|M=x|Pd=xxxx
		ENCODING: brkb_p_p_p_
			OPERATION: BRKB
			SYNTAX: <Pd>.B,<Pg>/<ZM>,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean merging = (M == '1');
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|B=1|S=1|01000001|Pg=xxxx|0|Pn=xxxx|M=0|Pd=xxxx
		ENCODING: brkbs_p_p_p_z
			OPERATION: BRKBS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean merging = FALSE;
			boolean setflags = TRUE;

IFORM: brkn_p_p_pp
	TYPE: instruction
	XML: brkn_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 001001010|S=0|01100001|Pg=xxxx|0|Pn=xxxx|0|Pdm=xxxx
		ENCODING: brkn_p_p_pp_
			OPERATION: BRKN
			SYNTAX: <Pdm>.B,<Pg>/Z,<Pn>.B,<Pdm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer dm = UInt(Pdm);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 001001010|S=1|01100001|Pg=xxxx|0|Pn=xxxx|0|Pdm=xxxx
		ENCODING: brkns_p_p_pp_
			OPERATION: BRKNS
			SYNTAX: <Pdm>.B,<Pg>/Z,<Pn>.B,<Pdm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer dm = UInt(Pdm);
			boolean setflags = TRUE;

IFORM: brkpa_p_p_pp
	TYPE: instruction
	XML: brkpa_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|11|Pg=xxxx|0|Pn=xxxx|B=0|Pd=xxxx
		ENCODING: brkpa_p_p_pp_
			OPERATION: BRKPA
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|11|Pg=xxxx|0|Pn=xxxx|B=0|Pd=xxxx
		ENCODING: brkpas_p_p_pp_
			OPERATION: BRKPAS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: brkpb_p_p_pp
	TYPE: instruction
	XML: brkpb_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|11|Pg=xxxx|0|Pn=xxxx|B=1|Pd=xxxx
		ENCODING: brkpb_p_p_pp_
			OPERATION: BRKPB
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|11|Pg=xxxx|0|Pn=xxxx|B=1|Pd=xxxx
		ENCODING: brkpbs_p_p_pp_
			OPERATION: BRKPBS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: clasta_r_p_z
	TYPE: instruction
	XML: clasta_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|11000|B=0|101|Pg=xxx|Zm=xxxxx|Rdn=xxxxx
		ENCODING: clasta_r_p_z_
			OPERATION: CLASTA
			SYNTAX: <R><dn>,<Pg>,<R><dn>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Rdn);
			integer m = UInt(Zm);
			integer csize = if esize < 64 then 32 else 64;
			boolean isBefore = FALSE;

IFORM: clasta_v_p_z
	TYPE: instruction
	XML: clasta_v_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10101|B=0|100|Pg=xxx|Zm=xxxxx|Vdn=xxxxx
		ENCODING: clasta_v_p_z_
			OPERATION: CLASTA
			SYNTAX: <V><dn>,<Pg>,<V><dn>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Vdn);
			integer m = UInt(Zm);
			boolean isBefore = FALSE;

IFORM: clasta_z_p_zz
	TYPE: instruction
	XML: clasta_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10100|B=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: clasta_z_p_zz_
			OPERATION: CLASTA
			SYNTAX: <Zdn>.<T>,<Pg>,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean isBefore = FALSE;

IFORM: clastb_r_p_z
	TYPE: instruction
	XML: clastb_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|11000|B=1|101|Pg=xxx|Zm=xxxxx|Rdn=xxxxx
		ENCODING: clastb_r_p_z_
			OPERATION: CLASTB
			SYNTAX: <R><dn>,<Pg>,<R><dn>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Rdn);
			integer m = UInt(Zm);
			integer csize = if esize < 64 then 32 else 64;
			boolean isBefore = TRUE;

IFORM: clastb_v_p_z
	TYPE: instruction
	XML: clastb_v_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10101|B=1|100|Pg=xxx|Zm=xxxxx|Vdn=xxxxx
		ENCODING: clastb_v_p_z_
			OPERATION: CLASTB
			SYNTAX: <V><dn>,<Pg>,<V><dn>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Vdn);
			integer m = UInt(Zm);
			boolean isBefore = TRUE;

IFORM: clastb_z_p_zz
	TYPE: instruction
	XML: clastb_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10100|B=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: clastb_z_p_zz_
			OPERATION: CLASTB
			SYNTAX: <Zdn>.<T>,<Pg>,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean isBefore = TRUE;

IFORM: cls_z_p_z
	TYPE: instruction
	XML: cls_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: cls_z_p_z_
			OPERATION: CLS
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: clz_z_p_z
	TYPE: instruction
	XML: clz_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: clz_z_p_z_
			OPERATION: CLZ
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: cmpeq_p_p_zi
	TYPE: instruction
	XML: cmpeq_p_p_zi.xml
	CLASS: eq
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpeq_p_p_zi_
			OPERATION: CMPEQ
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_EQ;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;
	CLASS: gt
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=0|0|lt=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpgt_p_p_zi_
			OPERATION: CMPGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;
	CLASS: ge
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=0|0|lt=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpge_p_p_zi_
			OPERATION: CMPGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;
	CLASS: hi
		FIELDS32: 00100100|size=xx|1|imm7=xxxxxxx|lt=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmphi_p_p_zi_
			OPERATION: CMPHI
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			integer imm = UInt(imm7);
			boolean unsigned = TRUE;
	CLASS: hs
		FIELDS32: 00100100|size=xx|1|imm7=xxxxxxx|lt=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmphs_p_p_zi_
			OPERATION: CMPHS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			integer imm = UInt(imm7);
			boolean unsigned = TRUE;
	CLASS: lt
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=0|0|lt=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmplt_p_p_zi_
			OPERATION: CMPLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LT;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;
	CLASS: le
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=0|0|lt=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmple_p_p_zi_
			OPERATION: CMPLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LE;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;
	CLASS: lo
		FIELDS32: 00100100|size=xx|1|imm7=xxxxxxx|lt=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmplo_p_p_zi_
			OPERATION: CMPLO
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LT;
			integer imm = UInt(imm7);
			boolean unsigned = TRUE;
	CLASS: ls
		FIELDS32: 00100100|size=xx|1|imm7=xxxxxxx|lt=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpls_p_p_zi_
			OPERATION: CMPLS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LE;
			integer imm = UInt(imm7);
			boolean unsigned = TRUE;
	CLASS: ne
		FIELDS32: 00100101|size=xx|0|imm5=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpne_p_p_zi_
			OPERATION: CMPNE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_NE;
			integer imm = SInt(imm5);
			boolean unsigned = FALSE;

IFORM: cmpeq_p_p_zw
	TYPE: instruction
	XML: cmpeq_p_p_zw.xml
	CLASS: eq
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpeq_p_p_zw_
			OPERATION: CMPEQ
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_EQ;
			boolean unsigned = FALSE;
	CLASS: gt
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=0|1|lt=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpgt_p_p_zw_
			OPERATION: CMPGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			boolean unsigned = FALSE;
	CLASS: ge
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=0|1|lt=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpge_p_p_zw_
			OPERATION: CMPGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			boolean unsigned = FALSE;
	CLASS: hi
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=1|1|lt=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmphi_p_p_zw_
			OPERATION: CMPHI
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			boolean unsigned = TRUE;
	CLASS: hs
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=1|1|lt=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmphs_p_p_zw_
			OPERATION: CMPHS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			boolean unsigned = TRUE;
	CLASS: lt
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=0|1|lt=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmplt_p_p_zw_
			OPERATION: CMPLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LT;
			boolean unsigned = FALSE;
	CLASS: le
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=0|1|lt=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmple_p_p_zw_
			OPERATION: CMPLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LE;
			boolean unsigned = FALSE;
	CLASS: lo
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=1|1|lt=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmplo_p_p_zw_
			OPERATION: CMPLO
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LT;
			boolean unsigned = TRUE;
	CLASS: ls
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|U=1|1|lt=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpls_p_p_zw_
			OPERATION: CMPLS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LE;
			boolean unsigned = TRUE;
	CLASS: ne
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpne_p_p_zw_
			OPERATION: CMPNE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_NE;
			boolean unsigned = FALSE;

IFORM: cmpeq_p_p_zz
	TYPE: instruction
	XML: cmpeq_p_p_zz.xml
	ALIAS: CMPLE_cmpeq_p_p_zz
		Never
	ALIAS: CMPLO_cmpeq_p_p_zz
		Never
	ALIAS: CMPLS_cmpeq_p_p_zz
		Never
	ALIAS: CMPLT_cmpeq_p_p_zz
		Never
	CLASS: eq
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=1|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpeq_p_p_zz_
			OPERATION: CMPEQ
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_EQ;
			boolean unsigned = FALSE;
	CLASS: gt
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpgt_p_p_zz_
			OPERATION: CMPGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			boolean unsigned = FALSE;
	CLASS: ge
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmpge_p_p_zz_
			OPERATION: CMPGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			boolean unsigned = FALSE;
	CLASS: hi
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=0|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmphi_p_p_zz_
			OPERATION: CMPHI
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
			boolean unsigned = TRUE;
	CLASS: hs
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=0|0|o2=0|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: cmphs_p_p_zz_
			OPERATION: CMPHS
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
			boolean unsigned = TRUE;
	CLASS: ne
		FIELDS32: 00100100|size=xx|0|Zm=xxxxx|op=1|0|o2=1|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: cmpne_p_p_zz_
			OPERATION: CMPNE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_NE;
			boolean unsigned = FALSE;

IFORM: cnot_z_p_z
	TYPE: instruction
	XML: cnot_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=01|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: cnot_z_p_z_
			OPERATION: CNOT
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: cnt_z_p_z
	TYPE: instruction
	XML: cnt_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=01|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: cnt_z_p_z_
			OPERATION: CNT
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: cntb_r_s
	TYPE: instruction
	XML: cntb_r_s.xml
	CLASS: esize_byte
		FIELDS32: 00000100|size=00|10|imm4=xxxx|11100|op=0|pattern=xxxxx|Rd=xxxxx
		ENCODING: cntb_r_s_
			OPERATION: CNTB
			SYNTAX: <Xd>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer d = UInt(Rd);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_doubleword
		FIELDS32: 00000100|size=11|10|imm4=xxxx|11100|op=0|pattern=xxxxx|Rd=xxxxx
		ENCODING: cntd_r_s_
			OPERATION: CNTD
			SYNTAX: <Xd>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer d = UInt(Rd);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=01|10|imm4=xxxx|11100|op=0|pattern=xxxxx|Rd=xxxxx
		ENCODING: cnth_r_s_
			OPERATION: CNTH
			SYNTAX: <Xd>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer d = UInt(Rd);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_word
		FIELDS32: 00000100|size=10|10|imm4=xxxx|11100|op=0|pattern=xxxxx|Rd=xxxxx
		ENCODING: cntw_r_s_
			OPERATION: CNTW
			SYNTAX: <Xd>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer d = UInt(Rd);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;

IFORM: cntp_r_p_p
	TYPE: instruction
	XML: cntp_r_p_p.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|opc<2:1>=00|opc<0>=0|10|Pg=xxxx|o2=0|Pn=xxxx|Rd=xxxxx
		ENCODING: cntp_r_p_p_
			OPERATION: CNTP
			SYNTAX: <Xd>,<Pg>,<Pn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer d = UInt(Rd);

IFORM: compact_z_p_z
	TYPE: instruction
	XML: compact_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|100001100|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: compact_z_p_z_
			OPERATION: COMPACT
			SYNTAX: <Zd>.<T>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: cpy_z_o_i
	TYPE: instruction
	XML: cpy_z_o_i.xml
	ALIAS: MOV_cpy_z_o_i
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|0|M=0|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: cpy_z_o_i_
			OPERATION: CPY
			SYNTAX: <Zd>.<T>,<Pg>/Z, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer d = UInt(Zd);
			boolean merging = FALSE;
			integer imm = SInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: cpy_z_p_i
	TYPE: instruction
	XML: cpy_z_p_i.xml
	ALIAS: MOV_cpy_z_p_i
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|0|M=1|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: cpy_z_p_i_
			OPERATION: CPY
			SYNTAX: <Zd>.<T>,<Pg>/M, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer d = UInt(Zd);
			boolean merging = TRUE;
			integer imm = SInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: cpy_z_p_r
	TYPE: instruction
	XML: cpy_z_p_r.xml
	ALIAS: MOV_cpy_z_p_r
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|101000101|Pg=xxx|Rn=xxxxx|Zd=xxxxx
		ENCODING: cpy_z_p_r_
			OPERATION: CPY
			SYNTAX: <Zd>.<T>,<Pg>/M,<R><n|SP>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer d = UInt(Zd);

IFORM: cpy_z_p_v
	TYPE: instruction
	XML: cpy_z_p_v.xml
	ALIAS: MOV_cpy_z_p_v
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|100000100|Pg=xxx|Vn=xxxxx|Zd=xxxxx
		ENCODING: cpy_z_p_v_
			OPERATION: CPY
			SYNTAX: <Zd>.<T>,<Pg>/M,<V><n>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Vn);
			integer d = UInt(Zd);

IFORM: ctermeq_rr
	TYPE: instruction
	XML: ctermeq_rr.xml
	CLASS: eq
		FIELDS32: 00|100101|op=1|sz=x|1|Rm=xxxxx|001000|Rn=xxxxx|ne=0|0|0|00
		ENCODING: ctermeq_rr_
			OPERATION: CTERMEQ
			SYNTAX: <R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			SVECmp op = Cmp_EQ;
	CLASS: ne
		FIELDS32: 00|100101|op=1|sz=x|1|Rm=xxxxx|001000|Rn=xxxxx|ne=1|0|0|00
		ENCODING: ctermne_rr_
			OPERATION: CTERMNE
			SYNTAX: <R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32 << UInt(sz);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			SVECmp op = Cmp_NE;

IFORM: decb_r_rs
	TYPE: instruction
	XML: decb_r_rs.xml
	CLASS: esize_byte
		FIELDS32: 00000100|size=00|11|imm4=xxxx|11100|D=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: decb_r_rs_
			OPERATION: DECB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_doubleword
		FIELDS32: 00000100|size=11|11|imm4=xxxx|11100|D=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: decd_r_rs_
			OPERATION: DECD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=01|11|imm4=xxxx|11100|D=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: dech_r_rs_
			OPERATION: DECH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_word
		FIELDS32: 00000100|size=10|11|imm4=xxxx|11100|D=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: decw_r_rs_
			OPERATION: DECW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;

IFORM: decd_z_zs
	TYPE: instruction
	XML: decd_z_zs.xml
	CLASS: esize_doubleword
		FIELDS32: 00000100|size=11|11|imm4=xxxx|11000|D=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: decd_z_zs_
			OPERATION: DECD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=01|11|imm4=xxxx|11000|D=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: dech_z_zs_
			OPERATION: DECH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_word
		FIELDS32: 00000100|size=10|11|imm4=xxxx|11000|D=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: decw_z_zs_
			OPERATION: DECW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;

IFORM: decp_r_p_r
	TYPE: instruction
	XML: decp_r_p_r.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1011|op=0|D=1|10001|opc2=00|Pm=xxxx|Rdn=xxxxx
		ENCODING: decp_r_p_r_
			OPERATION: DECP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);

IFORM: decp_z_p_z
	TYPE: instruction
	XML: decp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1011|op=0|D=1|10000|opc2=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: decp_z_p_z_
			OPERATION: DECP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);

IFORM: dup_z_i
	TYPE: instruction
	XML: dup_z_i.xml
	ALIAS: MOV_dup_z_i
		Unconditionally
	CLASS: sve
		FIELDS32: 00100101|size=xx|111|opc=00|011|sh=x|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: dup_z_i_
			OPERATION: DUP
			SYNTAX: <Zd>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer d = UInt(Zd);
			integer imm = SInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: dup_z_r
	TYPE: instruction
	XML: dup_z_r.xml
	ALIAS: MOV_dup_z_r
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|100000001110|Rn=xxxxx|Zd=xxxxx
		ENCODING: dup_z_r_
			OPERATION: DUP
			SYNTAX: <Zd>.<T>,<R><n|SP>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Rn);
			integer d = UInt(Zd);

IFORM: dup_z_zi
	TYPE: instruction
	XML: dup_z_zi.xml
	ALIAS: MOV_dup_z_zi
		BitCount(imm2:tsz) == 1
		BitCount(imm2:tsz) > 1
	CLASS: sve
		FIELDS32: 00000101|imm2=xx|1|tsz=xxxxx|001000|Zn=xxxxx|Zd=xxxxx
		ENCODING: dup_z_zi_
			OPERATION: DUP
			SYNTAX: <Zd>.<T>,<Zn>.<T>[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(7) imm = imm2:tsz;
			case tsz of
			    when '00000' UNDEFINED;
			    when '10000' esize = 128; index = UInt(imm<6:5>);
			    when 'x1000' esize = 64;  index = UInt(imm<6:4>);
			    when 'xx100' esize = 32;  index = UInt(imm<6:3>);
			    when 'xxx10' esize = 16;  index = UInt(imm<6:2>);
			    when 'xxxx1' esize = 8;   index = UInt(imm<6:1>);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: dupm_z_i
	TYPE: instruction
	XML: dupm_z_i.xml
	ALIAS: MOV_dupm_z_i
		SVEMoveMaskPreferred(imm13)
	CLASS: sve
		FIELDS32: 00000101110000|imm13=xxxxxxxxxxxxx|Zd=xxxxx
		ENCODING: dupm_z_i_
			OPERATION: DUPM
			SYNTAX: <Zd>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer d = UInt(Zd);
			bits(esize) imm;
			(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

IFORM: eor_p_p_pp
	TYPE: instruction
	XML: eor_p_p_pp.xml
	ALIAS: NOTS_eor_p_p_pp
		Pm == Pg
	ALIAS: NOT_eor_p_p_pp
		Pm == Pg
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: eor_p_p_pp_z
			OPERATION: EOR
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: eors_p_p_pp_z
			OPERATION: EORS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: eor_z_p_zz
	TYPE: instruction
	XML: eor_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: eor_z_p_zz_
			OPERATION: EOR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: eor_z_zi
	TYPE: instruction
	XML: eor_z_zi.xml
	ALIAS: EON_eor_z_zi
		Never
	CLASS: sve
		FIELDS32: 00000101|opc=01|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: eor_z_zi_
			OPERATION: EOR
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer dn = UInt(Zdn);
			bits(64) imm;
			(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

IFORM: eor_z_zz
	TYPE: instruction
	XML: eor_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|opc=10|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: eor_z_zz_
			OPERATION: EOR
			SYNTAX: <Zd>.D,<Zn>.D,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: eorv_r_p_z
	TYPE: instruction
	XML: eorv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: eorv_r_p_z_
			OPERATION: EORV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: ext_z_zi
	TYPE: instruction
	XML: ext_z_zi.xml
	CLASS: sve
		FIELDS32: 00000101001|imm8h=xxxxx|000|imm8l=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: ext_z_zi_des
			OPERATION: EXT
			SYNTAX: <Zdn>.B,<Zdn>.B,<Zm>.B, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer position = UInt(imm8h:imm8l);

IFORM: fabd_z_p_zz
	TYPE: instruction
	XML: fabd_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=100|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fabd_z_p_zz_
			OPERATION: FABD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fabs_z_p_z
	TYPE: instruction
	XML: fabs_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=10|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fabs_z_p_z_
			OPERATION: FABS
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: facge_p_p_zz
	TYPE: instruction
	XML: facge_p_p_zz.xml
	ALIAS: FACLE_facge_p_p_zz
		Never
	ALIAS: FACLT_facge_p_p_zz
		Never
	CLASS: gt
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=1|1|o2=1|Pg=xxx|Zn=xxxxx|o3=1|Pd=xxxx
		ENCODING: facgt_p_p_zz_
			OPERATION: FACGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
	CLASS: ge
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=1|1|o2=0|Pg=xxx|Zn=xxxxx|o3=1|Pd=xxxx
		ENCODING: facge_p_p_zz_
			OPERATION: FACGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;

IFORM: fadd_z_p_zs
	TYPE: instruction
	XML: fadd_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=00|opc<0>=0|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fadd_z_p_zs_
			OPERATION: FADD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

IFORM: fadd_z_p_zz
	TYPE: instruction
	XML: fadd_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=000|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fadd_z_p_zz_
			OPERATION: FADD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fadd_z_zz
	TYPE: instruction
	XML: fadd_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=00|opc<0>=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: fadd_z_zz_
			OPERATION: FADD
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: fadda_v_p_z
	TYPE: instruction
	XML: fadda_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=00|opc<0>=0|001|Pg=xxx|Zm=xxxxx|Vdn=xxxxx
		ENCODING: fadda_v_p_z_
			OPERATION: FADDA
			SYNTAX: <V><dn>,<Pg>,<V><dn>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Vdn);
			integer m = UInt(Zm);

IFORM: faddv_v_p_z
	TYPE: instruction
	XML: faddv_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|000|opc<2:1>=00|opc<0>=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: faddv_v_p_z_
			OPERATION: FADDV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: fcadd_z_p_zz
	TYPE: instruction
	XML: fcadd_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100100|size=xx|00000|rot=x|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fcadd_z_p_zz_
			OPERATION: FCADD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean sub_i = (rot == '0');
			boolean sub_r = (rot == '1');

IFORM: fcmeq_p_p_z0
	TYPE: instruction
	XML: fcmeq_p_p_z0.xml
	CLASS: eq
		FIELDS32: 01100101|size=xx|0100|eq=1|lt=0|001|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: fcmeq_p_p_z0_
			OPERATION: FCMEQ
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_EQ;
	CLASS: gt
		FIELDS32: 01100101|size=xx|0100|eq=0|lt=0|001|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: fcmgt_p_p_z0_
			OPERATION: FCMGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
	CLASS: ge
		FIELDS32: 01100101|size=xx|0100|eq=0|lt=0|001|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: fcmge_p_p_z0_
			OPERATION: FCMGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
	CLASS: lt
		FIELDS32: 01100101|size=xx|0100|eq=0|lt=1|001|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: fcmlt_p_p_z0_
			OPERATION: FCMLT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LT;
	CLASS: le
		FIELDS32: 01100101|size=xx|0100|eq=0|lt=1|001|Pg=xxx|Zn=xxxxx|ne=1|Pd=xxxx
		ENCODING: fcmle_p_p_z0_
			OPERATION: FCMLE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_LE;
	CLASS: ne
		FIELDS32: 01100101|size=xx|0100|eq=1|lt=1|001|Pg=xxx|Zn=xxxxx|ne=0|Pd=xxxx
		ENCODING: fcmne_p_p_z0_
			OPERATION: FCMNE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>, #0.0
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Pd);
			SVECmp op = Cmp_NE;

IFORM: fcmeq_p_p_zz
	TYPE: instruction
	XML: fcmeq_p_p_zz.xml
	ALIAS: FCMLE_fcmeq_p_p_zz
		Never
	ALIAS: FCMLT_fcmeq_p_p_zz
		Never
	CLASS: eq
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=1|Pg=xxx|Zn=xxxxx|cmpl=0|Pd=xxxx
		ENCODING: fcmeq_p_p_zz_
			OPERATION: FCMEQ
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_EQ;
	CLASS: gt
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=0|Pg=xxx|Zn=xxxxx|cmpl=1|Pd=xxxx
		ENCODING: fcmgt_p_p_zz_
			OPERATION: FCMGT
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GT;
	CLASS: ge
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=0|Pg=xxx|Zn=xxxxx|cmpl=0|Pd=xxxx
		ENCODING: fcmge_p_p_zz_
			OPERATION: FCMGE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_GE;
	CLASS: ne
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=0|1|cmph=1|Pg=xxx|Zn=xxxxx|cmpl=1|Pd=xxxx
		ENCODING: fcmne_p_p_zz_
			OPERATION: FCMNE
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_NE;
	CLASS: uo
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|op=1|1|o2=0|Pg=xxx|Zn=xxxxx|o3=0|Pd=xxxx
		ENCODING: fcmuo_p_p_zz_
			OPERATION: FCMUO
			SYNTAX: <Pd>.<T>,<Pg>/Z,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Pd);
			SVECmp op = Cmp_UN;

IFORM: fcmla_z_p_zzz
	TYPE: instruction
	XML: fcmla_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100100|size=xx|0|Zm=xxxxx|0|rot=xx|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fcmla_z_p_zzz_
			OPERATION: FCMLA
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer sel_a = UInt(rot<0>);
			integer sel_b = UInt(NOT(rot<0>));
			boolean neg_i = (rot<1> == '1');
			boolean neg_r = (rot<0> != rot<1>);

IFORM: fcmla_z_zzzi
	TYPE: instruction
	XML: fcmla_z_zzzi.xml
	CLASS: half
		FIELDS32: 01100100|size=10|1|i2=xx|Zm=xxx|0001|rot=xx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fcmla_z_zzzi_h
			OPERATION: FCMLA
			SYNTAX: <Zda>.H,<Zn>.H,<Zm>.H[<imm>],<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer sel_a = UInt(rot<0>);
			integer sel_b = UInt(NOT(rot<0>));
			boolean neg_i = (rot<1> == '1');
			boolean neg_r = (rot<0> != rot<1>);
	CLASS: single
		FIELDS32: 01100100|size=11|1|i1=x|Zm=xxxx|0001|rot=xx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fcmla_z_zzzi_s
			OPERATION: FCMLA
			SYNTAX: <Zda>.S,<Zn>.S,<Zm>.S[<imm>],<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			integer sel_a = UInt(rot<0>);
			integer sel_b = UInt(NOT(rot<0>));
			boolean neg_i = (rot<1> == '1');
			boolean neg_r = (rot<0> != rot<1>);

IFORM: fcpy_z_p_i
	TYPE: instruction
	XML: fcpy_z_p_i.xml
	ALIAS: FMOV_fcpy_z_p_i
		Unconditionally
	CLASS: sve
		FIELDS32: 00000101|size=xx|01|Pg=xxxx|110|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: fcpy_z_p_i_
			OPERATION: FCPY
			SYNTAX: <Zd>.<T>,<Pg>/M, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer d = UInt(Zd);
			bits(esize) imm = VFPExpandImm(imm8);

IFORM: fcvt_z_p_z
	TYPE: instruction
	XML: fcvt_z_p_z.xml
	CLASS: half_to_single
		FIELDS32: 01100101|opc=10|0010|opc2=01|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_h2s
			OPERATION: FCVT
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 32;
	CLASS: half_to_double
		FIELDS32: 01100101|opc=11|0010|opc2=01|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_h2d
			OPERATION: FCVT
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 64;
	CLASS: single_to_half
		FIELDS32: 01100101|opc=10|0010|opc2=00|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_s2h
			OPERATION: FCVT
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 16;
	CLASS: single_to_double
		FIELDS32: 01100101|opc=11|0010|opc2=11|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_s2d
			OPERATION: FCVT
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 64;
	CLASS: double_to_half
		FIELDS32: 01100101|opc=11|0010|opc2=00|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_d2h
			OPERATION: FCVT
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 16;
	CLASS: double_to_single
		FIELDS32: 01100101|opc=11|0010|opc2=10|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvt_z_p_z_d2s
			OPERATION: FCVT
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 32;

IFORM: fcvtzs_z_p_z
	TYPE: instruction
	XML: fcvtzs_z_p_z.xml
	CLASS: half_to_16
		FIELDS32: 01100101|opc=01|011|opc2=01|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_fp162h
			OPERATION: FCVTZS
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 16;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: half_to_32
		FIELDS32: 01100101|opc=01|011|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_fp162w
			OPERATION: FCVTZS
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 32;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: half_to_64
		FIELDS32: 01100101|opc=01|011|opc2=11|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_fp162x
			OPERATION: FCVTZS
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 64;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: single_to_32
		FIELDS32: 01100101|opc=10|011|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_s2w
			OPERATION: FCVTZS
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 32;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: single_to_64
		FIELDS32: 01100101|opc=11|011|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_s2x
			OPERATION: FCVTZS
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 64;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: double_to_32
		FIELDS32: 01100101|opc=11|011|opc2=00|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_d2w
			OPERATION: FCVTZS
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 32;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: double_to_64
		FIELDS32: 01100101|opc=11|011|opc2=11|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzs_z_p_z_d2x
			OPERATION: FCVTZS
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 64;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRounding_ZERO;

IFORM: fcvtzu_z_p_z
	TYPE: instruction
	XML: fcvtzu_z_p_z.xml
	CLASS: half_to_16
		FIELDS32: 01100101|opc=01|011|opc2=01|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_fp162h
			OPERATION: FCVTZU
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 16;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: half_to_32
		FIELDS32: 01100101|opc=01|011|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_fp162w
			OPERATION: FCVTZU
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 32;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: half_to_64
		FIELDS32: 01100101|opc=01|011|opc2=11|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_fp162x
			OPERATION: FCVTZU
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 64;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: single_to_32
		FIELDS32: 01100101|opc=10|011|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_s2w
			OPERATION: FCVTZU
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 32;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: single_to_64
		FIELDS32: 01100101|opc=11|011|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_s2x
			OPERATION: FCVTZU
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 64;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: double_to_32
		FIELDS32: 01100101|opc=11|011|opc2=00|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_d2w
			OPERATION: FCVTZU
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 32;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: double_to_64
		FIELDS32: 01100101|opc=11|011|opc2=11|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fcvtzu_z_p_z_d2x
			OPERATION: FCVTZU
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 64;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRounding_ZERO;

IFORM: fdiv_z_p_zz
	TYPE: instruction
	XML: fdiv_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=110|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fdiv_z_p_zz_
			OPERATION: FDIV
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fdivr_z_p_zz
	TYPE: instruction
	XML: fdivr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=110|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fdivr_z_p_zz_
			OPERATION: FDIVR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fdup_z_i
	TYPE: instruction
	XML: fdup_z_i.xml
	ALIAS: FMOV_fdup_z_i
		Unconditionally
	CLASS: sve
		FIELDS32: 00100101|size=xx|111|opc=00|111|o2=0|imm8=xxxxxxxx|Zd=xxxxx
		ENCODING: fdup_z_i_
			OPERATION: FDUP
			SYNTAX: <Zd>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer d = UInt(Zd);
			bits(esize) imm = VFPExpandImm(imm8);

IFORM: fexpa_z_z
	TYPE: instruction
	XML: fexpa_z_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|opc<4:1>=0000|opc<0>=0|101110|Zn=xxxxx|Zd=xxxxx
		ENCODING: fexpa_z_z_
			OPERATION: FEXPA
			SYNTAX: <Zd>.<T>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: fmad_z_p_zzz
	TYPE: instruction
	XML: fmad_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Za=xxxxx|1|N=0|op=0|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmad_z_p_zzz_
			OPERATION: FMAD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean op1_neg = FALSE;
			boolean op3_neg = FALSE;

IFORM: fmax_z_p_zs
	TYPE: instruction
	XML: fmax_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=11|opc<0>=0|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fmax_z_p_zs_
			OPERATION: FMAX
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

IFORM: fmax_z_p_zz
	TYPE: instruction
	XML: fmax_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=011|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmax_z_p_zz_
			OPERATION: FMAX
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fmaxnm_z_p_zs
	TYPE: instruction
	XML: fmaxnm_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=10|opc<0>=0|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fmaxnm_z_p_zs_
			OPERATION: FMAXNM
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

IFORM: fmaxnm_z_p_zz
	TYPE: instruction
	XML: fmaxnm_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=010|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmaxnm_z_p_zz_
			OPERATION: FMAXNM
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fmaxnmv_v_p_z
	TYPE: instruction
	XML: fmaxnmv_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|000|opc<2:1>=10|opc<0>=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: fmaxnmv_v_p_z_
			OPERATION: FMAXNMV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: fmaxv_v_p_z
	TYPE: instruction
	XML: fmaxv_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|000|opc<2:1>=11|opc<0>=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: fmaxv_v_p_z_
			OPERATION: FMAXV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: fmin_z_p_zs
	TYPE: instruction
	XML: fmin_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=11|opc<0>=1|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fmin_z_p_zs_
			OPERATION: FMIN
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

IFORM: fmin_z_p_zz
	TYPE: instruction
	XML: fmin_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=011|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmin_z_p_zz_
			OPERATION: FMIN
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fminnm_z_p_zs
	TYPE: instruction
	XML: fminnm_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=10|opc<0>=1|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fminnm_z_p_zs_
			OPERATION: FMINNM
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

IFORM: fminnm_z_p_zz
	TYPE: instruction
	XML: fminnm_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=010|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fminnm_z_p_zz_
			OPERATION: FMINNM
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fminnmv_v_p_z
	TYPE: instruction
	XML: fminnmv_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|000|opc<2:1>=10|opc<0>=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: fminnmv_v_p_z_
			OPERATION: FMINNMV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: fminv_v_p_z
	TYPE: instruction
	XML: fminv_v_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|000|opc<2:1>=11|opc<0>=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: fminv_v_p_z_
			OPERATION: FMINV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: fmla_z_p_zzz
	TYPE: instruction
	XML: fmla_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Zm=xxxxx|0|N=0|op=0|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmla_z_p_zzz_
			OPERATION: FMLA
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = FALSE;
			boolean op3_neg = FALSE;

IFORM: fmla_z_zzzi
	TYPE: instruction
	XML: fmla_z_zzzi.xml
	CLASS: half
		FIELDS32: 01100100|0|i3h=x|1|i3l=xx|Zm=xxx|00000|op=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmla_z_zzzi_h
			OPERATION: FMLA
			SYNTAX: <Zda>.H,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer index = UInt(i3h:i3l);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = FALSE;
			boolean op3_neg = FALSE;
	CLASS: single
		FIELDS32: 01100100|size=10|1|i2=xx|Zm=xxx|00000|op=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmla_z_zzzi_s
			OPERATION: FMLA
			SYNTAX: <Zda>.S,<Zn>.S,<Zm>.S[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = FALSE;
			boolean op3_neg = FALSE;
	CLASS: double
		FIELDS32: 01100100|size=11|1|i1=x|Zm=xxxx|00000|op=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmla_z_zzzi_d
			OPERATION: FMLA
			SYNTAX: <Zda>.D,<Zn>.D,<Zm>.D[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = FALSE;
			boolean op3_neg = FALSE;

IFORM: fmls_z_p_zzz
	TYPE: instruction
	XML: fmls_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Zm=xxxxx|0|N=0|op=1|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmls_z_p_zzz_
			OPERATION: FMLS
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = TRUE;
			boolean op3_neg = FALSE;

IFORM: fmls_z_zzzi
	TYPE: instruction
	XML: fmls_z_zzzi.xml
	CLASS: half
		FIELDS32: 01100100|0|i3h=x|1|i3l=xx|Zm=xxx|00000|op=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmls_z_zzzi_h
			OPERATION: FMLS
			SYNTAX: <Zda>.H,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer index = UInt(i3h:i3l);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = TRUE;
			boolean op3_neg = FALSE;
	CLASS: single
		FIELDS32: 01100100|size=10|1|i2=xx|Zm=xxx|00000|op=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmls_z_zzzi_s
			OPERATION: FMLS
			SYNTAX: <Zda>.S,<Zn>.S,<Zm>.S[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = TRUE;
			boolean op3_neg = FALSE;
	CLASS: double
		FIELDS32: 01100100|size=11|1|i1=x|Zm=xxxx|00000|op=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmls_z_zzzi_d
			OPERATION: FMLS
			SYNTAX: <Zda>.D,<Zn>.D,<Zm>.D[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = TRUE;
			boolean op3_neg = FALSE;

IFORM: fmmla_z_zzz
	TYPE: instruction
	XML: fmmla_z_zzz.xml
	CLASS: 32_elem
		FIELDS32: 01100100|opc=10|1|Zm=xxxxx|111001|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmmla_z_zzz_s
			OPERATION: FMMLA
			SYNTAX: <Zda>.S,<Zn>.S,<Zm>.S
		DECODE_PCODE:
			if !HaveSVEFP32MatMulExt() then UNDEFINED;
			integer esize = 32;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
	CLASS: 64_elem
		FIELDS32: 01100100|opc=11|1|Zm=xxxxx|111001|Zn=xxxxx|Zda=xxxxx
		ENCODING: fmmla_z_zzz_d
			OPERATION: FMMLA
			SYNTAX: <Zda>.D,<Zn>.D,<Zm>.D
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 64;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: fmsb_z_p_zzz
	TYPE: instruction
	XML: fmsb_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Za=xxxxx|1|N=0|op=1|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmsb_z_p_zzz_
			OPERATION: FMSB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean op1_neg = TRUE;
			boolean op3_neg = FALSE;

IFORM: fmul_z_p_zs
	TYPE: instruction
	XML: fmul_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=01|opc<0>=0|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fmul_z_p_zs_
			OPERATION: FMUL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPTwo('0');

IFORM: fmul_z_p_zz
	TYPE: instruction
	XML: fmul_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=001|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmul_z_p_zz_
			OPERATION: FMUL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fmul_z_zz
	TYPE: instruction
	XML: fmul_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=01|opc<0>=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: fmul_z_zz_
			OPERATION: FMUL
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: fmul_z_zzi
	TYPE: instruction
	XML: fmul_z_zzi.xml
	CLASS: half
		FIELDS32: 01100100|0|i3h=x|1|i3l=xx|Zm=xxx|001000|Zn=xxxxx|Zd=xxxxx
		ENCODING: fmul_z_zzi_h
			OPERATION: FMUL
			SYNTAX: <Zd>.H,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer index = UInt(i3h:i3l);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
	CLASS: single
		FIELDS32: 01100100|size=10|1|i2=xx|Zm=xxx|001000|Zn=xxxxx|Zd=xxxxx
		ENCODING: fmul_z_zzi_s
			OPERATION: FMUL
			SYNTAX: <Zd>.S,<Zn>.S,<Zm>.S[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
	CLASS: double
		FIELDS32: 01100100|size=11|1|i1=x|Zm=xxxx|001000|Zn=xxxxx|Zd=xxxxx
		ENCODING: fmul_z_zzi_d
			OPERATION: FMUL
			SYNTAX: <Zd>.D,<Zn>.D,<Zm>.D[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: fmulx_z_p_zz
	TYPE: instruction
	XML: fmulx_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=101|opc<0>=0|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fmulx_z_p_zz_
			OPERATION: FMULX
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fneg_z_p_z
	TYPE: instruction
	XML: fneg_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=10|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fneg_z_p_z_
			OPERATION: FNEG
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: fnmad_z_p_zzz
	TYPE: instruction
	XML: fnmad_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Za=xxxxx|1|N=1|op=0|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fnmad_z_p_zzz_
			OPERATION: FNMAD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean op1_neg = TRUE;
			boolean op3_neg = TRUE;

IFORM: fnmla_z_p_zzz
	TYPE: instruction
	XML: fnmla_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Zm=xxxxx|0|N=1|op=0|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fnmla_z_p_zzz_
			OPERATION: FNMLA
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = TRUE;
			boolean op3_neg = TRUE;

IFORM: fnmls_z_p_zzz
	TYPE: instruction
	XML: fnmls_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Zm=xxxxx|0|N=1|op=1|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: fnmls_z_p_zzz_
			OPERATION: FNMLS
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_neg = FALSE;
			boolean op3_neg = TRUE;

IFORM: fnmsb_z_p_zzz
	TYPE: instruction
	XML: fnmsb_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|1|Za=xxxxx|1|N=1|op=1|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fnmsb_z_p_zzz_
			OPERATION: FNMSB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean op1_neg = FALSE;
			boolean op3_neg = TRUE;

IFORM: frecpe_z_z
	TYPE: instruction
	XML: frecpe_z_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|001|opc<2:1>=11|opc<0>=0|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: frecpe_z_z_
			OPERATION: FRECPE
			SYNTAX: <Zd>.<T>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: frecps_z_zz
	TYPE: instruction
	XML: frecps_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=11|opc<0>=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: frecps_z_zz_
			OPERATION: FRECPS
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: frecpx_z_p_z
	TYPE: instruction
	XML: frecpx_z_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0011|opc=00|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frecpx_z_p_z_
			OPERATION: FRECPX
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: frinta_z_p_z
	TYPE: instruction
	XML: frinta_z_p_z.xml
	CLASS: frint_i
		FIELDS32: 01100101|size=xx|000|opc<2:1>=11|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frinti_z_p_z_
			OPERATION: FRINTI
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: frint_x
		FIELDS32: 01100101|size=xx|000|opc<2:1>=11|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frintx_z_p_z_
			OPERATION: FRINTX
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: frint_a
		FIELDS32: 01100101|size=xx|000|opc<2:1>=10|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frinta_z_p_z_
			OPERATION: FRINTA
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRounding_TIEAWAY;
	CLASS: frint_n
		FIELDS32: 01100101|size=xx|000|opc<2:1>=00|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frintn_z_p_z_
			OPERATION: FRINTN
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRounding_TIEEVEN;
	CLASS: frint_z
		FIELDS32: 01100101|size=xx|000|opc<2:1>=01|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frintz_z_p_z_
			OPERATION: FRINTZ
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRounding_ZERO;
	CLASS: frint_m
		FIELDS32: 01100101|size=xx|000|opc<2:1>=01|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frintm_z_p_z_
			OPERATION: FRINTM
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRounding_NEGINF;
	CLASS: frint_p
		FIELDS32: 01100101|size=xx|000|opc<2:1>=00|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: frintp_z_p_z_
			OPERATION: FRINTP
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean exact = FALSE;
			FPRounding rounding = FPRounding_POSINF;

IFORM: frsqrte_z_z
	TYPE: instruction
	XML: frsqrte_z_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|001|opc<2:1>=11|opc<0>=1|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: frsqrte_z_z_
			OPERATION: FRSQRTE
			SYNTAX: <Zd>.<T>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: frsqrts_z_zz
	TYPE: instruction
	XML: frsqrts_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=11|opc<0>=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: frsqrts_z_zz_
			OPERATION: FRSQRTS
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: fscale_z_p_zz
	TYPE: instruction
	XML: fscale_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=100|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fscale_z_p_zz_
			OPERATION: FSCALE
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fsqrt_z_p_z
	TYPE: instruction
	XML: fsqrt_z_p_z.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0011|opc=01|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: fsqrt_z_p_z_
			OPERATION: FSQRT
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: fsub_z_p_zs
	TYPE: instruction
	XML: fsub_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=00|opc<0>=1|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fsub_z_p_zs_
			OPERATION: FSUB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

IFORM: fsub_z_p_zz
	TYPE: instruction
	XML: fsub_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=000|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fsub_z_p_zz_
			OPERATION: FSUB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: fsub_z_zz
	TYPE: instruction
	XML: fsub_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=00|opc<0>=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: fsub_z_zz_
			OPERATION: FSUB
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: fsubr_z_p_zs
	TYPE: instruction
	XML: fsubr_z_p_zs.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|011|opc<2:1>=01|opc<0>=1|100|Pg=xxx|0000|i1=x|Zdn=xxxxx
		ENCODING: fsubr_z_p_zs_
			OPERATION: FSUBR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

IFORM: fsubr_z_p_zz
	TYPE: instruction
	XML: fsubr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|00|opc<3:1>=001|opc<0>=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: fsubr_z_p_zz_
			OPERATION: FSUBR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: ftmad_z_zzi
	TYPE: instruction
	XML: ftmad_z_zzi.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|010|imm3=xxx|100000|Zm=xxxxx|Zdn=xxxxx
		ENCODING: ftmad_z_zzi_
			OPERATION: FTMAD
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>,<Zm>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer imm = UInt(imm3);

IFORM: ftsmul_z_zz
	TYPE: instruction
	XML: ftsmul_z_zz.xml
	CLASS: sve
		FIELDS32: 01100101|size=xx|0|Zm=xxxxx|000|opc<2:1>=01|opc<0>=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: ftsmul_z_zz_
			OPERATION: FTSMUL
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: ftssel_z_zz
	TYPE: instruction
	XML: ftssel_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|10110|op=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: ftssel_z_zz_
			OPERATION: FTSSEL
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: incb_r_rs
	TYPE: instruction
	XML: incb_r_rs.xml
	CLASS: esize_byte
		FIELDS32: 00000100|size=00|11|imm4=xxxx|11100|D=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: incb_r_rs_
			OPERATION: INCB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_doubleword
		FIELDS32: 00000100|size=11|11|imm4=xxxx|11100|D=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: incd_r_rs_
			OPERATION: INCD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=01|11|imm4=xxxx|11100|D=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: inch_r_rs_
			OPERATION: INCH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_word
		FIELDS32: 00000100|size=10|11|imm4=xxxx|11100|D=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: incw_r_rs_
			OPERATION: INCW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;

IFORM: incd_z_zs
	TYPE: instruction
	XML: incd_z_zs.xml
	CLASS: esize_doubleword
		FIELDS32: 00000100|size=11|11|imm4=xxxx|11000|D=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: incd_z_zs_
			OPERATION: INCD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=01|11|imm4=xxxx|11000|D=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: inch_z_zs_
			OPERATION: INCH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
	CLASS: esize_word
		FIELDS32: 00000100|size=10|11|imm4=xxxx|11000|D=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: incw_z_zs_
			OPERATION: INCW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;

IFORM: incp_r_p_r
	TYPE: instruction
	XML: incp_r_p_r.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1011|op=0|D=0|10001|opc2=00|Pm=xxxx|Rdn=xxxxx
		ENCODING: incp_r_p_r_
			OPERATION: INCP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);

IFORM: incp_z_p_z
	TYPE: instruction
	XML: incp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1011|op=0|D=0|10000|opc2=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: incp_z_p_z_
			OPERATION: INCP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);

IFORM: index_z_ii
	TYPE: instruction
	XML: index_z_ii.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|imm5b=xxxxx|010000|imm5=xxxxx|Zd=xxxxx
		ENCODING: index_z_ii_
			OPERATION: INDEX
			SYNTAX: <Zd>.<T>, #<imm1>, #<imm2>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer d = UInt(Zd);
			integer imm1 = SInt(imm5);
			integer imm2 = SInt(imm5b);

IFORM: index_z_ir
	TYPE: instruction
	XML: index_z_ir.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Rm=xxxxx|010010|imm5=xxxxx|Zd=xxxxx
		ENCODING: index_z_ir_
			OPERATION: INDEX
			SYNTAX: <Zd>.<T>, #<imm>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Rm);
			integer d = UInt(Zd);
			integer imm = SInt(imm5);

IFORM: index_z_ri
	TYPE: instruction
	XML: index_z_ri.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|imm5=xxxxx|010001|Rn=xxxxx|Zd=xxxxx
		ENCODING: index_z_ri_
			OPERATION: INDEX
			SYNTAX: <Zd>.<T>,<R><n>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Rn);
			integer d = UInt(Zd);
			integer imm = SInt(imm5);

IFORM: index_z_rr
	TYPE: instruction
	XML: index_z_rr.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Rm=xxxxx|010011|Rn=xxxxx|Zd=xxxxx
		ENCODING: index_z_rr_
			OPERATION: INDEX
			SYNTAX: <Zd>.<T>,<R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Zd);

IFORM: insr_z_r
	TYPE: instruction
	XML: insr_z_r.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|100100001110|Rm=xxxxx|Zdn=xxxxx
		ENCODING: insr_z_r_
			OPERATION: INSR
			SYNTAX: <Zdn>.<T>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer m = UInt(Rm);

IFORM: insr_z_v
	TYPE: instruction
	XML: insr_z_v.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|110100001110|Vm=xxxxx|Zdn=xxxxx
		ENCODING: insr_z_v_
			OPERATION: INSR
			SYNTAX: <Zdn>.<T>,<V><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer m = UInt(Vm);

IFORM: lasta_r_p_z
	TYPE: instruction
	XML: lasta_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10000|B=0|101|Pg=xxx|Zn=xxxxx|Rd=xxxxx
		ENCODING: lasta_r_p_z_
			OPERATION: LASTA
			SYNTAX: <R><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = if esize < 64 then 32 else 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Rd);
			boolean isBefore = FALSE;

IFORM: lasta_v_p_z
	TYPE: instruction
	XML: lasta_v_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10001|B=0|100|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: lasta_v_p_z_
			OPERATION: LASTA
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean isBefore = FALSE;

IFORM: lastb_r_p_z
	TYPE: instruction
	XML: lastb_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10000|B=1|101|Pg=xxx|Zn=xxxxx|Rd=xxxxx
		ENCODING: lastb_r_p_z_
			OPERATION: LASTB
			SYNTAX: <R><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = if esize < 64 then 32 else 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Rd);
			boolean isBefore = TRUE;

IFORM: lastb_v_p_z
	TYPE: instruction
	XML: lastb_v_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|10001|B=1|100|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: lastb_v_p_z_
			OPERATION: LASTB
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean isBefore = TRUE;

IFORM: ld1b_z_p_ai
	TYPE: instruction
	XML: ld1b_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=00|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_ai_s
			OPERATION: LD1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=00|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_ai_d
			OPERATION: LD1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ld1b_z_p_bi
	TYPE: instruction
	XML: ld1b_z_p_bi.xml
	CLASS: 8_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bi_u8
			OPERATION: LD1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bi_u16
			OPERATION: LD1B
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bi_u32
			OPERATION: LD1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bi_u64
			OPERATION: LD1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ld1b_z_p_br
	TYPE: instruction
	XML: ld1b_z_p_br.xml
	CLASS: 8_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_br_u8
			OPERATION: LD1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_br_u16
			OPERATION: LD1B
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_br_u32
			OPERATION: LD1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_br_u64
			OPERATION: LD1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;

IFORM: ld1b_z_p_bz
	TYPE: instruction
	XML: ld1b_z_p_bz.xml
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=00|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bz_d_x32_unscaled
			OPERATION: LD1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=00|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bz_s_x32_unscaled
			OPERATION: LD1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=00|10|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1b_z_p_bz_d_64_unscaled
			OPERATION: LD1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1d_z_p_ai
	TYPE: instruction
	XML: ld1d_z_p_ai.xml
	CLASS: sve
		FIELDS32: 1100010|msz=11|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_ai_d
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ld1d_z_p_bi
	TYPE: instruction
	XML: ld1d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_bi_u64
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ld1d_z_p_br
	TYPE: instruction
	XML: ld1d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_br_u64
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;

IFORM: ld1d_z_p_bz
	TYPE: instruction
	XML: ld1d_z_p_bz.xml
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=11|xs=x|1|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_bz_d_x32_scaled
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 3;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=11|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_bz_d_x32_unscaled
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=11|11|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_bz_d_64_scaled
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 3;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=11|10|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1d_z_p_bz_d_64_unscaled
			OPERATION: LD1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1h_z_p_ai
	TYPE: instruction
	XML: ld1h_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=01|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_ai_s
			OPERATION: LD1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=01|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_ai_d
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ld1h_z_p_bi
	TYPE: instruction
	XML: ld1h_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bi_u16
			OPERATION: LD1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bi_u32
			OPERATION: LD1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bi_u64
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ld1h_z_p_br
	TYPE: instruction
	XML: ld1h_z_p_br.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_br_u16
			OPERATION: LD1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 16;
			boolean unsigned = TRUE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_br_u32
			OPERATION: LD1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_br_u64
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;

IFORM: ld1h_z_p_bz
	TYPE: instruction
	XML: ld1h_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001001|xs=x|1|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_s_x32_scaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=01|xs=x|1|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_d_x32_scaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=01|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_d_x32_unscaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=01|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_s_x32_unscaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=01|11|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_d_64_scaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 1;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=01|10|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1h_z_p_bz_d_64_unscaled
			OPERATION: LD1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1rb_z_p_bi
	TYPE: instruction
	XML: ld1rb_z_p_bi.xml
	CLASS: 8_elem
		FIELDS32: 1000010|dtypeh=00|1|imm6=xxxxxx|1|dtypel=00|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rb_z_p_bi_u8
			OPERATION: LD1RB
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 16_elem
		FIELDS32: 1000010|dtypeh=00|1|imm6=xxxxxx|1|dtypel=01|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rb_z_p_bi_u16
			OPERATION: LD1RB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 32_elem
		FIELDS32: 1000010|dtypeh=00|1|imm6=xxxxxx|1|dtypel=10|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rb_z_p_bi_u32
			OPERATION: LD1RB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 64_elem
		FIELDS32: 1000010|dtypeh=00|1|imm6=xxxxxx|1|dtypel=11|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rb_z_p_bi_u64
			OPERATION: LD1RB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);

IFORM: ld1rd_z_p_bi
	TYPE: instruction
	XML: ld1rd_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010|dtypeh=11|1|imm6=xxxxxx|1|dtypel=11|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rd_z_p_bi_u64
			OPERATION: LD1RD
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);

IFORM: ld1rh_z_p_bi
	TYPE: instruction
	XML: ld1rh_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1000010|dtypeh=01|1|imm6=xxxxxx|1|dtypel=01|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rh_z_p_bi_u16
			OPERATION: LD1RH
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 32_elem
		FIELDS32: 1000010|dtypeh=01|1|imm6=xxxxxx|1|dtypel=10|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rh_z_p_bi_u32
			OPERATION: LD1RH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 64_elem
		FIELDS32: 1000010|dtypeh=01|1|imm6=xxxxxx|1|dtypel=11|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rh_z_p_bi_u64
			OPERATION: LD1RH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);

IFORM: ld1rob_z_p_bi
	TYPE: instruction
	XML: ld1rob_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|ssz=01|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rob_z_p_bi_u8
			OPERATION: LD1ROB
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);

IFORM: ld1rob_z_p_br
	TYPE: instruction
	XML: ld1rob_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|ssz=01|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rob_z_p_br_contiguous
			OPERATION: LD1ROB
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;

IFORM: ld1rod_z_p_bi
	TYPE: instruction
	XML: ld1rod_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|ssz=01|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rod_z_p_bi_u64
			OPERATION: LD1ROD
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);

IFORM: ld1rod_z_p_br
	TYPE: instruction
	XML: ld1rod_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|ssz=01|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rod_z_p_br_contiguous
			OPERATION: LD1ROD
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;

IFORM: ld1roh_z_p_bi
	TYPE: instruction
	XML: ld1roh_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|ssz=01|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1roh_z_p_bi_u16
			OPERATION: LD1ROH
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);

IFORM: ld1roh_z_p_br
	TYPE: instruction
	XML: ld1roh_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|ssz=01|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1roh_z_p_br_contiguous
			OPERATION: LD1ROH
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;

IFORM: ld1row_z_p_bi
	TYPE: instruction
	XML: ld1row_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|ssz=01|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1row_z_p_bi_u32
			OPERATION: LD1ROW
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);

IFORM: ld1row_z_p_br
	TYPE: instruction
	XML: ld1row_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|ssz=01|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1row_z_p_br_contiguous
			OPERATION: LD1ROW
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;

IFORM: ld1rqb_z_p_bi
	TYPE: instruction
	XML: ld1rqb_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|ssz=00|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqb_z_p_bi_u8
			OPERATION: LD1RQB
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);

IFORM: ld1rqb_z_p_br
	TYPE: instruction
	XML: ld1rqb_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|ssz=00|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqb_z_p_br_contiguous
			OPERATION: LD1RQB
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;

IFORM: ld1rqd_z_p_bi
	TYPE: instruction
	XML: ld1rqd_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|ssz=00|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqd_z_p_bi_u64
			OPERATION: LD1RQD
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);

IFORM: ld1rqd_z_p_br
	TYPE: instruction
	XML: ld1rqd_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|ssz=00|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqd_z_p_br_contiguous
			OPERATION: LD1RQD
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;

IFORM: ld1rqh_z_p_bi
	TYPE: instruction
	XML: ld1rqh_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|ssz=00|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqh_z_p_bi_u16
			OPERATION: LD1RQH
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);

IFORM: ld1rqh_z_p_br
	TYPE: instruction
	XML: ld1rqh_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|ssz=00|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqh_z_p_br_contiguous
			OPERATION: LD1RQH
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;

IFORM: ld1rqw_z_p_bi
	TYPE: instruction
	XML: ld1rqw_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|ssz=00|0|imm4=xxxx|001|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqw_z_p_bi_u32
			OPERATION: LD1RQW
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);

IFORM: ld1rqw_z_p_br
	TYPE: instruction
	XML: ld1rqw_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|ssz=00|Rm=xxxxx|000|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rqw_z_p_br_contiguous
			OPERATION: LD1RQW
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;

IFORM: ld1rsb_z_p_bi
	TYPE: instruction
	XML: ld1rsb_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1000010|dtypeh=11|1|imm6=xxxxxx|1|dtypel=10|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsb_z_p_bi_s16
			OPERATION: LD1RSB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);
	CLASS: 32_elem
		FIELDS32: 1000010|dtypeh=11|1|imm6=xxxxxx|1|dtypel=01|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsb_z_p_bi_s32
			OPERATION: LD1RSB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);
	CLASS: 64_elem
		FIELDS32: 1000010|dtypeh=11|1|imm6=xxxxxx|1|dtypel=00|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsb_z_p_bi_s64
			OPERATION: LD1RSB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);

IFORM: ld1rsh_z_p_bi
	TYPE: instruction
	XML: ld1rsh_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1000010|dtypeh=10|1|imm6=xxxxxx|1|dtypel=01|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsh_z_p_bi_s32
			OPERATION: LD1RSH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);
	CLASS: 64_elem
		FIELDS32: 1000010|dtypeh=10|1|imm6=xxxxxx|1|dtypel=00|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsh_z_p_bi_s64
			OPERATION: LD1RSH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);

IFORM: ld1rsw_z_p_bi
	TYPE: instruction
	XML: ld1rsw_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010|dtypeh=01|1|imm6=xxxxxx|1|dtypel=00|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rsw_z_p_bi_s64
			OPERATION: LD1RSW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;
			integer offset = UInt(imm6);

IFORM: ld1rw_z_p_bi
	TYPE: instruction
	XML: ld1rw_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1000010|dtypeh=10|1|imm6=xxxxxx|1|dtypel=10|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rw_z_p_bi_u32
			OPERATION: LD1RW
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);
	CLASS: 64_elem
		FIELDS32: 1000010|dtypeh=10|1|imm6=xxxxxx|1|dtypel=11|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1rw_z_p_bi_u64
			OPERATION: LD1RW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm6);

IFORM: ld1sb_z_p_ai
	TYPE: instruction
	XML: ld1sb_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=00|01|imm5=xxxxx|1|U=0|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_ai_s
			OPERATION: LD1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=00|01|imm5=xxxxx|1|U=0|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_ai_d
			OPERATION: LD1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ld1sb_z_p_bi
	TYPE: instruction
	XML: ld1sb_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bi_s16
			OPERATION: LD1SB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bi_s32
			OPERATION: LD1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bi_s64
			OPERATION: LD1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ld1sb_z_p_br
	TYPE: instruction
	XML: ld1sb_z_p_br.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_br_s16
			OPERATION: LD1SB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = FALSE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_br_s32
			OPERATION: LD1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_br_s64
			OPERATION: LD1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;

IFORM: ld1sb_z_p_bz
	TYPE: instruction
	XML: ld1sb_z_p_bz.xml
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=00|xs=x|0|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bz_d_x32_unscaled
			OPERATION: LD1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=00|xs=x|0|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bz_s_x32_unscaled
			OPERATION: LD1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=00|10|Zm=xxxxx|1|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sb_z_p_bz_d_64_unscaled
			OPERATION: LD1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1sh_z_p_ai
	TYPE: instruction
	XML: ld1sh_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=01|01|imm5=xxxxx|1|U=0|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_ai_s
			OPERATION: LD1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=01|01|imm5=xxxxx|1|U=0|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_ai_d
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ld1sh_z_p_bi
	TYPE: instruction
	XML: ld1sh_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bi_s32
			OPERATION: LD1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bi_s64
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ld1sh_z_p_br
	TYPE: instruction
	XML: ld1sh_z_p_br.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_br_s32
			OPERATION: LD1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_br_s64
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;

IFORM: ld1sh_z_p_bz
	TYPE: instruction
	XML: ld1sh_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001001|xs=x|1|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_s_x32_scaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=01|xs=x|1|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_d_x32_scaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=01|xs=x|0|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_d_x32_unscaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=01|xs=x|0|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_s_x32_unscaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=01|11|Zm=xxxxx|1|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_d_64_scaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 1;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=01|10|Zm=xxxxx|1|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sh_z_p_bz_d_64_unscaled
			OPERATION: LD1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1sw_z_p_ai
	TYPE: instruction
	XML: ld1sw_z_p_ai.xml
	CLASS: sve
		FIELDS32: 1100010|msz=10|01|imm5=xxxxx|1|U=0|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_ai_d
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ld1sw_z_p_bi
	TYPE: instruction
	XML: ld1sw_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_bi_s64
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ld1sw_z_p_br
	TYPE: instruction
	XML: ld1sw_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_br_s64
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;

IFORM: ld1sw_z_p_bz
	TYPE: instruction
	XML: ld1sw_z_p_bz.xml
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=10|xs=x|1|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_bz_d_x32_scaled
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=10|xs=x|0|Zm=xxxxx|0|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_bz_d_x32_unscaled
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=10|11|Zm=xxxxx|1|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_bz_d_64_scaled
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 2;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=10|10|Zm=xxxxx|1|U=0|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1sw_z_p_bz_d_64_unscaled
			OPERATION: LD1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld1w_z_p_ai
	TYPE: instruction
	XML: ld1w_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=10|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_ai_s
			OPERATION: LD1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=10|01|imm5=xxxxx|1|U=1|ff=0|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_ai_d
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ld1w_z_p_bi
	TYPE: instruction
	XML: ld1w_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=0|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bi_u32
			OPERATION: LD1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=1|0|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bi_u64
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ld1w_z_p_br
	TYPE: instruction
	XML: ld1w_z_p_br.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=0|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_br_u32
			OPERATION: LD1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_br_u64
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;

IFORM: ld1w_z_p_bz
	TYPE: instruction
	XML: ld1w_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001010|xs=x|1|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_s_x32_scaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=10|xs=x|1|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_d_x32_scaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=10|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_d_x32_unscaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=10|xs=x|0|Zm=xxxxx|0|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_s_x32_unscaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=10|11|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_d_64_scaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 2;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=10|10|Zm=xxxxx|1|U=1|ff=0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld1w_z_p_bz_d_64_unscaled
			OPERATION: LD1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ld2b_z_p_bi
	TYPE: instruction
	XML: ld2b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=01|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2b_z_p_bi_contiguous
			OPERATION: LD2B
			SYNTAX: {<Zt1>.B,<Zt2>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: ld2b_z_p_br
	TYPE: instruction
	XML: ld2b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=01|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2b_z_p_br_contiguous
			OPERATION: LD2B
			SYNTAX: {<Zt1>.B,<Zt2>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 2;

IFORM: ld2d_z_p_bi
	TYPE: instruction
	XML: ld2d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=01|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2d_z_p_bi_contiguous
			OPERATION: LD2D
			SYNTAX: {<Zt1>.D,<Zt2>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: ld2d_z_p_br
	TYPE: instruction
	XML: ld2d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=01|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2d_z_p_br_contiguous
			OPERATION: LD2D
			SYNTAX: {<Zt1>.D,<Zt2>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 2;

IFORM: ld2h_z_p_bi
	TYPE: instruction
	XML: ld2h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=01|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2h_z_p_bi_contiguous
			OPERATION: LD2H
			SYNTAX: {<Zt1>.H,<Zt2>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: ld2h_z_p_br
	TYPE: instruction
	XML: ld2h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=01|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2h_z_p_br_contiguous
			OPERATION: LD2H
			SYNTAX: {<Zt1>.H,<Zt2>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 2;

IFORM: ld2w_z_p_bi
	TYPE: instruction
	XML: ld2w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=01|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2w_z_p_bi_contiguous
			OPERATION: LD2W
			SYNTAX: {<Zt1>.S,<Zt2>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: ld2w_z_p_br
	TYPE: instruction
	XML: ld2w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=01|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld2w_z_p_br_contiguous
			OPERATION: LD2W
			SYNTAX: {<Zt1>.S,<Zt2>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 2;

IFORM: ld3b_z_p_bi
	TYPE: instruction
	XML: ld3b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=10|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3b_z_p_bi_contiguous
			OPERATION: LD3B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: ld3b_z_p_br
	TYPE: instruction
	XML: ld3b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=10|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3b_z_p_br_contiguous
			OPERATION: LD3B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 3;

IFORM: ld3d_z_p_bi
	TYPE: instruction
	XML: ld3d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=10|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3d_z_p_bi_contiguous
			OPERATION: LD3D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: ld3d_z_p_br
	TYPE: instruction
	XML: ld3d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=10|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3d_z_p_br_contiguous
			OPERATION: LD3D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 3;

IFORM: ld3h_z_p_bi
	TYPE: instruction
	XML: ld3h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=10|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3h_z_p_bi_contiguous
			OPERATION: LD3H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: ld3h_z_p_br
	TYPE: instruction
	XML: ld3h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=10|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3h_z_p_br_contiguous
			OPERATION: LD3H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 3;

IFORM: ld3w_z_p_bi
	TYPE: instruction
	XML: ld3w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=10|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3w_z_p_bi_contiguous
			OPERATION: LD3W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: ld3w_z_p_br
	TYPE: instruction
	XML: ld3w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=10|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld3w_z_p_br_contiguous
			OPERATION: LD3W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 3;

IFORM: ld4b_z_p_bi
	TYPE: instruction
	XML: ld4b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=11|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4b_z_p_bi_contiguous
			OPERATION: LD4B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B,<Zt4>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: ld4b_z_p_br
	TYPE: instruction
	XML: ld4b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|opc=11|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4b_z_p_br_contiguous
			OPERATION: LD4B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B,<Zt4>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 4;

IFORM: ld4d_z_p_bi
	TYPE: instruction
	XML: ld4d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=11|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4d_z_p_bi_contiguous
			OPERATION: LD4D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D,<Zt4>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: ld4d_z_p_br
	TYPE: instruction
	XML: ld4d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|opc=11|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4d_z_p_br_contiguous
			OPERATION: LD4D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D,<Zt4>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 4;

IFORM: ld4h_z_p_bi
	TYPE: instruction
	XML: ld4h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=11|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4h_z_p_bi_contiguous
			OPERATION: LD4H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H,<Zt4>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: ld4h_z_p_br
	TYPE: instruction
	XML: ld4h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|opc=11|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4h_z_p_br_contiguous
			OPERATION: LD4H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H,<Zt4>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 4;

IFORM: ld4w_z_p_bi
	TYPE: instruction
	XML: ld4w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=11|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4w_z_p_bi_contiguous
			OPERATION: LD4W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S,<Zt4>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: ld4w_z_p_br
	TYPE: instruction
	XML: ld4w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|opc=11|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ld4w_z_p_br_contiguous
			OPERATION: LD4W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S,<Zt4>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 4;

IFORM: ldff1b_z_p_ai
	TYPE: instruction
	XML: ldff1b_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=00|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_ai_s
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=00|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_ai_d
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ldff1b_z_p_br
	TYPE: instruction
	XML: ldff1b_z_p_br.xml
	CLASS: 8_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_br_u8
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_br_u16
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_br_u32
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_br_u64
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;

IFORM: ldff1b_z_p_bz
	TYPE: instruction
	XML: ldff1b_z_p_bz.xml
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=00|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=00|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_bz_s_x32_unscaled
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=00|10|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1b_z_p_bz_d_64_unscaled
			OPERATION: LDFF1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1d_z_p_ai
	TYPE: instruction
	XML: ldff1d_z_p_ai.xml
	CLASS: sve
		FIELDS32: 1100010|msz=11|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_ai_d
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ldff1d_z_p_br
	TYPE: instruction
	XML: ldff1d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_br_u64
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #3}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;

IFORM: ldff1d_z_p_bz
	TYPE: instruction
	XML: ldff1d_z_p_bz.xml
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=11|xs=x|1|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_bz_d_x32_scaled
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 3;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=11|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=11|11|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_bz_d_64_scaled
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 3;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=11|10|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1d_z_p_bz_d_64_unscaled
			OPERATION: LDFF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1h_z_p_ai
	TYPE: instruction
	XML: ldff1h_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=01|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_ai_s
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=01|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_ai_d
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ldff1h_z_p_br
	TYPE: instruction
	XML: ldff1h_z_p_br.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_br_u16
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #1}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 16;
			boolean unsigned = TRUE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_br_u32
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #1}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_br_u64
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #1}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;

IFORM: ldff1h_z_p_bz
	TYPE: instruction
	XML: ldff1h_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001001|xs=x|1|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_s_x32_scaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=01|xs=x|1|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_d_x32_scaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=01|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=01|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_s_x32_unscaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=01|11|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_d_64_scaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 1;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=01|10|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1h_z_p_bz_d_64_unscaled
			OPERATION: LDFF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1sb_z_p_ai
	TYPE: instruction
	XML: ldff1sb_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=00|01|imm5=xxxxx|1|U=0|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_ai_s
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=00|01|imm5=xxxxx|1|U=0|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_ai_d
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ldff1sb_z_p_br
	TYPE: instruction
	XML: ldff1sb_z_p_br.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_br_s16
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = FALSE;
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_br_s32
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_br_s64
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;

IFORM: ldff1sb_z_p_bz
	TYPE: instruction
	XML: ldff1sb_z_p_bz.xml
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=00|xs=x|0|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=00|xs=x|0|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_bz_s_x32_unscaled
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=00|10|Zm=xxxxx|1|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sb_z_p_bz_d_64_unscaled
			OPERATION: LDFF1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1sh_z_p_ai
	TYPE: instruction
	XML: ldff1sh_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=01|01|imm5=xxxxx|1|U=0|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_ai_s
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=01|01|imm5=xxxxx|1|U=0|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_ai_d
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ldff1sh_z_p_br
	TYPE: instruction
	XML: ldff1sh_z_p_br.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_br_s32
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #1}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_br_s64
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #1}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;

IFORM: ldff1sh_z_p_bz
	TYPE: instruction
	XML: ldff1sh_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001001|xs=x|1|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_s_x32_scaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=01|xs=x|1|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_d_x32_scaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=01|xs=x|0|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=01|xs=x|0|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_s_x32_unscaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=01|11|Zm=xxxxx|1|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_d_64_scaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 1;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=01|10|Zm=xxxxx|1|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sh_z_p_bz_d_64_unscaled
			OPERATION: LDFF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1sw_z_p_ai
	TYPE: instruction
	XML: ldff1sw_z_p_ai.xml
	CLASS: sve
		FIELDS32: 1100010|msz=10|01|imm5=xxxxx|1|U=0|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_ai_d
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;
			integer offset = UInt(imm5);

IFORM: ldff1sw_z_p_br
	TYPE: instruction
	XML: ldff1sw_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_br_s64
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #2}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;

IFORM: ldff1sw_z_p_bz
	TYPE: instruction
	XML: ldff1sw_z_p_bz.xml
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=10|xs=x|1|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_bz_d_x32_scaled
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=10|xs=x|0|Zm=xxxxx|0|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = FALSE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=10|11|Zm=xxxxx|1|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_bz_d_64_scaled
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 2;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=10|10|Zm=xxxxx|1|U=0|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1sw_z_p_bz_d_64_unscaled
			OPERATION: LDFF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = FALSE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldff1w_z_p_ai
	TYPE: instruction
	XML: ldff1w_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=10|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_ai_s
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=10|01|imm5=xxxxx|1|U=1|ff=1|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_ai_d
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = UInt(imm5);

IFORM: ldff1w_z_p_br
	TYPE: instruction
	XML: ldff1w_z_p_br.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=0|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_br_u32
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #2}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=1|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_br_u64
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{,<Xm>, LSL #2}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;

IFORM: ldff1w_z_p_bz
	TYPE: instruction
	XML: ldff1w_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001010|xs=x|1|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_s_x32_scaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_scaled
		FIELDS32: 1100010|opc=10|xs=x|1|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_d_x32_scaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1100010|msz=10|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_d_x32_unscaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1000010|opc=10|xs=x|0|Zm=xxxxx|0|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_s_x32_unscaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean unsigned = TRUE;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1100010|opc=10|11|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_d_64_scaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 2;
	CLASS: off_d_64_unscaled
		FIELDS32: 1100010|msz=10|10|Zm=xxxxx|1|U=1|ff=1|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldff1w_z_p_bz_d_64_unscaled
			OPERATION: LDFF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean unsigned = TRUE;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: ldnf1b_z_p_bi
	TYPE: instruction
	XML: ldnf1b_z_p_bi.xml
	CLASS: 8_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1b_z_p_bi_u8
			OPERATION: LDNF1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=000|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1b_z_p_bi_u16
			OPERATION: LDNF1B
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1b_z_p_bi_u32
			OPERATION: LDNF1B
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=001|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1b_z_p_bi_u64
			OPERATION: LDNF1B
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ldnf1d_z_p_bi
	TYPE: instruction
	XML: ldnf1d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1d_z_p_bi_u64
			OPERATION: LDNF1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ldnf1h_z_p_bi
	TYPE: instruction
	XML: ldnf1h_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1h_z_p_bi_u16
			OPERATION: LDNF1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1h_z_p_bi_u32
			OPERATION: LDNF1H
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=011|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1h_z_p_bi_u64
			OPERATION: LDNF1H
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ldnf1sb_z_p_bi
	TYPE: instruction
	XML: ldnf1sb_z_p_bi.xml
	CLASS: 16_elem
		FIELDS32: 1010010|dtype<3:1>=111|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sb_z_p_bi_s16
			OPERATION: LDNF1SB
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sb_z_p_bi_s32
			OPERATION: LDNF1SB
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=110|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sb_z_p_bi_s64
			OPERATION: LDNF1SB
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ldnf1sh_z_p_bi
	TYPE: instruction
	XML: ldnf1sh_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sh_z_p_bi_s32
			OPERATION: LDNF1SH
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=100|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sh_z_p_bi_s64
			OPERATION: LDNF1SH
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ldnf1sw_z_p_bi
	TYPE: instruction
	XML: ldnf1sw_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|dtype<3:1>=010|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1sw_z_p_bi_s64
			OPERATION: LDNF1SW
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = FALSE;
			integer offset = SInt(imm4);

IFORM: ldnf1w_z_p_bi
	TYPE: instruction
	XML: ldnf1w_z_p_bi.xml
	CLASS: 32_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=0|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1w_z_p_bi_u32
			OPERATION: LDNF1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);
	CLASS: 64_elem
		FIELDS32: 1010010|dtype<3:1>=101|dtype<0>=1|1|imm4=xxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnf1w_z_p_bi_u64
			OPERATION: LDNF1W
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			boolean unsigned = TRUE;
			integer offset = SInt(imm4);

IFORM: ldnt1b_z_p_bi
	TYPE: instruction
	XML: ldnt1b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|000|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1b_z_p_bi_contiguous
			OPERATION: LDNT1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);

IFORM: ldnt1b_z_p_br
	TYPE: instruction
	XML: ldnt1b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=00|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1b_z_p_br_contiguous
			OPERATION: LDNT1B
			SYNTAX: {<Zt>.B},<Pg>/Z, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;

IFORM: ldnt1d_z_p_bi
	TYPE: instruction
	XML: ldnt1d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|000|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1d_z_p_bi_contiguous
			OPERATION: LDNT1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);

IFORM: ldnt1d_z_p_br
	TYPE: instruction
	XML: ldnt1d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=11|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1d_z_p_br_contiguous
			OPERATION: LDNT1D
			SYNTAX: {<Zt>.D},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;

IFORM: ldnt1h_z_p_bi
	TYPE: instruction
	XML: ldnt1h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|000|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1h_z_p_bi_contiguous
			OPERATION: LDNT1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);

IFORM: ldnt1h_z_p_br
	TYPE: instruction
	XML: ldnt1h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=01|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1h_z_p_br_contiguous
			OPERATION: LDNT1H
			SYNTAX: {<Zt>.H},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;

IFORM: ldnt1w_z_p_bi
	TYPE: instruction
	XML: ldnt1w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|000|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1w_z_p_bi_contiguous
			OPERATION: LDNT1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);

IFORM: ldnt1w_z_p_br
	TYPE: instruction
	XML: ldnt1w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1010010|msz=10|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldnt1w_z_p_br_contiguous
			OPERATION: LDNT1W
			SYNTAX: {<Zt>.S},<Pg>/Z, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;

IFORM: ldr_p_bi
	TYPE: instruction
	XML: ldr_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010110|imm9h=xxxxxx|000|imm9l=xxx|Rn=xxxxx|0|Pt=xxxx
		ENCODING: ldr_p_bi_
			OPERATION: LDR
			SYNTAX: <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Pt);
			integer n = UInt(Rn);
			integer imm = SInt(imm9h:imm9l);

IFORM: ldr_z_bi
	TYPE: instruction
	XML: ldr_z_bi.xml
	CLASS: sve
		FIELDS32: 1000010110|imm9h=xxxxxx|010|imm9l=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: ldr_z_bi_
			OPERATION: LDR
			SYNTAX: <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer imm = SInt(imm9h:imm9l);

IFORM: lsl_z_p_zi
	TYPE: instruction
	XML: lsl_z_p_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|00|opc=00|L=1|U=1|100|Pg=xxx|tszl=xx|imm3=xxx|Zdn=xxxxx
		ENCODING: lsl_z_p_zi_
			OPERATION: LSL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer shift = UInt(tsize:imm3) - esize;

IFORM: lsl_z_p_zw
	TYPE: instruction
	XML: lsl_z_p_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|R=0|L=1|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lsl_z_p_zw_
			OPERATION: LSL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: lsl_z_p_zz
	TYPE: instruction
	XML: lsl_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=0|L=1|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lsl_z_p_zz_
			OPERATION: LSL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: lsl_z_zi
	TYPE: instruction
	XML: lsl_z_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|1|tszl=xx|imm3=xxx|1001|opc=11|Zn=xxxxx|Zd=xxxxx
		ENCODING: lsl_z_zi_
			OPERATION: LSL
			SYNTAX: <Zd>.<T>,<Zn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer shift = UInt(tsize:imm3) - esize;

IFORM: lsl_z_zw
	TYPE: instruction
	XML: lsl_z_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|1000|opc=11|Zn=xxxxx|Zd=xxxxx
		ENCODING: lsl_z_zw_
			OPERATION: LSL
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: lslr_z_p_zz
	TYPE: instruction
	XML: lslr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=1|L=1|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lslr_z_p_zz_
			OPERATION: LSLR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: lsr_z_p_zi
	TYPE: instruction
	XML: lsr_z_p_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|00|opc=00|L=0|U=1|100|Pg=xxx|tszl=xx|imm3=xxx|Zdn=xxxxx
		ENCODING: lsr_z_p_zi_
			OPERATION: LSR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer shift = (2 * esize) - UInt(tsize:imm3);

IFORM: lsr_z_p_zw
	TYPE: instruction
	XML: lsr_z_p_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|R=0|L=0|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lsr_z_p_zw_
			OPERATION: LSR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: lsr_z_p_zz
	TYPE: instruction
	XML: lsr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=0|L=0|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lsr_z_p_zz_
			OPERATION: LSR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: lsr_z_zi
	TYPE: instruction
	XML: lsr_z_zi.xml
	CLASS: sve
		FIELDS32: 00000100|tszh=xx|1|tszl=xx|imm3=xxx|1001|0|U=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: lsr_z_zi_
			OPERATION: LSR
			SYNTAX: <Zd>.<T>,<Zn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			bits(4) tsize = tszh:tszl;
			case tsize of
			    when '0000' UNDEFINED;
			    when '0001' esize = 8;
			    when '001x' esize = 16;
			    when '01xx' esize = 32;
			    when '1xxx' esize = 64;
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer shift = (2 * esize) - UInt(tsize:imm3);

IFORM: lsr_z_zw
	TYPE: instruction
	XML: lsr_z_zw.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|1000|0|U=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: lsr_z_zw_
			OPERATION: LSR
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: lsrr_z_p_zz
	TYPE: instruction
	XML: lsrr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|R=1|L=0|U=1|100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: lsrr_z_p_zz_
			OPERATION: LSRR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: mad_z_p_zzz
	TYPE: instruction
	XML: mad_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0|Zm=xxxxx|11|op=0|Pg=xxx|Za=xxxxx|Zdn=xxxxx
		ENCODING: mad_z_p_zzz_
			OPERATION: MAD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean sub_op = FALSE;

IFORM: mla_z_p_zzz
	TYPE: instruction
	XML: mla_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0|Zm=xxxxx|01|op=0|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: mla_z_p_zzz_
			OPERATION: MLA
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean sub_op = FALSE;

IFORM: mls_z_p_zzz
	TYPE: instruction
	XML: mls_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0|Zm=xxxxx|01|op=1|Pg=xxx|Zn=xxxxx|Zda=xxxxx
		ENCODING: mls_z_p_zzz_
			OPERATION: MLS
			SYNTAX: <Zda>.<T>,<Pg>/M,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean sub_op = TRUE;

IFORM: movprfx_z_p_z
	TYPE: instruction
	XML: movprfx_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|opc=00|M=x|001|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: movprfx_z_p_z_
			OPERATION: MOVPRFX
			SYNTAX: <Zd>.<T>,<Pg>/<ZM>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean merging = (M == '1');

IFORM: movprfx_z_z
	TYPE: instruction
	XML: movprfx_z_z.xml
	CLASS: sve
		FIELDS32: 00000100|opc=00|1|opc2<4:1>=0000|opc2<0>=0|101111|Zn=xxxxx|Zd=xxxxx
		ENCODING: movprfx_z_z_
			OPERATION: MOVPRFX
			SYNTAX: <Zd>,<Zn>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: msb_z_p_zzz
	TYPE: instruction
	XML: msb_z_p_zzz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0|Zm=xxxxx|11|op=1|Pg=xxx|Za=xxxxx|Zdn=xxxxx
		ENCODING: msb_z_p_zzz_
			OPERATION: MSB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zm>.<T>,<Za>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			integer a = UInt(Za);
			boolean sub_op = TRUE;

IFORM: mul_z_p_zz
	TYPE: instruction
	XML: mul_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0100|H=0|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: mul_z_p_zz_
			OPERATION: MUL
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: mul_z_zi
	TYPE: instruction
	XML: mul_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|110|opc<2:1>=00|opc<0>=0|11|o2=0|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: mul_z_zi_
			OPERATION: MUL
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = SInt(imm8);

IFORM: nand_p_p_pp
	TYPE: instruction
	XML: nand_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=1|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: nand_p_p_pp_z
			OPERATION: NAND
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=1|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: nands_p_p_pp_z
			OPERATION: NANDS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: neg_z_p_z
	TYPE: instruction
	XML: neg_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|010|opc<2:1>=11|opc<0>=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: neg_z_p_z_
			OPERATION: NEG
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: nor_p_p_pp
	TYPE: instruction
	XML: nor_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=1|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: nor_p_p_pp_z
			OPERATION: NOR
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=1|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: nors_p_p_pp_z
			OPERATION: NORS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: not_z_p_z
	TYPE: instruction
	XML: not_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=11|opc<0>=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: not_z_p_z_
			OPERATION: NOT
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: orn_p_p_pp
	TYPE: instruction
	XML: orn_p_p_pp.xml
	CLASS: no_s
		FIELDS32: 00100101|op=1|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: orn_p_p_pp_z
			OPERATION: ORN
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=1|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: orns_p_p_pp_z
			OPERATION: ORNS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: orr_p_p_pp
	TYPE: instruction
	XML: orr_p_p_pp.xml
	ALIAS: MOVS_orr_p_p_pp
		S == '1' && Pn == Pm && Pm == Pg
	ALIAS: MOV_orr_p_p_pp
		S == '0' && Pn == Pm && Pm == Pg
	CLASS: no_s
		FIELDS32: 00100101|op=1|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: orr_p_p_pp_z
			OPERATION: ORR
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=1|S=1|00|Pm=xxxx|01|Pg=xxxx|o2=0|Pn=xxxx|o3=0|Pd=xxxx
		ENCODING: orrs_p_p_pp_z
			OPERATION: ORRS
			SYNTAX: <Pd>.B,<Pg>/Z,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: orr_z_p_zz
	TYPE: instruction
	XML: orr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: orr_z_p_zz_
			OPERATION: ORR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: orr_z_zi
	TYPE: instruction
	XML: orr_z_zi.xml
	ALIAS: ORN_orr_z_zi
		Never
	CLASS: sve
		FIELDS32: 00000101|opc=00|0000|imm13=xxxxxxxxxxxxx|Zdn=xxxxx
		ENCODING: orr_z_zi_
			OPERATION: ORR
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<const>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer dn = UInt(Zdn);
			bits(64) imm;
			(imm, -) = DecodeBitMasks(imm13<12>, imm13<5:0>, imm13<11:6>, TRUE);

IFORM: orr_z_zz
	TYPE: instruction
	XML: orr_z_zz.xml
	ALIAS: MOV_orr_z_zz
		Zn == Zm
	CLASS: sve
		FIELDS32: 00000100|opc=01|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: orr_z_zz_
			OPERATION: ORR
			SYNTAX: <Zd>.D,<Zn>.D,<Zm>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: orv_r_p_z
	TYPE: instruction
	XML: orv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|011|opc<2:1>=00|opc<0>=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: orv_r_p_z_
			OPERATION: ORV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: pfalse_p
	TYPE: instruction
	XML: pfalse_p.xml
	CLASS: sve
		FIELDS32: 00100101|op=0|S=0|011000111001|000000|Pd=xxxx
		ENCODING: pfalse_p_
			OPERATION: PFALSE
			SYNTAX: <Pd>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer d = UInt(Pd);

IFORM: pfirst_p_p_p
	TYPE: instruction
	XML: pfirst_p_p_p.xml
	CLASS: sve
		FIELDS32: 00100101|op=0|S=1|011000110000|0|Pg=xxxx|0|Pdn=xxxx
		ENCODING: pfirst_p_p_p_
			OPERATION: PFIRST
			SYNTAX: <Pdn>.B,<Pg>,<Pdn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer dn = UInt(Pdn);

IFORM: pnext_p_p_p
	TYPE: instruction
	XML: pnext_p_p_p.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|011001110001|0|Pg=xxxx|0|Pdn=xxxx
		ENCODING: pnext_p_p_p_
			OPERATION: PNEXT
			SYNTAX: <Pdn>.<T>,<Pg>,<Pdn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Pdn);

IFORM: prfb_i_p_ai
	TYPE: instruction
	XML: prfb_i_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=00|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_ai_s
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 0;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=00|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_ai_d
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 0;
			integer offset = UInt(imm5);

IFORM: prfb_i_p_bi
	TYPE: instruction
	XML: prfb_i_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010111|imm6=xxxxxx|0|msz=00|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_bi_s
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 0;
			integer offset = SInt(imm6);

IFORM: prfb_i_p_br
	TYPE: instruction
	XML: prfb_i_p_br.xml
	CLASS: sve
		FIELDS32: 1000010|msz=00|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_br_s
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 0;

IFORM: prfb_i_p_bz
	TYPE: instruction
	XML: prfb_i_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001000|xs=x|1|Zm=xxxxx|0|msz=00|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_bz_s_x32_scaled
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 0;
	CLASS: off_d_x32_scaled
		FIELDS32: 110001000|xs=x|1|Zm=xxxxx|0|msz=00|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_bz_d_x32_scaled
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 11000100011|Zm=xxxxx|1|msz=00|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfb_i_p_bz_d_64_scaled
			OPERATION: PRFB
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: prfd_i_p_ai
	TYPE: instruction
	XML: prfd_i_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=11|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_ai_s
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 3;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=11|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_ai_d
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 3;
			integer offset = UInt(imm5);

IFORM: prfd_i_p_bi
	TYPE: instruction
	XML: prfd_i_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010111|imm6=xxxxxx|0|msz=11|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_bi_s
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 3;
			integer offset = SInt(imm6);

IFORM: prfd_i_p_br
	TYPE: instruction
	XML: prfd_i_p_br.xml
	CLASS: sve
		FIELDS32: 1000010|msz=11|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_br_s
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 3;

IFORM: prfd_i_p_bz
	TYPE: instruction
	XML: prfd_i_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001000|xs=x|1|Zm=xxxxx|0|msz=11|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_bz_s_x32_scaled
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.S,<mod>#3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 3;
	CLASS: off_d_x32_scaled
		FIELDS32: 110001000|xs=x|1|Zm=xxxxx|0|msz=11|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_bz_d_x32_scaled
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D,<mod>#3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 3;
	CLASS: off_d_64_scaled
		FIELDS32: 11000100011|Zm=xxxxx|1|msz=11|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfd_i_p_bz_d_64_scaled
			OPERATION: PRFD
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 3;

IFORM: prfh_i_p_ai
	TYPE: instruction
	XML: prfh_i_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=01|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_ai_s
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 1;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=01|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_ai_d
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 1;
			integer offset = UInt(imm5);

IFORM: prfh_i_p_bi
	TYPE: instruction
	XML: prfh_i_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010111|imm6=xxxxxx|0|msz=01|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_bi_s
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 1;
			integer offset = SInt(imm6);

IFORM: prfh_i_p_br
	TYPE: instruction
	XML: prfh_i_p_br.xml
	CLASS: sve
		FIELDS32: 1000010|msz=01|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_br_s
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 1;

IFORM: prfh_i_p_bz
	TYPE: instruction
	XML: prfh_i_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001000|xs=x|1|Zm=xxxxx|0|msz=01|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_bz_s_x32_scaled
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 110001000|xs=x|1|Zm=xxxxx|0|msz=01|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_bz_d_x32_scaled
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 1;
	CLASS: off_d_64_scaled
		FIELDS32: 11000100011|Zm=xxxxx|1|msz=01|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfh_i_p_bz_d_64_scaled
			OPERATION: PRFH
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 1;

IFORM: prfw_i_p_ai
	TYPE: instruction
	XML: prfw_i_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1000010|msz=10|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_ai_s
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 2;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1100010|msz=10|00|imm5=xxxxx|111|Pg=xxx|Zn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_ai_d
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 2;
			integer offset = UInt(imm5);

IFORM: prfw_i_p_bi
	TYPE: instruction
	XML: prfw_i_p_bi.xml
	CLASS: sve
		FIELDS32: 1000010111|imm6=xxxxxx|0|msz=10|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_bi_s
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 2;
			integer offset = SInt(imm6);

IFORM: prfw_i_p_br
	TYPE: instruction
	XML: prfw_i_p_br.xml
	CLASS: sve
		FIELDS32: 1000010|msz=10|00|Rm=xxxxx|110|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_br_s
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer scale = 2;

IFORM: prfw_i_p_bz
	TYPE: instruction
	XML: prfw_i_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 100001000|xs=x|1|Zm=xxxxx|0|msz=10|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_bz_s_x32_scaled
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.S,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 2;
	CLASS: off_d_x32_scaled
		FIELDS32: 110001000|xs=x|1|Zm=xxxxx|0|msz=10|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_bz_d_x32_scaled
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 32;
			boolean offs_unsigned = (xs == '0');
			integer scale = 2;
	CLASS: off_d_64_scaled
		FIELDS32: 11000100011|Zm=xxxxx|1|msz=10|Pg=xxx|Rn=xxxxx|0|prfop=xxxx
		ENCODING: prfw_i_p_bz_d_64_scaled
			OPERATION: PRFW
			SYNTAX: <prfop>,<Pg>, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer level = UInt(prfop<2:1>);
			boolean stream = (prfop<0> == '1');
			pref_hint = if prfop<3> == '0' then Prefetch_READ else Prefetch_WRITE;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 2;

IFORM: ptest_p_p
	TYPE: instruction
	XML: ptest_p_p.xml
	CLASS: sve
		FIELDS32: 00|100101|op=0|S=1|01|000011|Pg=xxxx|0|Pn=xxxx|0|opc2=0000
		ENCODING: ptest_p_p_
			OPERATION: PTEST
			SYNTAX: <Pg>,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);

IFORM: ptrue_p_s
	TYPE: instruction
	XML: ptrue_p_s.xml
	CLASS: no_s
		FIELDS32: 00100101|size=xx|01100|S=0|111000|pattern=xxxxx|0|Pd=xxxx
		ENCODING: ptrue_p_s_
			OPERATION: PTRUE
			SYNTAX: <Pd>.<T>{,<pattern>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
			bits(5) pat = pattern;
	CLASS: s
		FIELDS32: 00100101|size=xx|01100|S=1|111000|pattern=xxxxx|0|Pd=xxxx
		ENCODING: ptrues_p_s_
			OPERATION: PTRUES
			SYNTAX: <Pd>.<T>{,<pattern>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer d = UInt(Pd);
			boolean setflags = TRUE;
			bits(5) pat = pattern;

IFORM: punpkhi_p_p
	TYPE: instruction
	XML: punpkhi_p_p.xml
	CLASS: sve_high_half
		FIELDS32: 000001010011000|H=1|010000|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: punpkhi_p_p_
			OPERATION: PUNPKHI
			SYNTAX: <Pd>.H,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean hi = TRUE;
	CLASS: sve_low_half
		FIELDS32: 000001010011000|H=0|010000|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: punpklo_p_p_
			OPERATION: PUNPKLO
			SYNTAX: <Pd>.H,<Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer n = UInt(Pn);
			integer d = UInt(Pd);
			boolean hi = FALSE;

IFORM: rbit_z_p_z
	TYPE: instruction
	XML: rbit_z_p_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|1001|opc=11|100|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: rbit_z_p_z_
			OPERATION: RBIT
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: rdffr_p_f
	TYPE: instruction
	XML: rdffr_p_f.xml
	CLASS: sve
		FIELDS32: 00100101|op=0|S=0|011001111100|000000|Pd=xxxx
		ENCODING: rdffr_p_f_
			OPERATION: RDFFR
			SYNTAX: <Pd>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer d = UInt(Pd);

IFORM: rdffr_p_p_f
	TYPE: instruction
	XML: rdffr_p_p_f.xml
	CLASS: no_s
		FIELDS32: 00100101|op=0|S=0|011000111100|0|Pg=xxxx|0|Pd=xxxx
		ENCODING: rdffr_p_p_f_
			OPERATION: RDFFR
			SYNTAX: <Pd>.B,<Pg>/Z
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer g = UInt(Pg);
			integer d = UInt(Pd);
			boolean setflags = FALSE;
	CLASS: s
		FIELDS32: 00100101|op=0|S=1|011000111100|0|Pg=xxxx|0|Pd=xxxx
		ENCODING: rdffrs_p_p_f_
			OPERATION: RDFFRS
			SYNTAX: <Pd>.B,<Pg>/Z
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer g = UInt(Pg);
			integer d = UInt(Pd);
			boolean setflags = TRUE;

IFORM: rdvl_r_i
	TYPE: instruction
	XML: rdvl_r_i.xml
	CLASS: sve
		FIELDS32: 000001001|op=0|1|opc2<4:1>=1111|opc2<0>=1|01010|imm6=xxxxxx|Rd=xxxxx
		ENCODING: rdvl_r_i_
			OPERATION: RDVL
			SYNTAX: <Xd>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer d = UInt(Rd);
			integer imm = SInt(imm6);

IFORM: rev_p_p
	TYPE: instruction
	XML: rev_p_p.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|110100010000|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: rev_p_p_
			OPERATION: REV
			SYNTAX: <Pd>.<T>,<Pn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer d = UInt(Pd);

IFORM: rev_z_z
	TYPE: instruction
	XML: rev_z_z.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|111000001110|Zn=xxxxx|Zd=xxxxx
		ENCODING: rev_z_z_
			OPERATION: REV
			SYNTAX: <Zd>.<T>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);

IFORM: revb_z_z
	TYPE: instruction
	XML: revb_z_z.xml
	CLASS: esize_byte
		FIELDS32: 00000101|size=xx|1001|opc=00|100|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: revb_z_z_
			OPERATION: REVB
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer swsize = 8;
	CLASS: esize_halfword
		FIELDS32: 00000101|size=xx|1001|opc=01|100|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: revh_z_z_
			OPERATION: REVH
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '1x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer swsize = 16;
	CLASS: esize_word
		FIELDS32: 00000101|size=xx|1001|opc=10|100|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: revw_z_z_
			OPERATION: REVW
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer swsize = 32;

IFORM: sabd_z_p_zz
	TYPE: instruction
	XML: sabd_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=10|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: sabd_z_p_zz_
			OPERATION: SABD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: saddv_r_p_z
	TYPE: instruction
	XML: saddv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|000|opc=00|U=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: saddv_r_p_z_
			OPERATION: SADDV
			SYNTAX: <Dd>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: scvtf_z_p_z
	TYPE: instruction
	XML: scvtf_z_p_z.xml
	CLASS: 16_to_half
		FIELDS32: 01100101|opc=01|010|opc2=01|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_h2fp16
			OPERATION: SCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 16;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_half
		FIELDS32: 01100101|opc=01|010|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_w2fp16
			OPERATION: SCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 16;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_single
		FIELDS32: 01100101|opc=10|010|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_w2s
			OPERATION: SCVTF
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 32;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_double
		FIELDS32: 01100101|opc=11|010|opc2=00|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_w2d
			OPERATION: SCVTF
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 64;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_half
		FIELDS32: 01100101|opc=01|010|opc2=11|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_x2fp16
			OPERATION: SCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 16;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_single
		FIELDS32: 01100101|opc=11|010|opc2=10|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_x2s
			OPERATION: SCVTF
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 32;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_double
		FIELDS32: 01100101|opc=11|010|opc2=11|int_U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: scvtf_z_p_z_x2d
			OPERATION: SCVTF
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 64;
			boolean unsigned = FALSE;
			FPRounding rounding = FPRoundingMode(FPCR[]);

IFORM: sdiv_z_p_zz
	TYPE: instruction
	XML: sdiv_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0101|R=0|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: sdiv_z_p_zz_
			OPERATION: SDIV
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: sdivr_z_p_zz
	TYPE: instruction
	XML: sdivr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0101|R=1|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: sdivr_z_p_zz_
			OPERATION: SDIVR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: sdot_z_zzz
	TYPE: instruction
	XML: sdot_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000100|size=xx|0|Zm=xxxxx|00000|U=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: sdot_z_zzz_
			OPERATION: SDOT
			SYNTAX: <Zda>.<T>,<Zn>.<Tb>,<Zm>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: sdot_z_zzzi
	TYPE: instruction
	XML: sdot_z_zzzi.xml
	CLASS: of_words
		FIELDS32: 01000100|size=10|1|i2=xx|Zm=xxx|00000|U=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: sdot_z_zzzi_s
			OPERATION: SDOT
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
	CLASS: of_doublewords
		FIELDS32: 01000100|size=11|1|i1=x|Zm=xxxx|00000|U=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: sdot_z_zzzi_d
			OPERATION: SDOT
			SYNTAX: <Zda>.D,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: sel_p_p_pp
	TYPE: instruction
	XML: sel_p_p_pp.xml
	ALIAS: MOV_sel_p_p_pp
		Pd == Pm
	CLASS: sve
		FIELDS32: 00100101|op=0|S=0|00|Pm=xxxx|01|Pg=xxxx|o2=1|Pn=xxxx|o3=1|Pd=xxxx
		ENCODING: sel_p_p_pp_
			OPERATION: SEL
			SYNTAX: <Pd>.B,<Pg>,<Pn>.B,<Pm>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);

IFORM: sel_z_p_zz
	TYPE: instruction
	XML: sel_z_p_zz.xml
	ALIAS: MOV_sel_z_p_zz
		Zd == Zm
	CLASS: sve
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|11|Pg=xxxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: sel_z_p_zz_
			OPERATION: SEL
			SYNTAX: <Zd>.<T>,<Pg>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: setffr_f
	TYPE: instruction
	XML: setffr_f.xml
	CLASS: sve
		FIELDS32: 00|100101|opc=00|10|1100100100|000000|0|0|00
		ENCODING: setffr_f_
			OPERATION: SETFFR
			SYNTAX: 
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;

IFORM: shared_pseudocode
	TYPE: pseudocode
	XML: shared_pseudocode.xml

IFORM: smax_z_p_zz
	TYPE: instruction
	XML: smax_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=00|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: smax_z_p_zz_
			OPERATION: SMAX
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: smax_z_zi
	TYPE: instruction
	XML: smax_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|101|00|U=0|11|o2=0|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: smax_z_zi_
			OPERATION: SMAX
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			boolean unsigned = FALSE;
			integer imm = Int(imm8, unsigned);

IFORM: smaxv_r_p_z
	TYPE: instruction
	XML: smaxv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=00|U=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: smaxv_r_p_z_
			OPERATION: SMAXV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean unsigned = FALSE;

IFORM: smin_z_p_zz
	TYPE: instruction
	XML: smin_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=01|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: smin_z_p_zz_
			OPERATION: SMIN
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: smin_z_zi
	TYPE: instruction
	XML: smin_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|101|01|U=0|11|o2=0|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: smin_z_zi_
			OPERATION: SMIN
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			boolean unsigned = FALSE;
			integer imm = Int(imm8, unsigned);

IFORM: sminv_r_p_z
	TYPE: instruction
	XML: sminv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=01|U=0|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: sminv_r_p_z_
			OPERATION: SMINV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean unsigned = FALSE;

IFORM: smmla_z_zzz
	TYPE: instruction
	XML: smmla_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000101|uns=00|0|Zm=xxxxx|100110|Zn=xxxxx|Zda=xxxxx
		ENCODING: smmla_z_zzz_
			OPERATION: SMMLA
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_unsigned = FALSE;
			boolean op2_unsigned = FALSE;

IFORM: smulh_z_p_zz
	TYPE: instruction
	XML: smulh_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0100|H=1|U=0|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: smulh_z_p_zz_
			OPERATION: SMULH
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = FALSE;

IFORM: splice_z_p_zz
	TYPE: instruction
	XML: splice_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|101100100|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: splice_z_p_zz_des
			OPERATION: SPLICE
			SYNTAX: <Zdn>.<T>,<Pg>,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: sqadd_z_zi
	TYPE: instruction
	XML: sqadd_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|10|U=0|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: sqadd_z_zi_
			OPERATION: SQADD
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;
			boolean unsigned = FALSE;

IFORM: sqadd_z_zz
	TYPE: instruction
	XML: sqadd_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|10|U=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: sqadd_z_zz_
			OPERATION: SQADD
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;

IFORM: sqdecb_r_rs
	TYPE: instruction
	XML: sqdecb_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=00|1|sf=0|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecb_r_rs_sx
			OPERATION: SQDECB
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=00|1|sf=1|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecb_r_rs_x
			OPERATION: SQDECB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqdecd_r_rs
	TYPE: instruction
	XML: sqdecd_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=11|1|sf=0|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecd_r_rs_sx
			OPERATION: SQDECD
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=11|1|sf=1|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecd_r_rs_x
			OPERATION: SQDECD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqdecd_z_zs
	TYPE: instruction
	XML: sqdecd_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=11|10|imm4=xxxx|1100|D=1|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqdecd_z_zs_
			OPERATION: SQDECD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqdech_r_rs
	TYPE: instruction
	XML: sqdech_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=01|1|sf=0|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdech_r_rs_sx
			OPERATION: SQDECH
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=01|1|sf=1|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdech_r_rs_x
			OPERATION: SQDECH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqdech_z_zs
	TYPE: instruction
	XML: sqdech_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=01|10|imm4=xxxx|1100|D=1|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqdech_z_zs_
			OPERATION: SQDECH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqdecp_r_p_r
	TYPE: instruction
	XML: sqdecp_r_p_r.xml
	CLASS: 32_fsreg
		FIELDS32: 00100101|size=xx|1010|D=1|U=0|10001|sf=0|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: sqdecp_r_p_r_sx
			OPERATION: SQDECP
			SYNTAX: <Xdn>,<Pm>.<T>,<Wdn>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00100101|size=xx|1010|D=1|U=0|10001|sf=1|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: sqdecp_r_p_r_x
			OPERATION: SQDECP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqdecp_z_p_z
	TYPE: instruction
	XML: sqdecp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1010|D=1|U=0|10000|opc=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: sqdecp_z_p_z_
			OPERATION: SQDECP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);
			boolean unsigned = FALSE;

IFORM: sqdecw_r_rs
	TYPE: instruction
	XML: sqdecw_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=10|1|sf=0|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecw_r_rs_sx
			OPERATION: SQDECW
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=10|1|sf=1|imm4=xxxx|1111|D=1|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqdecw_r_rs_x
			OPERATION: SQDECW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqdecw_z_zs
	TYPE: instruction
	XML: sqdecw_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=10|10|imm4=xxxx|1100|D=1|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqdecw_z_zs_
			OPERATION: SQDECW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqincb_r_rs
	TYPE: instruction
	XML: sqincb_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=00|1|sf=0|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincb_r_rs_sx
			OPERATION: SQINCB
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=00|1|sf=1|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincb_r_rs_x
			OPERATION: SQINCB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqincd_r_rs
	TYPE: instruction
	XML: sqincd_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=11|1|sf=0|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincd_r_rs_sx
			OPERATION: SQINCD
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=11|1|sf=1|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincd_r_rs_x
			OPERATION: SQINCD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqincd_z_zs
	TYPE: instruction
	XML: sqincd_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=11|10|imm4=xxxx|1100|D=0|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqincd_z_zs_
			OPERATION: SQINCD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqinch_r_rs
	TYPE: instruction
	XML: sqinch_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=01|1|sf=0|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqinch_r_rs_sx
			OPERATION: SQINCH
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=01|1|sf=1|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqinch_r_rs_x
			OPERATION: SQINCH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqinch_z_zs
	TYPE: instruction
	XML: sqinch_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=01|10|imm4=xxxx|1100|D=0|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqinch_z_zs_
			OPERATION: SQINCH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqincp_r_p_r
	TYPE: instruction
	XML: sqincp_r_p_r.xml
	CLASS: 32_fsreg
		FIELDS32: 00100101|size=xx|1010|D=0|U=0|10001|sf=0|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: sqincp_r_p_r_sx
			OPERATION: SQINCP
			SYNTAX: <Xdn>,<Pm>.<T>,<Wdn>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00100101|size=xx|1010|D=0|U=0|10001|sf=1|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: sqincp_r_p_r_x
			OPERATION: SQINCP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqincp_z_p_z
	TYPE: instruction
	XML: sqincp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1010|D=0|U=0|10000|opc=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: sqincp_z_p_z_
			OPERATION: SQINCP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);
			boolean unsigned = FALSE;

IFORM: sqincw_r_rs
	TYPE: instruction
	XML: sqincw_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=10|1|sf=0|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincw_r_rs_sx
			OPERATION: SQINCW
			SYNTAX: <Xdn>,<Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=10|1|sf=1|imm4=xxxx|1111|D=0|U=0|pattern=xxxxx|Rdn=xxxxx
		ENCODING: sqincw_r_rs_x
			OPERATION: SQINCW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;
			integer ssize = 64;

IFORM: sqincw_z_zs
	TYPE: instruction
	XML: sqincw_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=10|10|imm4=xxxx|1100|D=0|U=0|pattern=xxxxx|Zdn=xxxxx
		ENCODING: sqincw_z_zs_
			OPERATION: SQINCW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = FALSE;

IFORM: sqsub_z_zi
	TYPE: instruction
	XML: sqsub_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|11|U=0|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: sqsub_z_zi_
			OPERATION: SQSUB
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;
			boolean unsigned = FALSE;

IFORM: sqsub_z_zz
	TYPE: instruction
	XML: sqsub_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|11|U=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: sqsub_z_zz_
			OPERATION: SQSUB
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;

IFORM: st1b_z_p_ai
	TYPE: instruction
	XML: st1b_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1110010|msz=00|11|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_ai_s
			OPERATION: ST1B
			SYNTAX: {<Zt>.S},<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1110010|msz=00|10|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_ai_d
			OPERATION: ST1B
			SYNTAX: {<Zt>.D},<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offset = UInt(imm5);

IFORM: st1b_z_p_bi
	TYPE: instruction
	XML: st1b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|size=xx|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_bi_
			OPERATION: ST1B
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 8;
			integer offset = SInt(imm4);

IFORM: st1b_z_p_br
	TYPE: instruction
	XML: st1b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|00|size=xx|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_br_
			OPERATION: ST1B
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 8;

IFORM: st1b_z_p_bz
	TYPE: instruction
	XML: st1b_z_p_bz.xml
	CLASS: off_d_x32_unscaled
		FIELDS32: 1110010|msz=00|00|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_bz_d_x32_unscaled
			OPERATION: ST1B
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1110010|msz=00|10|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_bz_s_x32_unscaled
			OPERATION: ST1B
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 8;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_unscaled
		FIELDS32: 1110010|msz=00|00|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1b_z_p_bz_d_64_unscaled
			OPERATION: ST1B
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 8;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: st1d_z_p_ai
	TYPE: instruction
	XML: st1d_z_p_ai.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|10|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_ai_d
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offset = UInt(imm5);

IFORM: st1d_z_p_bi
	TYPE: instruction
	XML: st1d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|size=xx|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_bi_
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '11' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 64;
			integer offset = SInt(imm4);

IFORM: st1d_z_p_br
	TYPE: instruction
	XML: st1d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|opc<2:1>=11|opc<0>=1|o2=1|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_br_
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;

IFORM: st1d_z_p_bz
	TYPE: instruction
	XML: st1d_z_p_bz.xml
	CLASS: off_d_x32_scaled
		FIELDS32: 1110010|msz=11|01|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_bz_d_x32_scaled
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>#3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 3;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1110010|msz=11|00|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_bz_d_x32_unscaled
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1110010|msz=11|01|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_bz_d_64_scaled
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 3;
	CLASS: off_d_64_unscaled
		FIELDS32: 1110010|msz=11|00|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1d_z_p_bz_d_64_unscaled
			OPERATION: ST1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 64;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: st1h_z_p_ai
	TYPE: instruction
	XML: st1h_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1110010|msz=01|11|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_ai_s
			OPERATION: ST1H
			SYNTAX: {<Zt>.S},<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1110010|msz=01|10|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_ai_d
			OPERATION: ST1H
			SYNTAX: {<Zt>.D},<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offset = UInt(imm5);

IFORM: st1h_z_p_bi
	TYPE: instruction
	XML: st1h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|size=xx|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bi_
			OPERATION: ST1H
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 16;
			integer offset = SInt(imm4);

IFORM: st1h_z_p_br
	TYPE: instruction
	XML: st1h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|01|size=xx|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_br_
			OPERATION: ST1H
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 16;

IFORM: st1h_z_p_bz
	TYPE: instruction
	XML: st1h_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 1110010|msz=01|11|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_s_x32_scaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Zm>.S,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_scaled
		FIELDS32: 1110010|msz=01|01|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_d_x32_scaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>#1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 1;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1110010|msz=01|00|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_d_x32_unscaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1110010|msz=01|10|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_s_x32_unscaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 16;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1110010|msz=01|01|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_d_64_scaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 1;
	CLASS: off_d_64_unscaled
		FIELDS32: 1110010|msz=01|00|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1h_z_p_bz_d_64_unscaled
			OPERATION: ST1H
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 16;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: st1w_z_p_ai
	TYPE: instruction
	XML: st1w_z_p_ai.xml
	CLASS: 32_elem
		FIELDS32: 1110010|msz=10|11|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_ai_s
			OPERATION: ST1W
			SYNTAX: {<Zt>.S},<Pg>, [<Zn>.S{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offset = UInt(imm5);
	CLASS: 64_elem
		FIELDS32: 1110010|msz=10|10|imm5=xxxxx|101|Pg=xxx|Zn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_ai_d
			OPERATION: ST1W
			SYNTAX: {<Zt>.D},<Pg>, [<Zn>.D{, #<imm>}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Zn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offset = UInt(imm5);

IFORM: st1w_z_p_bi
	TYPE: instruction
	XML: st1w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|size=xx|0|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bi_
			OPERATION: ST1W
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '1x' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 32;
			integer offset = SInt(imm4);

IFORM: st1w_z_p_br
	TYPE: instruction
	XML: st1w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|10|size=xx|Rm=xxxxx|010|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_br_
			OPERATION: ST1W
			SYNTAX: {<Zt>.<T>},<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '1x' then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8 << UInt(size);
			integer msize = 32;

IFORM: st1w_z_p_bz
	TYPE: instruction
	XML: st1w_z_p_bz.xml
	CLASS: off_s_x32_scaled
		FIELDS32: 1110010|msz=10|11|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_s_x32_scaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Zm>.S,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_scaled
		FIELDS32: 1110010|msz=10|01|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_d_x32_scaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>#2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 2;
	CLASS: off_d_x32_unscaled
		FIELDS32: 1110010|msz=10|00|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_d_x32_unscaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_s_x32_unscaled
		FIELDS32: 1110010|msz=10|10|Zm=xxxxx|1|xs=x|0|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_s_x32_unscaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Zm>.S,<mod>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer msize = 32;
			integer offs_size = 32;
			boolean offs_unsigned = xs == '0';
			integer scale = 0;
	CLASS: off_d_64_scaled
		FIELDS32: 1110010|msz=10|01|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_d_64_scaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 2;
	CLASS: off_d_64_unscaled
		FIELDS32: 1110010|msz=10|00|Zm=xxxxx|101|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st1w_z_p_bz_d_64_unscaled
			OPERATION: ST1W
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Zm>.D]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Zm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer msize = 32;
			integer offs_size = 64;
			boolean offs_unsigned = TRUE;
			integer scale = 0;

IFORM: st2b_z_p_bi
	TYPE: instruction
	XML: st2b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=01|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2b_z_p_bi_contiguous
			OPERATION: ST2B
			SYNTAX: {<Zt1>.B,<Zt2>.B},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: st2b_z_p_br
	TYPE: instruction
	XML: st2b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=01|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2b_z_p_br_contiguous
			OPERATION: ST2B
			SYNTAX: {<Zt1>.B,<Zt2>.B},<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 2;

IFORM: st2d_z_p_bi
	TYPE: instruction
	XML: st2d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=01|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2d_z_p_bi_contiguous
			OPERATION: ST2D
			SYNTAX: {<Zt1>.D,<Zt2>.D},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: st2d_z_p_br
	TYPE: instruction
	XML: st2d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=01|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2d_z_p_br_contiguous
			OPERATION: ST2D
			SYNTAX: {<Zt1>.D,<Zt2>.D},<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 2;

IFORM: st2h_z_p_bi
	TYPE: instruction
	XML: st2h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=01|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2h_z_p_bi_contiguous
			OPERATION: ST2H
			SYNTAX: {<Zt1>.H,<Zt2>.H},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: st2h_z_p_br
	TYPE: instruction
	XML: st2h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=01|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2h_z_p_br_contiguous
			OPERATION: ST2H
			SYNTAX: {<Zt1>.H,<Zt2>.H},<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 2;

IFORM: st2w_z_p_bi
	TYPE: instruction
	XML: st2w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=01|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2w_z_p_bi_contiguous
			OPERATION: ST2W
			SYNTAX: {<Zt1>.S,<Zt2>.S},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 2;

IFORM: st2w_z_p_br
	TYPE: instruction
	XML: st2w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=01|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st2w_z_p_br_contiguous
			OPERATION: ST2W
			SYNTAX: {<Zt1>.S,<Zt2>.S},<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 2;

IFORM: st3b_z_p_bi
	TYPE: instruction
	XML: st3b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=10|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3b_z_p_bi_contiguous
			OPERATION: ST3B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: st3b_z_p_br
	TYPE: instruction
	XML: st3b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=10|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3b_z_p_br_contiguous
			OPERATION: ST3B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B},<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 3;

IFORM: st3d_z_p_bi
	TYPE: instruction
	XML: st3d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=10|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3d_z_p_bi_contiguous
			OPERATION: ST3D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: st3d_z_p_br
	TYPE: instruction
	XML: st3d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=10|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3d_z_p_br_contiguous
			OPERATION: ST3D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D},<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 3;

IFORM: st3h_z_p_bi
	TYPE: instruction
	XML: st3h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=10|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3h_z_p_bi_contiguous
			OPERATION: ST3H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: st3h_z_p_br
	TYPE: instruction
	XML: st3h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=10|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3h_z_p_br_contiguous
			OPERATION: ST3H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H},<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 3;

IFORM: st3w_z_p_bi
	TYPE: instruction
	XML: st3w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=10|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3w_z_p_bi_contiguous
			OPERATION: ST3W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 3;

IFORM: st3w_z_p_br
	TYPE: instruction
	XML: st3w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=10|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st3w_z_p_br_contiguous
			OPERATION: ST3W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S},<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 3;

IFORM: st4b_z_p_bi
	TYPE: instruction
	XML: st4b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=11|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4b_z_p_bi_contiguous
			OPERATION: ST4B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B,<Zt4>.B},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: st4b_z_p_br
	TYPE: instruction
	XML: st4b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|opc=11|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4b_z_p_br_contiguous
			OPERATION: ST4B
			SYNTAX: {<Zt1>.B,<Zt2>.B,<Zt3>.B,<Zt4>.B},<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;
			integer nreg = 4;

IFORM: st4d_z_p_bi
	TYPE: instruction
	XML: st4d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=11|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4d_z_p_bi_contiguous
			OPERATION: ST4D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D,<Zt4>.D},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: st4d_z_p_br
	TYPE: instruction
	XML: st4d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|opc=11|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4d_z_p_br_contiguous
			OPERATION: ST4D
			SYNTAX: {<Zt1>.D,<Zt2>.D,<Zt3>.D,<Zt4>.D},<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;
			integer nreg = 4;

IFORM: st4h_z_p_bi
	TYPE: instruction
	XML: st4h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=11|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4h_z_p_bi_contiguous
			OPERATION: ST4H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H,<Zt4>.H},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: st4h_z_p_br
	TYPE: instruction
	XML: st4h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|opc=11|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4h_z_p_br_contiguous
			OPERATION: ST4H
			SYNTAX: {<Zt1>.H,<Zt2>.H,<Zt3>.H,<Zt4>.H},<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;
			integer nreg = 4;

IFORM: st4w_z_p_bi
	TYPE: instruction
	XML: st4w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=11|1|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4w_z_p_bi_contiguous
			OPERATION: ST4W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S,<Zt4>.S},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);
			integer nreg = 4;

IFORM: st4w_z_p_br
	TYPE: instruction
	XML: st4w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|opc=11|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: st4w_z_p_br_contiguous
			OPERATION: ST4W
			SYNTAX: {<Zt1>.S,<Zt2>.S,<Zt3>.S,<Zt4>.S},<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;
			integer nreg = 4;

IFORM: stnt1b_z_p_bi
	TYPE: instruction
	XML: stnt1b_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|001|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1b_z_p_bi_contiguous
			OPERATION: STNT1B
			SYNTAX: {<Zt>.B},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 8;
			integer offset = SInt(imm4);

IFORM: stnt1b_z_p_br
	TYPE: instruction
	XML: stnt1b_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=00|00|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1b_z_p_br_contiguous
			OPERATION: STNT1B
			SYNTAX: {<Zt>.B},<Pg>, [<Xn|SP>,<Xm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 8;

IFORM: stnt1d_z_p_bi
	TYPE: instruction
	XML: stnt1d_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|001|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1d_z_p_bi_contiguous
			OPERATION: STNT1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 64;
			integer offset = SInt(imm4);

IFORM: stnt1d_z_p_br
	TYPE: instruction
	XML: stnt1d_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=11|00|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1d_z_p_br_contiguous
			OPERATION: STNT1D
			SYNTAX: {<Zt>.D},<Pg>, [<Xn|SP>,<Xm>, LSL #3]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 64;

IFORM: stnt1h_z_p_bi
	TYPE: instruction
	XML: stnt1h_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|001|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1h_z_p_bi_contiguous
			OPERATION: STNT1H
			SYNTAX: {<Zt>.H},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 16;
			integer offset = SInt(imm4);

IFORM: stnt1h_z_p_br
	TYPE: instruction
	XML: stnt1h_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=01|00|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1h_z_p_br_contiguous
			OPERATION: STNT1H
			SYNTAX: {<Zt>.H},<Pg>, [<Xn|SP>,<Xm>, LSL #1]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 16;

IFORM: stnt1w_z_p_bi
	TYPE: instruction
	XML: stnt1w_z_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|001|imm4=xxxx|111|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1w_z_p_bi_contiguous
			OPERATION: STNT1W
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer g = UInt(Pg);
			integer esize = 32;
			integer offset = SInt(imm4);

IFORM: stnt1w_z_p_br
	TYPE: instruction
	XML: stnt1w_z_p_br.xml
	CLASS: sve
		FIELDS32: 1110010|msz=10|00|Rm=xxxxx|011|Pg=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: stnt1w_z_p_br_contiguous
			OPERATION: STNT1W
			SYNTAX: {<Zt>.S},<Pg>, [<Xn|SP>,<Xm>, LSL #2]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if Rm == '11111' then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer g = UInt(Pg);
			integer esize = 32;

IFORM: str_p_bi
	TYPE: instruction
	XML: str_p_bi.xml
	CLASS: sve
		FIELDS32: 1110010110|imm9h=xxxxxx|000|imm9l=xxx|Rn=xxxxx|0|Pt=xxxx
		ENCODING: str_p_bi_
			OPERATION: STR
			SYNTAX: <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Pt);
			integer n = UInt(Rn);
			integer imm = SInt(imm9h:imm9l);

IFORM: str_z_bi
	TYPE: instruction
	XML: str_z_bi.xml
	CLASS: sve
		FIELDS32: 1110010110|imm9h=xxxxxx|010|imm9l=xxx|Rn=xxxxx|Zt=xxxxx
		ENCODING: str_z_bi_
			OPERATION: STR
			SYNTAX: <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer t = UInt(Zt);
			integer n = UInt(Rn);
			integer imm = SInt(imm9h:imm9l);

IFORM: sub_z_p_zz
	TYPE: instruction
	XML: sub_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|000|opc<2:1>=00|opc<0>=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: sub_z_p_zz_
			OPERATION: SUB
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: sub_z_zi
	TYPE: instruction
	XML: sub_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|opc<2:1>=00|opc<0>=1|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: sub_z_zi_
			OPERATION: SUB
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: sub_z_zz
	TYPE: instruction
	XML: sub_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|opc<2:1>=00|opc<0>=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: sub_z_zz_
			OPERATION: SUB
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: subr_z_p_zz
	TYPE: instruction
	XML: subr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|000|opc<2:1>=01|opc<0>=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: subr_z_p_zz_
			OPERATION: SUBR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);

IFORM: subr_z_zi
	TYPE: instruction
	XML: subr_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|opc<2:1>=01|opc<0>=1|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: subr_z_zi_
			OPERATION: SUBR
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;

IFORM: sudot_z_zzzi
	TYPE: instruction
	XML: sudot_z_zzzi.xml
	CLASS: sve
		FIELDS32: 01000100|size=10|1|i2=xx|Zm=xxx|00011|U=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: sudot_z_zzzi_s
			OPERATION: SUDOT
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B[<imm>]
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: sunpkhi_z_z
	TYPE: instruction
	XML: sunpkhi_z_z.xml
	CLASS: sve_high_half
		FIELDS32: 00000101|size=xx|1100|U=0|H=1|001110|Zn=xxxxx|Zd=xxxxx
		ENCODING: sunpkhi_z_z_
			OPERATION: SUNPKHI
			SYNTAX: <Zd>.<T>,<Zn>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;
			boolean hi = TRUE;
	CLASS: sve_low_half
		FIELDS32: 00000101|size=xx|1100|U=0|H=0|001110|Zn=xxxxx|Zd=xxxxx
		ENCODING: sunpklo_z_z_
			OPERATION: SUNPKLO
			SYNTAX: <Zd>.<T>,<Zn>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;
			boolean hi = FALSE;

IFORM: sxtb_z_p_z
	TYPE: instruction
	XML: sxtb_z_p_z.xml
	CLASS: esize_byte
		FIELDS32: 00000100|size=xx|010|00|U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: sxtb_z_p_z_
			OPERATION: SXTB
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=xx|010|01|U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: sxth_z_p_z_
			OPERATION: SXTH
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '1x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;
	CLASS: esize_word
		FIELDS32: 00000100|size=xx|010|10|U=0|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: sxtw_z_p_z_
			OPERATION: SXTW
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = FALSE;

IFORM: tbl_z_zz
	TYPE: instruction
	XML: tbl_z_zz.xml
	CLASS: sve
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|001100|Zn=xxxxx|Zd=xxxxx
		ENCODING: tbl_z_zz_1
			OPERATION: TBL
			SYNTAX: <Zd>.<T>,{<Zn>.<T>},<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);

IFORM: trn1_p_pp
	TYPE: instruction
	XML: trn1_p_pp.xml
	CLASS: sve_even
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=10|H=0|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: trn1_p_pp_
			OPERATION: TRN1
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 0;
	CLASS: sve_odd
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=10|H=1|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: trn2_p_pp_
			OPERATION: TRN2
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 1;

IFORM: trn1_z_zz
	TYPE: instruction
	XML: trn1_z_zz.xml
	CLASS: sve_even
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|10|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: trn1_z_zz_
			OPERATION: TRN1
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;
	CLASS: sve_even_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|11|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: trn1_z_zz_q
			OPERATION: TRN1
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;
	CLASS: sve_odd
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|10|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: trn2_z_zz_
			OPERATION: TRN2
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;
	CLASS: sve_odd_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|11|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: trn2_z_zz_q
			OPERATION: TRN2
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;

IFORM: uabd_z_p_zz
	TYPE: instruction
	XML: uabd_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=10|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: uabd_z_p_zz_
			OPERATION: UABD
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: uaddv_r_p_z
	TYPE: instruction
	XML: uaddv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|000|opc=00|U=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: uaddv_r_p_z_
			OPERATION: UADDV
			SYNTAX: <Dd>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);

IFORM: ucvtf_z_p_z
	TYPE: instruction
	XML: ucvtf_z_p_z.xml
	CLASS: 16_to_half
		FIELDS32: 01100101|opc=01|010|opc2=01|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_h2fp16
			OPERATION: UCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.H
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 16;
			integer d_esize = 16;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_half
		FIELDS32: 01100101|opc=01|010|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_w2fp16
			OPERATION: UCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 16;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_single
		FIELDS32: 01100101|opc=10|010|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_w2s
			OPERATION: UCVTF
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 32;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 32_to_double
		FIELDS32: 01100101|opc=11|010|opc2=00|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_w2d
			OPERATION: UCVTF
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.S
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 32;
			integer d_esize = 64;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_half
		FIELDS32: 01100101|opc=01|010|opc2=11|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_x2fp16
			OPERATION: UCVTF
			SYNTAX: <Zd>.H,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 16;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_single
		FIELDS32: 01100101|opc=11|010|opc2=10|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_x2s
			OPERATION: UCVTF
			SYNTAX: <Zd>.S,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 32;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);
	CLASS: 64_to_double
		FIELDS32: 01100101|opc=11|010|opc2=11|int_U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: ucvtf_z_p_z_x2d
			OPERATION: UCVTF
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			integer s_esize = 64;
			integer d_esize = 64;
			boolean unsigned = TRUE;
			FPRounding rounding = FPRoundingMode(FPCR[]);

IFORM: udiv_z_p_zz
	TYPE: instruction
	XML: udiv_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0101|R=0|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: udiv_z_p_zz_
			OPERATION: UDIV
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: udivr_z_p_zz
	TYPE: instruction
	XML: udivr_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0101|R=1|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: udivr_z_p_zz_
			OPERATION: UDIVR
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: udot_z_zzz
	TYPE: instruction
	XML: udot_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000100|size=xx|0|Zm=xxxxx|00000|U=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: udot_z_zzz_
			OPERATION: UDOT
			SYNTAX: <Zda>.<T>,<Zn>.<Tb>,<Zm>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '0x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: udot_z_zzzi
	TYPE: instruction
	XML: udot_z_zzzi.xml
	CLASS: of_words
		FIELDS32: 01000100|size=10|1|i2=xx|Zm=xxx|00000|U=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: udot_z_zzzi_s
			OPERATION: UDOT
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
	CLASS: of_doublewords
		FIELDS32: 01000100|size=11|1|i1=x|Zm=xxxx|00000|U=1|Zn=xxxxx|Zda=xxxxx
		ENCODING: udot_z_zzzi_d
			OPERATION: UDOT
			SYNTAX: <Zda>.D,<Zn>.H,<Zm>.H[<imm>]
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer index = UInt(i1);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: umax_z_p_zz
	TYPE: instruction
	XML: umax_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=00|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: umax_z_p_zz_
			OPERATION: UMAX
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: umax_z_zi
	TYPE: instruction
	XML: umax_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|101|00|U=1|11|o2=0|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: umax_z_zi_
			OPERATION: UMAX
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			boolean unsigned = TRUE;
			integer imm = Int(imm8, unsigned);

IFORM: umaxv_r_p_z
	TYPE: instruction
	XML: umaxv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=00|U=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: umaxv_r_p_z_
			OPERATION: UMAXV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean unsigned = TRUE;

IFORM: umin_z_p_zz
	TYPE: instruction
	XML: umin_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=01|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: umin_z_p_zz_
			OPERATION: UMIN
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: umin_z_zi
	TYPE: instruction
	XML: umin_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|101|01|U=1|11|o2=0|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: umin_z_zi_
			OPERATION: UMIN
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			boolean unsigned = TRUE;
			integer imm = Int(imm8, unsigned);

IFORM: uminv_r_p_z
	TYPE: instruction
	XML: uminv_r_p_z.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|001|opc=01|U=1|001|Pg=xxx|Zn=xxxxx|Vd=xxxxx
		ENCODING: uminv_r_p_z_
			OPERATION: UMINV
			SYNTAX: <V><d>,<Pg>,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Vd);
			boolean unsigned = TRUE;

IFORM: ummla_z_zzz
	TYPE: instruction
	XML: ummla_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000101|uns=11|0|Zm=xxxxx|100110|Zn=xxxxx|Zda=xxxxx
		ENCODING: ummla_z_zzz_
			OPERATION: UMMLA
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_unsigned = TRUE;
			boolean op2_unsigned = TRUE;

IFORM: umulh_z_p_zz
	TYPE: instruction
	XML: umulh_z_p_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|0100|H=1|U=1|000|Pg=xxx|Zm=xxxxx|Zdn=xxxxx
		ENCODING: umulh_z_p_zz_
			OPERATION: UMULH
			SYNTAX: <Zdn>.<T>,<Pg>/M,<Zdn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer g = UInt(Pg);
			integer dn = UInt(Zdn);
			integer m = UInt(Zm);
			boolean unsigned = TRUE;

IFORM: uqadd_z_zi
	TYPE: instruction
	XML: uqadd_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|10|U=1|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: uqadd_z_zi_
			OPERATION: UQADD
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;
			boolean unsigned = TRUE;

IFORM: uqadd_z_zz
	TYPE: instruction
	XML: uqadd_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|10|U=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: uqadd_z_zz_
			OPERATION: UQADD
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;

IFORM: uqdecb_r_rs
	TYPE: instruction
	XML: uqdecb_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=00|1|sf=0|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecb_r_rs_uw
			OPERATION: UQDECB
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=00|1|sf=1|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecb_r_rs_x
			OPERATION: UQDECB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqdecd_r_rs
	TYPE: instruction
	XML: uqdecd_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=11|1|sf=0|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecd_r_rs_uw
			OPERATION: UQDECD
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=11|1|sf=1|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecd_r_rs_x
			OPERATION: UQDECD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqdecd_z_zs
	TYPE: instruction
	XML: uqdecd_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=11|10|imm4=xxxx|1100|D=1|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqdecd_z_zs_
			OPERATION: UQDECD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqdech_r_rs
	TYPE: instruction
	XML: uqdech_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=01|1|sf=0|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdech_r_rs_uw
			OPERATION: UQDECH
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=01|1|sf=1|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdech_r_rs_x
			OPERATION: UQDECH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqdech_z_zs
	TYPE: instruction
	XML: uqdech_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=01|10|imm4=xxxx|1100|D=1|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqdech_z_zs_
			OPERATION: UQDECH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqdecp_r_p_r
	TYPE: instruction
	XML: uqdecp_r_p_r.xml
	CLASS: 32_fsreg
		FIELDS32: 00100101|size=xx|1010|D=1|U=1|10001|sf=0|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: uqdecp_r_p_r_uw
			OPERATION: UQDECP
			SYNTAX: <Wdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00100101|size=xx|1010|D=1|U=1|10001|sf=1|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: uqdecp_r_p_r_x
			OPERATION: UQDECP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqdecp_z_p_z
	TYPE: instruction
	XML: uqdecp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1010|D=1|U=1|10000|opc=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: uqdecp_z_p_z_
			OPERATION: UQDECP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);
			boolean unsigned = TRUE;

IFORM: uqdecw_r_rs
	TYPE: instruction
	XML: uqdecw_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=10|1|sf=0|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecw_r_rs_uw
			OPERATION: UQDECW
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=10|1|sf=1|imm4=xxxx|1111|D=1|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqdecw_r_rs_x
			OPERATION: UQDECW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqdecw_z_zs
	TYPE: instruction
	XML: uqdecw_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=10|10|imm4=xxxx|1100|D=1|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqdecw_z_zs_
			OPERATION: UQDECW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqincb_r_rs
	TYPE: instruction
	XML: uqincb_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=00|1|sf=0|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincb_r_rs_uw
			OPERATION: UQINCB
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=00|1|sf=1|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincb_r_rs_x
			OPERATION: UQINCB
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqincd_r_rs
	TYPE: instruction
	XML: uqincd_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=11|1|sf=0|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincd_r_rs_uw
			OPERATION: UQINCD
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=11|1|sf=1|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincd_r_rs_x
			OPERATION: UQINCD
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqincd_z_zs
	TYPE: instruction
	XML: uqincd_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=11|10|imm4=xxxx|1100|D=0|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqincd_z_zs_
			OPERATION: UQINCD
			SYNTAX: <Zdn>.D{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 64;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqinch_r_rs
	TYPE: instruction
	XML: uqinch_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=01|1|sf=0|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqinch_r_rs_uw
			OPERATION: UQINCH
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=01|1|sf=1|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqinch_r_rs_x
			OPERATION: UQINCH
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqinch_z_zs
	TYPE: instruction
	XML: uqinch_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=01|10|imm4=xxxx|1100|D=0|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqinch_z_zs_
			OPERATION: UQINCH
			SYNTAX: <Zdn>.H{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 16;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqincp_r_p_r
	TYPE: instruction
	XML: uqincp_r_p_r.xml
	CLASS: 32_fsreg
		FIELDS32: 00100101|size=xx|1010|D=0|U=1|10001|sf=0|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: uqincp_r_p_r_uw
			OPERATION: UQINCP
			SYNTAX: <Wdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00100101|size=xx|1010|D=0|U=1|10001|sf=1|op=0|Pm=xxxx|Rdn=xxxxx
		ENCODING: uqincp_r_p_r_x
			OPERATION: UQINCP
			SYNTAX: <Xdn>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Rdn);
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqincp_z_p_z
	TYPE: instruction
	XML: uqincp_z_p_z.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1010|D=0|U=1|10000|opc=00|Pm=xxxx|Zdn=xxxxx
		ENCODING: uqincp_z_p_z_
			OPERATION: UQINCP
			SYNTAX: <Zdn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer m = UInt(Pm);
			integer dn = UInt(Zdn);
			boolean unsigned = TRUE;

IFORM: uqincw_r_rs
	TYPE: instruction
	XML: uqincw_r_rs.xml
	CLASS: 32_fsreg
		FIELDS32: 00000100|size=10|1|sf=0|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincw_r_rs_uw
			OPERATION: UQINCW
			SYNTAX: <Wdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 32;
	CLASS: 64_fsreg
		FIELDS32: 00000100|size=10|1|sf=1|imm4=xxxx|1111|D=0|U=1|pattern=xxxxx|Rdn=xxxxx
		ENCODING: uqincw_r_rs_x
			OPERATION: UQINCW
			SYNTAX: <Xdn>{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Rdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;
			integer ssize = 64;

IFORM: uqincw_z_zs
	TYPE: instruction
	XML: uqincw_z_zs.xml
	CLASS: sve
		FIELDS32: 00000100|size=10|10|imm4=xxxx|1100|D=0|U=1|pattern=xxxxx|Zdn=xxxxx
		ENCODING: uqincw_z_zs_
			OPERATION: UQINCW
			SYNTAX: <Zdn>.S{,<pattern>{, MUL #<imm>}}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 32;
			integer dn = UInt(Zdn);
			bits(5) pat = pattern;
			integer imm = UInt(imm4) + 1;
			boolean unsigned = TRUE;

IFORM: uqsub_z_zi
	TYPE: instruction
	XML: uqsub_z_zi.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|100|11|U=1|11|sh=x|imm8=xxxxxxxx|Zdn=xxxxx
		ENCODING: uqsub_z_zi_
			OPERATION: UQSUB
			SYNTAX: <Zdn>.<T>,<Zdn>.<T>, #<imm>{,<shift>}
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size:sh == '001' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer dn = UInt(Zdn);
			integer imm = UInt(imm8);
			if sh == '1' then imm = imm << 8;
			boolean unsigned = TRUE;

IFORM: uqsub_z_zz
	TYPE: instruction
	XML: uqsub_z_zz.xml
	CLASS: sve
		FIELDS32: 00000100|size=xx|1|Zm=xxxxx|000|11|U=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: uqsub_z_zz_
			OPERATION: UQSUB
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;

IFORM: usdot_z_zzz
	TYPE: instruction
	XML: usdot_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000100|size=10|0|Zm=xxxxx|011110|Zn=xxxxx|Zda=xxxxx
		ENCODING: usdot_z_zzz_s
			OPERATION: USDOT
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer esize = 32;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: usdot_z_zzzi
	TYPE: instruction
	XML: usdot_z_zzzi.xml
	CLASS: sve
		FIELDS32: 01000100|size=10|1|i2=xx|Zm=xxx|00011|U=0|Zn=xxxxx|Zda=xxxxx
		ENCODING: usdot_z_zzzi_s
			OPERATION: USDOT
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B[<imm>]
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer esize = 32;
			integer index = UInt(i2);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);

IFORM: usmmla_z_zzz
	TYPE: instruction
	XML: usmmla_z_zzz.xml
	CLASS: sve
		FIELDS32: 01000101|uns=10|0|Zm=xxxxx|100110|Zn=xxxxx|Zda=xxxxx
		ENCODING: usmmla_z_zzz_
			OPERATION: USMMLA
			SYNTAX: <Zda>.S,<Zn>.B,<Zm>.B
		DECODE_PCODE:
			if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer da = UInt(Zda);
			boolean op1_unsigned = TRUE;
			boolean op2_unsigned = FALSE;

IFORM: uunpkhi_z_z
	TYPE: instruction
	XML: uunpkhi_z_z.xml
	CLASS: sve_high_half
		FIELDS32: 00000101|size=xx|1100|U=1|H=1|001110|Zn=xxxxx|Zd=xxxxx
		ENCODING: uunpkhi_z_z_
			OPERATION: UUNPKHI
			SYNTAX: <Zd>.<T>,<Zn>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;
			boolean hi = TRUE;
	CLASS: sve_low_half
		FIELDS32: 00000101|size=xx|1100|U=1|H=0|001110|Zn=xxxxx|Zd=xxxxx
		ENCODING: uunpklo_z_z_
			OPERATION: UUNPKLO
			SYNTAX: <Zd>.<T>,<Zn>.<Tb>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;
			boolean hi = FALSE;

IFORM: uxtb_z_p_z
	TYPE: instruction
	XML: uxtb_z_p_z.xml
	CLASS: esize_byte
		FIELDS32: 00000100|size=xx|010|00|U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: uxtb_z_p_z_
			OPERATION: UXTB
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size == '00' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 8;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;
	CLASS: esize_halfword
		FIELDS32: 00000100|size=xx|010|01|U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: uxth_z_p_z_
			OPERATION: UXTH
			SYNTAX: <Zd>.<T>,<Pg>/M,<Zn>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '1x' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 16;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;
	CLASS: esize_word
		FIELDS32: 00000100|size=xx|010|10|U=1|101|Pg=xxx|Zn=xxxxx|Zd=xxxxx
		ENCODING: uxtw_z_p_z_
			OPERATION: UXTW
			SYNTAX: <Zd>.D,<Pg>/M,<Zn>.D
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			if size != '11' then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer s_esize = 32;
			integer g = UInt(Pg);
			integer n = UInt(Zn);
			integer d = UInt(Zd);
			boolean unsigned = TRUE;

IFORM: uzp1_p_pp
	TYPE: instruction
	XML: uzp1_p_pp.xml
	CLASS: sve_even
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=01|H=0|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: uzp1_p_pp_
			OPERATION: UZP1
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 0;
	CLASS: sve_odd
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=01|H=1|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: uzp2_p_pp_
			OPERATION: UZP2
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 1;

IFORM: uzp1_z_zz
	TYPE: instruction
	XML: uzp1_z_zz.xml
	CLASS: sve_even
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|01|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: uzp1_z_zz_
			OPERATION: UZP1
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;
	CLASS: sve_even_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|01|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: uzp1_z_zz_q
			OPERATION: UZP1
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;
	CLASS: sve_odd
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|01|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: uzp2_z_zz_
			OPERATION: UZP2
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;
	CLASS: sve_odd_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|01|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: uzp2_z_zz_q
			OPERATION: UZP2
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;

IFORM: whilele_p_p_rr
	TYPE: instruction
	XML: whilele_p_p_rr.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1|Rm=xxxxx|000|sf=x|U=0|lt=1|Rn=xxxxx|eq=1|Pd=xxxx
		ENCODING: whilele_p_p_rr_
			OPERATION: WHILELE
			SYNTAX: <Pd>.<T>,<R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = 32 << UInt(sf);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Pd);
			boolean unsigned = FALSE;
			SVECmp op = Cmp_LE;

IFORM: whilelo_p_p_rr
	TYPE: instruction
	XML: whilelo_p_p_rr.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1|Rm=xxxxx|000|sf=x|U=1|lt=1|Rn=xxxxx|eq=0|Pd=xxxx
		ENCODING: whilelo_p_p_rr_
			OPERATION: WHILELO
			SYNTAX: <Pd>.<T>,<R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = 32 << UInt(sf);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Pd);
			boolean unsigned = TRUE;
			SVECmp op = Cmp_LT;

IFORM: whilels_p_p_rr
	TYPE: instruction
	XML: whilels_p_p_rr.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1|Rm=xxxxx|000|sf=x|U=1|lt=1|Rn=xxxxx|eq=1|Pd=xxxx
		ENCODING: whilels_p_p_rr_
			OPERATION: WHILELS
			SYNTAX: <Pd>.<T>,<R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = 32 << UInt(sf);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Pd);
			boolean unsigned = TRUE;
			SVECmp op = Cmp_LE;

IFORM: whilelt_p_p_rr
	TYPE: instruction
	XML: whilelt_p_p_rr.xml
	CLASS: sve
		FIELDS32: 00100101|size=xx|1|Rm=xxxxx|000|sf=x|U=0|lt=1|Rn=xxxxx|eq=0|Pd=xxxx
		ENCODING: whilelt_p_p_rr_
			OPERATION: WHILELT
			SYNTAX: <Pd>.<T>,<R><n>,<R><m>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer rsize = 32 << UInt(sf);
			integer n = UInt(Rn);
			integer m = UInt(Rm);
			integer d = UInt(Pd);
			boolean unsigned = FALSE;
			SVECmp op = Cmp_LT;

IFORM: wrffr_f_p
	TYPE: instruction
	XML: wrffr_f_p.xml
	CLASS: sve
		FIELDS32: 00|100101|opc=00|10|1000100100|0|Pn=xxxx|0|0|0|00
		ENCODING: wrffr_f_p_
			OPERATION: WRFFR
			SYNTAX: <Pn>.B
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer n = UInt(Pn);

IFORM: zip1_p_pp
	TYPE: instruction
	XML: zip1_p_pp.xml
	CLASS: sve_high_halves
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=00|H=1|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: zip2_p_pp_
			OPERATION: ZIP2
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 1;
	CLASS: sve_low_halves
		FIELDS32: 00000101|size=xx|10|Pm=xxxx|010|opc=00|H=0|0|Pn=xxxx|0|Pd=xxxx
		ENCODING: zip1_p_pp_
			OPERATION: ZIP1
			SYNTAX: <Pd>.<T>,<Pn>.<T>,<Pm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Pn);
			integer m = UInt(Pm);
			integer d = UInt(Pd);
			integer part = 0;

IFORM: zip1_z_zz
	TYPE: instruction
	XML: zip1_z_zz.xml
	CLASS: sve_high_halves
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|00|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: zip2_z_zz_
			OPERATION: ZIP2
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;
	CLASS: sve_high_halves_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|00|H=1|Zn=xxxxx|Zd=xxxxx
		ENCODING: zip2_z_zz_q
			OPERATION: ZIP2
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 1;
	CLASS: sve_low_halves
		FIELDS32: 00000101|size=xx|1|Zm=xxxxx|011|00|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: zip1_z_zz_
			OPERATION: ZIP1
			SYNTAX: <Zd>.<T>,<Zn>.<T>,<Zm>.<T>
		DECODE_PCODE:
			if !HaveSVE() then UNDEFINED;
			integer esize = 8 << UInt(size);
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;
	CLASS: sve_low_halves_quad
		FIELDS32: 000001011|op=0|1|Zm=xxxxx|000|00|H=0|Zn=xxxxx|Zd=xxxxx
		ENCODING: zip1_z_zz_q
			OPERATION: ZIP1
			SYNTAX: <Zd>.Q,<Zn>.Q,<Zm>.Q
		DECODE_PCODE:
			if !HaveSVEFP64MatMulExt() then UNDEFINED;
			integer esize = 128;
			integer n = UInt(Zn);
			integer m = UInt(Zm);
			integer d = UInt(Zd);
			integer part = 0;

