The "exchange" part in arm/thumb instructions like `bx` and `blx` have confused me for too long. It's time I run some tests (using [unicorn engine emulator](https://www.unicorn-engine.org/)) and commit these instructions' behavior to memory once and for all.

**Summary**:

1. when the operand is an **absolute** address, the lsb marks the destination mode (0 for arm, 1 for thumb)
2. when the operand is a register, it contains an **absolute** address, see rule #1
3. when the operand is a **relative address** (displacement), the mode always toggles (exchanges) with the current mode

In other words, exchange instructions that use a register **may** change the state while instructions that use displacements **will** change the state.

**Tabulated**:

| instruction                  | destination mode                           | toggles? |
| ---------------------------- | ------------------------------------------ | -------- |
| `bx Rm`<br />`bx{cond} Rm`   | lsb of Rm                                  | maybe    |
| `blx Rm`<br />`blx{cond} Rm` | lsb of Rm                                  | maybe    |
| `mov pc, Rm`                 | lsb of Rm                                  | maybe    |
| `ldm Rm, {..., pc}`          | lsb of Rm                                  | maybe    |
| `bx label`                   | (this instruction form doesn't exist)      |          |
| `blx label`                  | opposite of current mode (always exchange) | always   |

The link register `lr` will be set by `blx` to the pointer to instruction following the source instruction. If the source of the branch was in thumb mode, the pointer will have its lsb set, otherwise it will be cleared.

## Thumb function pointers, not addresses, have lsb set

It's a common misconception the arm/thumb state is stored in the lsb of PC, or that thumb functions start at odd misaligned boundaries. This is not true. The **address** in PC and the **address** of all functions are always aligned on even boundaries.

The function **pointers**, however, may have a lsb set to signal `bx` and `blx` to set the appropriate destination mode.

So a `blx` to function **pointer** 0x4000001 executes the function stored at **address** 0x4000000  in thumb mode.

Sometimes the address and pointer have the same value. A `blx` to function **pointer** 0x4001000 executes the function stored at **address** 0x4001000 in arm mode.

The actual arm/thumb state is stored in the T bit (bit 5) of the CPSR.

## experiments: bx rm

### arm to arm

The T flag **remains clear** because the lsb of pointer 0 is clear:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000000  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000000  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### arm to thumb

The T flag **is set** because the lsb of pointer 1 is set:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

The T flag **is cleared** because the lsb of pointer 1 is clear:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### thumb to thumb 

The T flag **remains set** because the lsb of pointer 1 is set:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> bx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

## experiments: blx rm

### arm to arm

The T flag **remains clear** and `lr` points to next arm instruction at 0xC:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000D  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### arm to thumb

The T flag **is set** and `lr` points to the next arm instruction at 0xC:

```
> pc = 8
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000008
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

The T flag **is cleared** and `lr` points with value 0xB to the thumb instruction at actual address 0xA:

```
> r3 = 0
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000C  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000B  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

### thumb to thumb

The T flag **remains clear** and `lr` points with value 0xB to the thumb instruction at actual address 0xA:

```
> r
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx r3
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000001
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000B  pc=0000000000000000
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

## experiments: blx label

### arm to thumb

Though the effective address is 8, with lsb clear, the displacement form of blx **always changes** state, so the T flag goes from clear to set:

```
> pc = 0
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000005  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
> blx 8
arm-assembled 00000000: 000000fa  (4 bytes)
starting emulation at pointer: 0x00000000
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

### thumb to arm

Bouncing back to 0, the displacement form of blx again **always changes** state, so the T flag goes from set to clear:

```
> r
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=0000000000000004  pc=0000000000000008
 cpsr=00000000400001F3 (N=0 Z=1 C=0 V=0 T=1)
> blx 0
thumb-assembled 00000008: fff7faef  (4 bytes)
starting emulation at pointer: 0x00000009
 r0=0000000000000000  r1=0000000000000000  r2=0000000000000000  r3=0000000000000000
 r4=0000000000000000  r5=0000000000000000  r6=0000000000000000  r7=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000 r11=0000000000000000
 ip=0000000000000000  sp=0000000000000000  lr=000000000000000D  pc=0000000000000000
 cpsr=00000000400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

## experiment: ldm Rm, {..., pc}

At address 0x10 I have set up four odd pointers: 0x00000011, 0x00000021, 0x00000031, 0x00000041:

```
> db 0x10
00000010: 11 00 00 00 21 00 00 00 31 00 00 00 41 00 00 00  ....!...1...A...
```

Now set r5 to point at this memory and load multiple:

```
> r5 = 0x10
> ldm r5, {r0, r1, r2, pc}
 r0=00000011  r1=00000021  r2=00000031  r3=00000000
 r4=00000000  r5=00000010  r6=00000000  r7=00000000
 r8=00000000  r9=00000000 r10=00000000 r11=00000000
 ip=00000000  sp=00000000  lr=00000000  pc=00000040
 cpsr=400001F3 (N=0 Z=1 C=0 V=0 T=1)
```

Registers r0, r1, r2 picked up the first three pointers, and PC picked up the fourth address (lsb stripped from pointer) and transitioned to thumb.

I set them to even pointers and execute the same `ldm`:

```
> ldm r5, {r0, r1, r2, pc}
thumb-assembled 00000040: 95e80780  (4 bytes)
starting emulation at pointer: 0x00000041
 r0=00000010  r1=00000020  r2=00000030  r3=00000000
 r4=00000000  r5=00000010  r6=00000000  r7=00000000
 r8=00000000  r9=00000000 r10=00000000 r11=00000000
 ip=00000000  sp=00000000  lr=00000000  pc=00000040
 cpsr=400001D3 (N=0 Z=1 C=0 V=0 T=0)
```

And we return to ARM mode.

Created: 2022-03-10